initSidebarItems({"enum":[["PoolPartition","Kernel memory pool."],["ProcInfoAddrSpace","Address space type to use when creating a process."]],"fn":[["accept_session","Accept a connection on the given port."],["clear_event","Clear the \"signaled\" state of an event. After calling this on a signaled event, [wait_synchronization()] on this handle will wait until [signal_event()] is called once again."],["close_handle","Close the given handle."],["connect_to_named_port","Creates a session to the given named port."],["connect_to_port","Connects to the given named port."],["create_event","Create a [ReadableEvent]/[WritableEvent] pair."],["create_interrupt_event","Create a waitable object for the given IRQ number."],["create_port","Creates an anonymous port."],["create_process","Creates a new process with the given parameters."],["create_session","Create an anonymous session."],["create_shared_memory","Creates a shared memory handle."],["create_thread","Creates a thread in the current process."],["exit_process","Exits the process, killing all threads."],["exit_thread","Exits the current thread."],["get_process_id","Gets the PID of the given Process handle. Alias handles (0xFFFF8000 and 0xFFFF8001) are not allowed here. PIDs are global, unique identifiers for a given process. PIDs are never reused, and can be passed over IPC safely (the kernel ensures the correct pid is passed when a process does a request), making them the best way for sysmodule to identify a calling process."],["get_process_info","Extract information from a process."],["get_process_list","Fills the provided array with the pids of currently living processes. A process \"lives\" so long as it is currently running or a handle to it still exists."],["manage_named_port","Creates a named port."],["map_framebuffer","Maps the framebuffer to a kernel-chosen address."],["map_mmio_region","Maps a physical region in the address space of the process."],["map_process_memory","Maps the given src memory range from a remote process into the current process as RW-. This is used by the Loader to load binaries into the memory region allocated by the kernel in `create_process`."],["map_shared_memory","Maps a shared memory."],["output_debug_string","Print the given string to the kernel's debug output."],["query_memory","Query information about an address. Will fetch the page-aligned mapping `addr` falls in. mapping that contains the provided address."],["query_physical_address","Gets the physical region a given virtual address maps."],["reply_and_receive_with_user_buffer","Reply and Receive IPC requests on the given handles."],["reset_signal","Clear the \"signaled\" state of a readable event or process. After calling this on a signaled event, [wait_synchronization()] on this handle will wait until the handle is signaled again."],["send_sync_request_with_user_buffer","Send an IPC request through the given pipe."],["set_heap_size","Resize the heap of a process, just like a brk. It can both expand, and shrink the heap."],["set_process_memory_permission","Change permission of a page-aligned memory region. Acceptable permissions are ---, r-- and rw-. In other words, it is not allowed to set the executable bit, nor is it acceptable to use write-only permissions."],["set_thread_area","Set thread local area pointer."],["signal_event","Sets the \"signaled\" state of an event. Calling this on an unsignalled event will cause any thread waiting on this event through [wait_synchronization()] to wake up. Any future calls to [wait_synchronization()] with this handle will immediately return - the user has to clear the \"signaled\" state through [clear_event()]."],["sleep_thread","Sleeps for a specified amount of time, or yield thread."],["start_process","Start the given process on the provided CPU with the provided scheduler priority."],["start_thread","Starts the thread for the provided handle."],["syscall","Generic syscall function."],["syscall_inner",""],["terminate_process","Kills the given process, terminating the execution of all of its thread and putting its state to Exiting/Exited."],["unmap_process_memory","Unmaps a memory range mapped with [map_process_memory()]. `dst_addr` is an address in the current address space, while `src_addr` is the address in the remote address space that was previously mapped."],["unmap_shared_memory","Unmaps a shared memory."],["wait_synchronization","Wait for an event on the given handles."]],"mod":[["nr","Syscall numbers"],["syscall_inner",""]],"struct":[["KipHeader","Header for Kernel Builtins. Can be found in the `.kip_header` section of our ELFs. Nintendo KIPs start with a (slightly different, but functionally equivalent) header."],["MemoryInfo","The structure returned by the `query_memory` syscall."],["MemoryPermissions","Memory permissions of a memory area."],["ProcInfo","Informations necessary for the create_process syscall."],["ProcInfoFlags","Miscelaneous flags."],["ProcessCategory","Category of the process."],["ProcessInfoType","Kind of information to extract from a process wit `get_process_info`."],["ProcessState","The state the process is currently in."],["Registers","Register backup structure. The syscall_inner will pop the registers from this structure before jumping into the kernel, and then update the structure with the registers set by the syscall."]]});