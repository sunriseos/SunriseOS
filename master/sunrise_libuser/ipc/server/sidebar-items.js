initSidebarItems({"fn":[["common_port_handler","Infinite loop future that waits for `port` to get signaled, then accepts a new session on the port, creates a new object backing the session using `T::default()`, and finally spawns a new session wrapper future using [new_session_wrapper()]."],["control_dispatch","Implement the Control ipc cmd types."],["encode_bytes","Encode an 8-character service string into an u64"],["managed_port_handler","Creates a port through [syscalls::manage_named_port()] with the given name, and returns a future which will handle the port - that is, it will continuously accept new sessions on the port, and create backing objects through `T::default()`, and spawn a top-level future handling that sesion with [new_session_wrapper()]."],["new_session_wrapper","Creates a new top-level future that handles session."],["port_handler","Creates a port through [crate::sm::IUserInterfaceProxy::register_service()] with the given name, and returns a future which will handle the port - that is, it will continuously accept new sessions on the port, and create backing objects through `T::default()`, and spawn a top-level future handling that sesion with [new_session_wrapper()]."]],"mod":[["hrtb_hack","Ideally, that's what we would want to write async fn new_session_wrapper(mut dispatch: F) -> () where     F: for<'a> FnMut<(&'a mut [u8],)>,     for<'a> <F as FnOnce<(&'a mut [u8],)>>::Output: Future<Output = Result<(), ()>>, {     // Session wrapper code } But the compiler seems to have trouble reasoning about associated types in an HRTB context (maybe that's just not possible ? Not sure)."]],"struct":[["Align16","Wrapper struct that forces the alignment to 0x10. Somewhat necessary for the IPC command buffer."]]});