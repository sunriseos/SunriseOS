initSidebarItems({"fn":[["align_down","Align the address to the previous alignment."],["align_up","Align the address to the next alignment."],["align_up_checked","align_up, but checks if addr overflows"],["bit_array_first_count_one","Returns the index of the first instance of count contiguous 1 in a bit array"],["bit_array_first_one","Returns the index of the first 1 in a bit array."],["bit_array_first_zero","Returns the index of the first 0 in a bit array."],["cast_mut","Cast a slice while keeping the lifetimes."],["div_ceil","Counts the numbers of `b` in `a`, rounding the result up."],["log2_ceil","Returns the ceiled base 2 logarithm of the number."],["log2_floor","Returns the floored base 2 logarithm of the number."],["print_hexdump","Displays memory as hexdump"],["print_hexdump_as_if_at_addr","Makes a hexdump of a slice, but display different addresses. Used for displaying memory areas which are not identity mapped in the current pages"]],"macro":[["enum_with_val","Creates a fake C-like enum, where all bit values are accepted."],["initialize_to_zero","A macro to initialize a struct directly in global."]],"mod":[["cursor","Simple cursor"],["io","The IO interface"],["loop_future","Definition of the `LoopFn` combinator, implementing `Future` loops."]],"struct":[["CursorRead","A minimal Cursor for writing, for use in libcore."],["CursorWrite","A minimal Cursor for writing, for use in libcore."]],"trait":[["BitArrayExt","Extension of the [BitField] trait, that adds the `set_bits_area` function."]]});