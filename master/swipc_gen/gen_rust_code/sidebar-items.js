initSidebarItems({"enum":[["Error","Internal error type. Raised whenever we fail to generate something, so we can carry on generating everything else."]],"fn":[["format_args","Format the arguments of a function."],["format_cmd","Generate code for a single function."],["format_ret","Generate code to recover a single return value from an output Message."],["format_ret_ty","Format the return type of a function."],["format_type","Create a new type definition. For a `TypeDef::Struct`, this will be a new struct, For a `TypeDef::Enum`, it will be a new enum, and for a `TypeDef::Alias`, it will be a rust `type` alias."],["gen_call","Parse an incoming request, call the appropriate function from the trait we're currently generating (see [generate_trait()]), and fill the byte buffer with the response data."],["gen_in_raw","Generates the InRaw structure from the argument list of a function. This structure corresponds to the Raw Data that will be sent in the request of an IPC message."],["gen_out_raw","Generates the OutRaw structure from the return param list of a function. This structure corresponds to the Raw Data that will be sent in the response of an IPC message."],["generate_ipc","Generate a module containing all the functions in the given IPC file."],["generate_mod","Generate the module hierarchy. The depth should be set to 0 on the first call and will be increased on each recursive call."],["generate_proxy","Generate a \"proxy\" interface (nomenclature shamelessly stolen from binder). A \"proxy\" is a client interface to a remote IPC object."],["generate_trait","Generate a trait representing an IPC interface. Implementors of this trait may then create IPC Server objects through libuser's SessionWrapper and PortHandler."],["generate_trait_async","Generate a trait representing an async IPC interface. Implementors of this trait may then create IPC Server objects through libuser's `new_session_wrapper` and `create_port`."],["get_handle_type","Get the Rust equivalent of a handle type."],["get_type","Get the Rust type of an [Alias]. If output is true, then the type should be suitable for a return type (or an output IPC buffer argument). If output is false, then the type should be suitable for an input argument."],["is_raw","Checks if an alias contains a raw data type (as opposed to a special datatype)"],["named_iterator","Takes an iterator of potentially unnamed arguments/returns, and returns a named version (where the unnamed fields are named unknown_idx)."],["raw_iterator","Creates an iterator over the raw values from an argument/ret iterator."],["remap_keywords","Rename field names that would conflict with rust keywords."]],"struct":[["BUILTINS","SwIPC builtin type. Associates a SwIPC builtin name with a size/alignment and a rust type name."],["Mod","A module hierarchy."]]});