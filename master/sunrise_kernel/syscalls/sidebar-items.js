initSidebarItems({"fn":[["accept_session","Waits for an incoming connection on the given ServerPort handle, and create a new ServerSession for it."],["clear_event","Clear the \"signaled\" state of an event. After calling this on a signaled event, [wait_synchronization()] on this handle will wait until [signal_event()] is called once again."],["close_handle","Closed the passed handle."],["connect_to_named_port","Connects to the given named port. The name should be a 12-byte array containing a null-terminated string."],["connect_to_port","Connects to the given ClientPort."],["create_event","Create a [WritableEvent]/[ReadableEvent] pair. Signals on the [WritableEvent] will cause threads waiting on the [ReadableEvent] to wake up until the signal is cleared/reset."],["create_interrupt_event","Create an event handle for the given IRQ number. Waiting on this handle will wait until the IRQ is triggered. The flags argument configures the triggering. If it is false, the IRQ is active HIGH level sensitive, if it is true it is rising-edge sensitive."],["create_port","Create a new Port pair. Those ports are linked to each-other: The server will receive connections from the client."],["create_process","Creates a new process. This will create an empty address space without any thread yet. The size of this address space is controlled through the [ProcInfoAddrSpace] found in `procinfo`."],["create_session","Create a new Session pair. Those sessions are linked to each-other: The server will receive requests sent through the client."],["create_shared_memory","Allocate a new SharedMemory region. This is a memory region backed by DRAM allocated from the current process' pool partition, that can be mapped in different processes."],["create_thread","Creates a thread in the current process. The thread can then be started with the svcStartThread."],["exit_process","Kills our own process."],["exit_thread","Kills our own thread."],["get_process_id","Gets the PID of the given Process handle. Alias handles (0xFFFF8000 and 0xFFFF8001) are not allowed here. PIDs are global, unique identifiers for a given process. PIDs are never reused, and can be passed over IPC safely (the kernel ensures the correct pid is passed when a process does a request), making them the best way for sysmodule to identify a calling process."],["get_process_info","Extract information from a process."],["get_process_list","Fills the provided array with the pids of currently living processes. A process \"lives\" so long as it is currently running or a handle to it still exists."],["manage_named_port","Creates a new ServerPort for the given named port. The name should be a 12-byte array containing a null-terminated string. This ServerPort can be connected to with `connect_to_named_port`."],["map_framebuffer","Maps the vga frame buffer mmio in userspace memory"],["map_mmio_region","Maps a physical region in the address space of the process."],["map_process_memory","Maps the given src memory range from a remote process into the current process as RW-. This is used by the Loader to load binaries into the memory region allocated by the kernel in [create_process()]."],["map_shared_memory","Maps the block supplied by the handle. The required permissions are different for the process that created the handle and all other processes."],["output_debug_string","Print the passed string to the serial port."],["query_memory","Query information about an address. Will always fetch the lowest page-aligned mapping that contains the provided address. Writes the output to the given userspace pointer to a MemoryInfo structure."],["query_physical_address","Gets the physical region a given virtual address maps."],["reply_and_receive_with_user_buffer","If ReplyTarget is not zero, a reply from the given buffer will be sent to that session. Then it will wait until either of the passed sessions has an incoming message, is closed, a passed port has an incoming connection, or the timeout expires. If there is an incoming message, it is copied to the TLS."],["reset_signal","Clear the \"signaled\" state of a readable event or process. After calling this on a signaled event, [wait_synchronization()] on this handle will wait until the handle is signaled again."],["send_sync_request_with_user_buffer","Send an IPC request through the ClientSession, and blocks until a response is received. This variant takes a userspace buffer and size. Those must be page-aligned."],["set_heap_size","Resize the heap of a process, just like a brk. It can both expand, and shrink the heap."],["set_process_memory_permission","Change permission of a page-aligned memory region. Acceptable permissions are ---, r-- and rw-. In other words, it is not allowed to set the executable bit, nor is it acceptable to use write-only permissions."],["set_thread_area","Set thread local area pointer."],["signal_event","Sets the \"signaled\" state of an event. Calling this on an unsignalled event will cause any thread waiting on this event through [wait_synchronization()] to wake up. Any future calls to [wait_synchronization()] with this handle will immediately return - the user has to clear the \"signaled\" state through [clear_event()]."],["sleep_thread","Sleep for a specified amount of time, or yield thread."],["start_process","Start the given process on the provided CPU with the provided scheduler priority."],["start_thread","Starts a previously created thread."],["terminate_process","Kills the given process, terminating the execution of all of its thread and putting its state to Exiting/Exited."],["unmap_process_memory","Unmaps a memory range mapped with [map_process_memory()]. `dst_addr` is an address in the current address space, while `src_addr` is the address in the remote address space that was previously mapped."],["unmap_shared_memory","Unmaps this shared memory region. This cannot be used to partially unmap a region: the address must be the start of the shared mapping, and the size must be the full size of the mapping."],["wait_synchronization","Waits for one of the handles to signal an event."]]});