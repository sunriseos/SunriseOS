<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `cpu_locals` mod in crate `sunrise_kernel`."><meta name="keywords" content="rust, rustlang, rust-lang, cpu_locals"><title>sunrise_kernel::cpu_locals - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../sunrise_kernel/index.html'><div class='logo-container'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Module cpu_locals</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#statics">Statics</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'><a href='../index.html'>sunrise_kernel</a></p><script>window.sidebarCurrent = {name: 'cpu_locals', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/sunrise_kernel/cpu_locals.rs.html#1-354' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../index.html'>sunrise_kernel</a>::<wbr><a class="mod" href=''>cpu_locals</a></span></h1><div class='docblock'><p>CPU local storage</p>
<p>We want some statics to be cpu-local (e.g. <a href="../../sunrise_kernel/scheduler/static.CURRENT_THREAD.html"><code>CURRENT_THREAD</code></a>). We could implement this fully
in software, by having an area of memory that is replicated for every cpu core, where
statics are indexes in this memory area, and provide getters and setters to access and modify
the cpu-local statics.</p>
<p>However this is not ideal as it is not really optimized, and pretty tedious.</p>
<p>Instead we use the very common concept of Thread Local Storage (TLS), and apply it to cpu cores
instead of threads, and let the compiler do all the hard work for us.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>In the kernel you declare a cpu-local using the <a href="https://github.com/rust-lang/rust/issues/10310">#[thread_local] attribute</a> :</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">thread_local</span>]</span>
<span class="kw">static</span> <span class="ident">MY_CPU_LOCAL</span>: <span class="ident">core</span>::<span class="ident">cell</span>::<span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">core</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">42</span>);</pre></div>
<p>and access it as if it was a regular static, only that each cpu core will have its own view of
the static.</p>
<p>The compiler is responsible for generating code that will access the right address, provided
we configured TLS correctly.</p>
<h5 id="early-boot" class="section-header"><a href="#early-boot">Early boot</a></h5>
<p>Note that you can't access a cpu-local static before <a href="../../sunrise_kernel/cpu_locals/fn.init_cpu_locals.html"><code>init_cpu_locals</code></a> is called, because
the cpu-local areas arent' initialized yet, and this will likely result to a cpu exception
being raised, or UB.</p>
<p>This means you can't ever access cpu-locals in early boot. If your code might be called during
early boot, we advise you to use <a href="../../sunrise_kernel/cpu_locals/static.ARE_CPU_LOCALS_INITIALIZED_YET.html"><code>ARE_CPU_LOCALS_INITIALIZED_YET</code></a> to know if you're allowed
to access your cpu-local static, and if not return an error of some kind.</p>
<h1 id="inner-workings" class="section-header"><a href="#inner-workings">Inner workings</a></h1>
<p>We implement the TLS according to conventions laid out by <a href="https://web.archive.org/web/20190710135250/https://akkadia.org/drepper/tls.pdf">Ulrich Drepper's paper on TLS</a> which
is followed by LLVM and most compilers.</p>
<p>Since we're running on i386, we're following variant II.</p>
<p>Each cpu core's <code>gs</code> segment points to a thread local memory area where cpu-locals statics live.
Cpu-local statics are simply accessed through an offset from <code>gs</code>.
Those regions can be found in <a href="../../sunrise_kernel/cpu_locals/static.CPU_LOCAL_REGIONS.html"><code>CPU_LOCAL_REGIONS</code></a>.</p>
<p>The linker is in charge of creating an ELF segment of type <code>PT_TLS</code> where an initialization image
for cpu local regions can be found, and is meant to be copy-pasted for every <del>thread we create</del>
cpu core we have.</p>
<h5 id="segmentation" class="section-header"><a href="#segmentation">Segmentation</a></h5>
<p>Each core gets its own <a href="../../sunrise_kernel/i386/gdt/index.html">GDT</a>. In each of these there is a <code>KTls</code> segment which points to this
core's cpu-local area, and which is meant to be loaded into <code>gs</code>.</p>
<p>Because userspace might want to use Thread Local Storage too, and also needs <code>gs</code> to point to its
thread local area (see <a href="../../sunrise_kernel/syscalls/fn.set_thread_area.html"><code>set_thread_area</code></a>), we swap the segment <code>gs</code> points to everytime
we enter and leave the kernel in <a href="../../sunrise_kernel/macro.trap_gate_asm.html" title="`trap_gate_asm`"><code>trap_gate_asm</code></a>, from <code>UTls_Elf</code> to <code>KTls</code> and back.</p>
<p>TLS on x86 are really weird. It uses the variant II, where offsets must be <em>subtracted</em> from <code>gs</code>,
even though segmentation only supports <em>adding</em> offsets. The only way to make them work is to have
<code>gs</code> segment's limit be <code>0xffffffff</code>, effectively spanning the whole address space, and when
the cpu will add a &quot;negative&quot; (e.g. <code>0xfffffffc</code> for -4) offset, it will treat it as an unsigned
huge positive offset, which when added to <code>gs</code>'s base will &quot;wrap around&quot; the address space,
and effectively end up 4 bytes behind <code>gs</code>'s base.</p>
<p>Illustration:</p>
<p><img src="https://raw.githubusercontent.com/sunriseos/SunriseOS/master/kernel/res/cpu_locals_segmentation_doc.gif" alt="cpu backflip" /></p>
<h5 id="dtv-and-__tls_get_addr" class="section-header"><a href="#dtv-and-__tls_get_addr">dtv and <code>__tls_get_addr</code></a></h5>
<p>We're the kernel, and we don't do dynamic loading (no loadable kernel modules).
Because of this, we know our TLS model will be static (either Initial Exec or Local Exec).
Those models always access thread-locals directly via <code>gs</code>, and always short-circuit the dtv.</p>
<p>So we don't even bother allocating a dtv array at all. Neither do we define a <code>__tls_get_addr</code>
function.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.CpuLocalRegion.html" title='sunrise_kernel::cpu_locals::CpuLocalRegion struct'>CpuLocalRegion</a></td><td class='docblock-short'><p>Represents an allocated cpu local region.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ThreadControlBlock.html" title='sunrise_kernel::cpu_locals::ThreadControlBlock struct'>ThreadControlBlock</a></td><td class='docblock-short'><p>Elf TLS TCB</p>
</td></tr></table><h2 id='statics' class='section-header'><a href="#statics">Statics</a></h2>
<table><tr class='module-item'><td><a class="static" href="static.ARE_CPU_LOCALS_INITIALIZED_YET.html" title='sunrise_kernel::cpu_locals::ARE_CPU_LOCALS_INITIALIZED_YET static'>ARE_CPU_LOCALS_INITIALIZED_YET</a></td><td class='docblock-short'><p>Use this if your code might run in an early boot stage to know if you're
allowed to access a cpu-local variable. Accessing one when this is false is UB.</p>
</td></tr><tr class='module-item'><td><a class="static" href="static.CPU_LOCAL_REGIONS.html" title='sunrise_kernel::cpu_locals::CPU_LOCAL_REGIONS static'>CPU_LOCAL_REGIONS</a></td><td class='docblock-short'><p>Array of cpu local regions, copied from the initialization image in kernel's ELF.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.get_cpu_locals_ptr_for_core.html" title='sunrise_kernel::cpu_locals::get_cpu_locals_ptr_for_core fn'>get_cpu_locals_ptr_for_core</a></td><td class='docblock-short'><p>Address that should be put in <code>KTls</code> segment's base.
The limit should be <code>0xffffffff</code>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.init_cpu_locals.html" title='sunrise_kernel::cpu_locals::init_cpu_locals fn'>init_cpu_locals</a></td><td class='docblock-short'><p>Initializes cpu locals during early boot stage.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.tls_align_up.html" title='sunrise_kernel::cpu_locals::tls_align_up fn'>tls_align_up</a></td><td class='docblock-short'><p>The <code>round</code> function, as defined in section 3.0:</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "sunrise_kernel";</script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>