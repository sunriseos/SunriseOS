var searchIndex = JSON.parse('{\
"disk_initializer":{"doc":"Disk initializer application","i":[[5,"write_file_to_filesystem","disk_initializer","Write a std file to FAT filesystem.",null,[[["fatfilesystem",3],["fatfile",3]],["fatfilesystemresult",6]]],[5,"write_tempate_to_filesystem","","Write the template directory content to a FAT fileystem",null,[[["fatfilesystem",3],["pathbuf",3],["path",3]],["result",6]]],[5,"main","","",null,[[]]],[0,"gpt","","GPT definition module.",null,null],[3,"RawUUID","disk_initializer::gpt","A raw uuid representation.",null,null],[12,"d1","","Time low part.",0,null],[12,"d2","","Time mid part.",0,null],[12,"d3","","Time high part and version.",0,null],[12,"d4","","Node.",0,null],[3,"GPTHeader","","The header of a GPT table.",null,null],[12,"signature","","Signature of a GPT header.",1,null],[12,"revision","","GPT revision.",1,null],[12,"header_size","","Header size.",1,null],[12,"crc32","","CRC over the header.",1,null],[12,"reserved","","Reserved field.",1,null],[12,"current_lba","","The LBA of this header.",1,null],[12,"backup_lba","","The LBA of the backup header.",1,null],[12,"first_usable","","The first usable LBA. (partition table entries)",1,null],[12,"last_usable","","The last usable LBA.",1,null],[12,"disk_guid","","The GUID of this disk.",1,null],[12,"partition_table_start","","The LBA of the first partition entry.",1,null],[12,"partition_entry_count","","The count of partition entries.",1,null],[12,"partition_entry_size","","The size of a partition entry.",1,null],[12,"partition_table_crc32","","The CRC over all partition entries.",1,null],[3,"GPTPartitionEntry","","A GPT partition entry.",null,null],[12,"partition_type","","Partition type GUID.",2,null],[12,"unique_id","","Partition GUID.",2,null],[12,"first_lba","","First LBA of the partition.",2,null],[12,"last_lba","","Last LBA of the partition (inclusive).",2,null],[12,"attribute","","Attribute flags.",2,null],[12,"partition_name","","Partition name in UTF16LE.",2,null],[3,"PartitionManager","","Manage partition of a IStorage.",null,null],[12,"inner","","The IStorage used.",3,null],[3,"PartitionIterator","","Iterator over GPT partitions",null,null],[12,"inner","","The IStorage used.",4,null],[12,"partition_table_start","","Partition sector start.",4,null],[12,"partition_entry_count","","Partition count.",4,null],[12,"partition_entry_size","","Partition entry size",4,null],[12,"position","","Current position of the iterator.",4,null],[5,"calculate_crc32","","Compute the CRC32 of a given slice.",null,[[]]],[5,"lba_to_cls","","Convert a LBA to a CLS address.",null,[[]]],[11,"from_fields","","Create a RawUUID from raw parts",0,[[]]],[11,"to_uuid","","Convert to a UUID instance.",0,[[],["uuid",3]]],[11,"from_uuid","","Convert a UUID to a RawUUID.",0,[[["uuid",3]]]],[11,"from_slice_le","","Create a RawUUID from a little endian slice of bytes.",0,[[]]],[11,"to_bytes_le","","Convert to a little endian byte array.",0,[[]]],[11,"set_partition_type","","Set the partition type GUID.",2,[[["uuid",3]]]],[11,"set_unique_id","","Set the unique partition GUID.",2,[[["uuid",3]]]],[11,"set_name","","Set the name of the partition.",2,[[]]],[11,"from_bytes","","Create a GPTPartitionEntry from bytes.",2,[[]]],[11,"read","","Read the content of a raw array into a GPTPartitionEntry.",2,[[]]],[11,"write","","Conver the structure data to a raw array.",2,[[]]],[18,"MAGIC","","The magic of a GPT header (\\\"EFI PART\\\")",1,null],[11,"from_storage_device","","Read the GPT header from the disk",1,[[["storagedevice",8]],[["result",4],["debug",8]]]],[11,"from_bytes","","Create a GPTHeader from a raw array.",1,[[]]],[11,"read","","Read the content of a raw array into a GPTHeader.",1,[[]]],[11,"write","","Conver the structure data to a raw array.",1,[[]]],[11,"update_header_crc","","Update the CRC32 of the header.",1,[[]]],[11,"set_disk_guid","","Set the disk GUID.",1,[[["uuid",3]]]],[11,"new","","Create a new partition manager.",3,[[["storagedevice",8]]]],[11,"create_protective_mbr","","Create a protective MBR",3,[[],["result",4]]],[11,"initialize","","Initialize a IStorage partition table.",3,[[],["result",4]]],[11,"new","","Create a new partition iterator.",4,[[["storagedevice",8]],["result",4]]],[17,"BLOCK_SIZE","disk_initializer","Size of a block.",null,null],[17,"BLOCK_SIZE_U64","","Size of an AHCI block in u64.",null,null],[11,"from","disk_initializer::gpt","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"into_iter","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"next","","",4,[[],["option",4]]],[11,"clone","","",0,[[],["rawuuid",3]]],[11,"clone","","",1,[[],["gptheader",3]]],[11,"clone","","",2,[[],["gptpartitionentry",3]]],[11,"default","","",0,[[]]],[11,"default","","",2,[[]]],[11,"default","","",1,[[]]],[11,"eq","","",0,[[["rawuuid",3]]]],[11,"ne","","",0,[[["rawuuid",3]]]],[11,"eq","","",1,[[["gptheader",3]]]],[11,"ne","","",1,[[["gptheader",3]]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]]],"p":[[3,"RawUUID"],[3,"GPTHeader"],[3,"GPTPartitionEntry"],[3,"PartitionManager"],[3,"PartitionIterator"]]},\
"docs":{"doc":"SunriseOS Architecture Documentation","i":[[5,"main","docs","",null,[[]]],[0,"building","","Build Instructions",null,null],[0,"updating_rust_version","","Updating the Rust Toolchain",null,null],[0,"security_architecture","","SunriseOS Security Architecture",null,null]],"p":[]},\
"sunrise_ahci":{"doc":"AHCI driver module","i":[[3,"AhciInterface","sunrise_ahci","Main interface to the AHCI driver.",null,null],[5,"main","","Ahci driver initialisation.",null,[[]]],[0,"pci","","PCI discovery",null,null],[3,"PciConfigPortsPair","sunrise_ahci::pci","A struct tying the two pci config ports together.",null,null],[12,"address","","The address port.",0,null],[12,"data","","The data port.",0,null],[3,"PciDevice","","A pci device, addressed by its bus number, slot, and…",null,null],[12,"bus","","The device\'s bus number.",1,null],[12,"slot","","The device\'s slot number on its bus.",1,null],[12,"function","","The device\'s function number.",1,null],[12,"did","","Device id.",1,null],[12,"vid","","Vendor id.",1,null],[12,"class","","",1,null],[12,"subclass","","",1,null],[12,"prog_if","","",1,null],[12,"rev_id","","",1,null],[12,"header_type","","",1,null],[12,"latency_timer","","",1,null],[12,"cache_line_size","","",1,null],[12,"header","","Remaining registers values, based on header type.",1,null],[3,"PciHeader00","","Pci header when Header Type == 0x00 (General device).",null,null],[12,"bar0","","",2,null],[12,"bar1","","",2,null],[12,"bar2","","",2,null],[12,"bar3","","",2,null],[12,"bar4","","",2,null],[12,"bar5","","",2,null],[12,"cardbus_cis_ptr","","",2,null],[12,"subsystem_id","","",2,null],[12,"subsystem_vendor_id","","",2,null],[12,"expansion_rom_base_address","","",2,null],[12,"capabilities_ptr","","",2,null],[12,"max_latency","","",2,null],[12,"min_grant","","",2,null],[12,"interrupt_pin","","",2,null],[12,"interrupt_line","","",2,null],[4,"PciHeader","","Contents of pci config registers 0x4-0xf, structure varies…",null,null],[13,"GeneralDevice","","header type == 0x00",3,null],[13,"PCItoPCIBridge","","header type == 0x01, not implemented",3,null],[13,"CardBus","","header type == 0x02, not implemented",3,null],[13,"UnknownHeaderType","","header type == other",3,null],[4,"BAR","","Base Address Registers. Minimal implementation, does not…",null,null],[13,"Memory","","a memory space address and its size",4,null],[13,"Io","","an IO space address",4,null],[5,"pci_config_read_word","","Read one of the 64 32-bit registers of a pci…",null,[[]]],[5,"pci_config_write_word","","Read one of the 64 32-bit registers of a pci…",null,[[]]],[5,"discover","","Discover all pci devices, by probing the PID-VID of every…",null,[[],[["vec",3],["pcidevice",3]]]],[5,"get_ahci_controllers","","Gets the ahci controllers found by pci discovery.",null,[[],["vec",3]]],[7,"PCI_CONFIG_PORTS","","A mutex around the two ports used to address pci…",null,null],[17,"CONFIG_ADDRESS","","The CONFIG_ADDRESS I/O location.",null,null],[17,"CONFIG_DATA","","The CONFIG_DATA I/O location.",null,null],[17,"MAX_BUS","","The highest addressable bus.",null,null],[17,"MAX_SLOT","","The highest addressable slot on a bus.",null,null],[17,"MAX_FUNC","","The highest addressable function on a slot on a bus.",null,null],[17,"MAX_REGISTER","","The highest addressable register on a function on a slot…",null,null],[11,"probe","","Checks if a device exists on given bus>slot>function.",1,[[],["option",4]]],[11,"read_config_register","","Reads a configuration space register.",1,[[]]],[11,"write_config_register","","Writes to a configuration space register.",1,[[]]],[11,"status","","Reads the status register.",1,[[]]],[11,"command","","Reads the command register.",1,[[]]],[0,"hba","sunrise_ahci","HBA structures",null,null],[3,"HbaMemoryRegisters","sunrise_ahci::hba","HBA memory registers.",null,null],[12,"generic_host_control","","",5,null],[12,"_rsv","","",5,null],[12,"_rsv_vendor","","",5,null],[12,"ports","","",5,null],[3,"GenericHostControl","","HBA Generic Host Control.",null,null],[12,"cap","","",6,null],[12,"ghc","","",6,null],[12,"is","","",6,null],[12,"pi","","",6,null],[12,"vs","","",6,null],[12,"ccc_ctl","","",6,null],[12,"ccc_pts","","",6,null],[12,"em_loc","","",6,null],[12,"em_ctl","","",6,null],[12,"cap2","","",6,null],[12,"bohc","","",6,null],[3,"CAP","","HbaMem.CAP \\\"HBA Capabilities\\\" register bitfield.",null,null],[12,"0","","",7,null],[3,"GHC","","HbaMem.GHC \\\"Global HBA Control\\\" register bitfield.",null,null],[12,"0","","",8,null],[3,"CAP2","","HbaMem.CAP2 \\\"HBA Capabilities Extended\\\" register bitfield.",null,null],[12,"0","","",9,null],[3,"Px","","HBA Memory Port registers.",null,null],[12,"clb","","",10,null],[12,"fb","","",10,null],[12,"is","","",10,null],[12,"ie","","",10,null],[12,"cmd","","",10,null],[12,"_rsv0","","",10,null],[12,"tfd","","",10,null],[12,"sig","","",10,null],[12,"ssts","","",10,null],[12,"sctl","","",10,null],[12,"serr","","",10,null],[12,"sact","","",10,null],[12,"ci","","",10,null],[12,"sntf","","",10,null],[12,"fbs","","",10,null],[12,"_rsv1","","",10,null],[12,"vendor","","",10,null],[3,"PxIS","","`PxIS` \\\"Port x Interrupt status\\\" register bitfield.",null,null],[12,"0","","",11,null],[3,"PxIE","","`PxIE` \\\"Port x Interrupt Enable\\\" register bitfield.",null,null],[12,"0","","",12,null],[3,"PxCMD","","`PxCMD` \\\"Port x Command and Status\\\" register bitfield.",null,null],[12,"0","","",13,null],[3,"PxTFD","","`PxTFD` \\\"Port x Task File Data\\\" register bitfield.",null,null],[12,"0","","",14,null],[3,"PxSSTS","","`PxSSTS` \\\"Port x Serial ATA Status\\\" register bitfield.",null,null],[12,"0","","",15,null],[3,"CmdHeader","","Command Header. Pointed to by `PxCLB[i]`.",null,null],[12,"flags","","",16,null],[12,"prdtl","","",16,null],[12,"prdbc","","",16,null],[12,"ctba","","",16,null],[12,"_rsv1","","",16,null],[3,"CmdHeaderFlags","","Command Header word 0.",null,null],[12,"0","","",17,null],[3,"CmdHeaderArray","","The array of 32 [CmdHeader].",null,null],[12,"slots","","",18,null],[3,"CmdTable","","Command Table.",null,null],[12,"cfis","","",19,null],[12,"acmd","","",19,null],[12,"_rsv","","",19,null],[12,"prdt","","",19,null],[3,"PrdtEntry","","Physical Region Descriptor Table entry.",null,null],[12,"dba","","",20,null],[12,"_rsv0","","",20,null],[12,"dbc","","",20,null],[3,"ReceivedFis","","Received FIS Structure. Pointed to by `PxFB`.",null,null],[12,"dsfis","","",21,null],[12,"_rsv0","","",21,null],[12,"psfis","","",21,null],[12,"_rsv1","","",21,null],[12,"rfis","","",21,null],[12,"_rsv2","","",21,null],[12,"sdbfis","","",21,null],[12,"ufis","","",21,null],[12,"_rsv3","","",21,null],[19,"Cfis","","Command FIS.",null,null],[12,"raw_bytes","","",22,null],[12,"h2d","","",22,null],[11,"s64a","","",7,[[]]],[11,"sncq","","",7,[[]]],[11,"ssntf","","",7,[[]]],[11,"smps","","",7,[[]]],[11,"sss","","",7,[[]]],[11,"salp","","",7,[[]]],[11,"sal","","",7,[[]]],[11,"sclo","","",7,[[]]],[11,"iss","","",7,[[]]],[11,"sam","","",7,[[]]],[11,"spm","","",7,[[]]],[11,"fbss","","",7,[[]]],[11,"pmd","","",7,[[]]],[11,"scc","","",7,[[]]],[11,"psc","","",7,[[]]],[11,"ncs","","",7,[[]]],[11,"cccs","","",7,[[]]],[11,"ems","","",7,[[]]],[11,"sxs","","",7,[[]]],[11,"np","","",7,[[]]],[11,"ae","","",8,[[]]],[11,"set_ae","","",8,[[]]],[11,"mrsm","","",8,[[]]],[11,"ie","","",8,[[]]],[11,"set_ie","","",8,[[]]],[11,"hr","","",8,[[]]],[11,"set_hr","","",8,[[]]],[11,"deso","","",9,[[]]],[11,"sadm","","",9,[[]]],[11,"sds","","",9,[[]]],[11,"apst","","",9,[[]]],[11,"nvmp","","",9,[[]]],[11,"boh","","",9,[[]]],[11,"init","","Initializes an AHCI Controller.",5,[[],[["disk",3],["vec",3]]]],[11,"cpds","","",11,[[]]],[11,"set_cpds","","",11,[[]]],[11,"tfes","","",11,[[]]],[11,"set_tfes","","",11,[[]]],[11,"hbfs","","",11,[[]]],[11,"set_hbfs","","",11,[[]]],[11,"hbds","","",11,[[]]],[11,"set_hbds","","",11,[[]]],[11,"ifs","","",11,[[]]],[11,"set_ifs","","",11,[[]]],[11,"infs","","",11,[[]]],[11,"set_infs","","",11,[[]]],[11,"ofs","","",11,[[]]],[11,"set_ofs","","",11,[[]]],[11,"ipms","","",11,[[]]],[11,"set_ipms","","",11,[[]]],[11,"prcs","","",11,[[]]],[11,"dmps","","",11,[[]]],[11,"set_dmps","","",11,[[]]],[11,"pcs","","",11,[[]]],[11,"dps","","",11,[[]]],[11,"set_dps","","",11,[[]]],[11,"ufs","","",11,[[]]],[11,"sbds","","",11,[[]]],[11,"set_sbds","","",11,[[]]],[11,"dss","","",11,[[]]],[11,"set_dss","","",11,[[]]],[11,"pss","","",11,[[]]],[11,"set_pss","","",11,[[]]],[11,"dhrs","","",11,[[]]],[11,"set_dhrs","","",11,[[]]],[11,"is_err","","Checks if a PxIS has set any of the bits corresponding to…",11,[[]]],[11,"cpde","","",12,[[]]],[11,"set_cpde","","",12,[[]]],[11,"tfee","","",12,[[]]],[11,"set_tfee","","",12,[[]]],[11,"hbfe","","",12,[[]]],[11,"set_hbfe","","",12,[[]]],[11,"hbde","","",12,[[]]],[11,"set_hbde","","",12,[[]]],[11,"ife","","",12,[[]]],[11,"set_ife","","",12,[[]]],[11,"infe","","",12,[[]]],[11,"set_infe","","",12,[[]]],[11,"ofe","","",12,[[]]],[11,"set_ofe","","",12,[[]]],[11,"ipme","","",12,[[]]],[11,"set_ipme","","",12,[[]]],[11,"prce","","",12,[[]]],[11,"set_prce","","",12,[[]]],[11,"dmpe","","",12,[[]]],[11,"set_dmpe","","",12,[[]]],[11,"pce","","",12,[[]]],[11,"set_pce","","",12,[[]]],[11,"dpe","","",12,[[]]],[11,"set_dpe","","",12,[[]]],[11,"ufe","","",12,[[]]],[11,"set_ufe","","",12,[[]]],[11,"sbde","","",12,[[]]],[11,"set_sbde","","",12,[[]]],[11,"dse","","",12,[[]]],[11,"set_dse","","",12,[[]]],[11,"pse","","",12,[[]]],[11,"set_pse","","",12,[[]]],[11,"dhre","","",12,[[]]],[11,"set_dhre","","",12,[[]]],[11,"cmd","","",13,[[]]],[11,"set_cmd","","",13,[[]]],[11,"asp","","",13,[[]]],[11,"set_asp","","",13,[[]]],[11,"alpe","","",13,[[]]],[11,"set_alpe","","",13,[[]]],[11,"dlae","","",13,[[]]],[11,"set_dlae","","",13,[[]]],[11,"atapi","","",13,[[]]],[11,"set_atapi","","",13,[[]]],[11,"apste","","",13,[[]]],[11,"set_apste","","",13,[[]]],[11,"fbscp","","",13,[[]]],[11,"esp","","",13,[[]]],[11,"cpd","","",13,[[]]],[11,"mpsp","","",13,[[]]],[11,"hpcp","","",13,[[]]],[11,"pma","","",13,[[]]],[11,"set_pma","","",13,[[]]],[11,"cps","","",13,[[]]],[11,"cr","","",13,[[]]],[11,"fr","","",13,[[]]],[11,"mpss","","",13,[[]]],[11,"ccs","","",13,[[]]],[11,"fre","","",13,[[]]],[11,"set_fre","","",13,[[]]],[11,"clo","","",13,[[]]],[11,"set_clo","","",13,[[]]],[11,"pod","","",13,[[]]],[11,"set_pod","","",13,[[]]],[11,"sud","","",13,[[]]],[11,"set_sud","","",13,[[]]],[11,"st","","",13,[[]]],[11,"set_st","","",13,[[]]],[11,"err","","",14,[[]]],[11,"bsy","","",14,[[]]],[11,"cs0","","",14,[[]]],[11,"drq","","",14,[[]]],[11,"cs1","","",14,[[]]],[11,"err_flag","","",14,[[]]],[11,"ipm","","",15,[[]]],[11,"spd","","",15,[[]]],[11,"det","","",15,[[]]],[11,"stop","","Stop this port.",10,[[]]],[11,"start","","Start this port.",10,[[["cmdheaderarray",3]]]],[11,"disable_fis_receive","","Disables FIS Receive.",10,[[]]],[11,"enable_fis_receive","","Enable FIS Receive.",10,[[["receivedfis",3]]]],[11,"probe","","Checks if a functional device is present on the port.",10,[[]]],[11,"clear_addresses","","Makes `PxFB` and `PxCLB` point to `0x00000000`.",10,[[]]],[11,"init","","Initializes a port, returning a [Disk] to interface with it.",10,[[["px",3]],[["disk",3],["option",4]]]],[11,"command_running","","Checks if the command issued in `slot` is still running.",10,[[]]],[11,"wait_command_completion","","Polls the port until the command in `slot` is completed,…",10,[[],[["error",4],["result",4]]]],[11,"identify","","Sends the IDENTIFY DEVICE command to a port to gather some…",10,[[["px",3],["cmdheader",3],["cmdtable",3]],[["error",4],["result",4]]]],[11,"read_dma","","Read `sector_count` contiguous sectors from the disk into…",10,[[["px",3],["cmdheader",3],["cmdtable",3]],[["error",4],["result",4]]]],[11,"write_dma","","Write `sector_count` contiguous sectors to the disk from…",10,[[["px",3],["cmdheader",3],["cmdtable",3]],[["error",4],["result",4]]]],[11,"pmp","","",17,[[]]],[11,"set_pmp","","",17,[[]]],[11,"c","","",17,[[]]],[11,"set_c","","",17,[[]]],[11,"b","","",17,[[]]],[11,"set_b","","",17,[[]]],[11,"r","","",17,[[]]],[11,"set_r","","",17,[[]]],[11,"p","","",17,[[]]],[11,"set_p","","",17,[[]]],[11,"w","","",17,[[]]],[11,"set_w","","",17,[[]]],[11,"a","","",17,[[]]],[11,"set_a","","",17,[[]]],[11,"cfl","","",17,[[]]],[11,"set_cfl","","",17,[[]]],[11,"init","","Initializes a CmdHeader, making it point to its [CmdTable].",16,[[["cmdtable",3]]]],[11,"fill_prdt","","Fills a PRDT with the given buffer.",19,[[["cmdheader",3]],[["error",4],["result",4]]]],[11,"dsfis","","Return a const reference to the last received DMA Setup FIS.",21,[[],["fisdmasetup",3]]],[11,"psfis","","Return a const reference to the last received PIO Setup FIS.",21,[[],["fispiosetup",3]]],[11,"rfis","","Return a const reference to the last received D2H Register…",21,[[],["fisregd2h",3]]],[11,"sdbfis","","Return a const reference to the last received Set Device…",21,[[],["fissetdevicebits",3]]],[11,"ufis","","Return a const reference to the last received Unknown FIS.",21,[[]]],[0,"fis","sunrise_ahci","Frame Information Structures",null,null],[3,"FisRegH2D","sunrise_ahci::fis","Register FIS - host to device",null,null],[12,"fis_type","","",23,null],[12,"pm","","",23,null],[12,"command","","",23,null],[12,"featurel","","",23,null],[12,"lba0","","",23,null],[12,"lba1","","",23,null],[12,"lba2","","",23,null],[12,"device","","",23,null],[12,"lba3","","",23,null],[12,"lba4","","",23,null],[12,"lba5","","",23,null],[12,"featureh","","",23,null],[12,"countl","","",23,null],[12,"counth","","",23,null],[12,"icc","","",23,null],[12,"control","","",23,null],[12,"rsv1","","",23,null],[3,"FisRegD2H","","Register FIS - device to host",null,null],[12,"fis_type","","",24,null],[12,"pm","","",24,null],[12,"status","","",24,null],[12,"error","","",24,null],[12,"lba0","","",24,null],[12,"lba1","","",24,null],[12,"lba2","","",24,null],[12,"device","","",24,null],[12,"lba3","","",24,null],[12,"lba4","","",24,null],[12,"lba5","","",24,null],[12,"rsv2","","",24,null],[12,"countl","","",24,null],[12,"counth","","",24,null],[12,"rsv3","","",24,null],[12,"rsv4","","",24,null],[3,"FisData","","Data FIS - bidirectional",null,null],[12,"fis_type","","",25,null],[12,"pm","","",25,null],[12,"rsv1","","",25,null],[12,"data","","",25,null],[3,"FisPioSetup","","PIO setup FIS - device to host",null,null],[12,"fis_type","","",26,null],[12,"pm","","",26,null],[12,"status","","",26,null],[12,"error","","",26,null],[12,"lba0","","",26,null],[12,"lba1","","",26,null],[12,"lba2","","",26,null],[12,"device","","",26,null],[12,"lba3","","",26,null],[12,"lba4","","",26,null],[12,"lba5","","",26,null],[12,"rsv2","","",26,null],[12,"countl","","",26,null],[12,"counth","","",26,null],[12,"rsv3","","",26,null],[12,"e_status","","",26,null],[12,"tc","","",26,null],[12,"rsv4","","",26,null],[3,"FisDmaSetup","","DMA setup FIS - bidirectional",null,null],[12,"fis_type","","",27,null],[12,"pm","","",27,null],[12,"rsv1","","",27,null],[12,"dma_buffer_id","","",27,null],[12,"rsv3","","",27,null],[12,"dma_buffer_offset","","",27,null],[12,"transfer_count","","",27,null],[12,"rsv6","","",27,null],[3,"FisSetDeviceBits","","Set device bits FIS - device to host",null,null],[12,"fis_type","","",28,null],[12,"i","","",28,null],[12,"status","","",28,null],[12,"error","","",28,null],[12,"_rsv","","",28,null],[4,"FisType","","The types of a FIS.",null,null],[13,"RegH2D","","Register FIS - host to device",29,null],[13,"RegD2H","","Register FIS - device to host",29,null],[13,"DmaAct","","DMA activate FIS - device to host",29,null],[13,"DmaSetup","","DMA setup FIS - bidirectional",29,null],[13,"Data","","Data FIS - bidirectional",29,null],[13,"Bist","","BIST activate FIS - bidirectional",29,null],[13,"PioSetup","","PIO setup FIS - device to host",29,null],[13,"DevBits","","Set device bits FIS - device to host",29,null],[0,"disk","sunrise_ahci","AHCI Disk",null,null],[3,"Disk","sunrise_ahci::disk","An AHCI Disk",null,null],[12,"px","","Pointer back to the corresponding Port Control Registers,…",30,null],[12,"rfis","","The allocated Received FIS memory zone that the port uses.",30,null],[12,"cmd_list","","The allocated Command List memory zone that the port uses.",30,null],[12,"cmd_tables","","An allocated Command Table for each implemented Command…",30,null],[12,"sectors","","Number of addressable sectors of this disk. Each sector is…",30,null],[12,"supports_48_bit","","Indicates if the device supports 48 bit addresses.",30,null],[3,"IDisk","","Interface to a disk.",null,null],[12,"0","","",31,null],[11,"sector_count","","Returns the number of addressable 512-octet sectors for…",30,[[],[["error",4],["result",4]]]],[11,"read_dma","","Reads sectors from disk.",30,[[],[["error",4],["result",4]]]],[11,"write_dma","","Writes sectors to disk.",30,[[],[["error",4],["result",4]]]],[11,"new","","Creates an IDisk from the wrapped [Disk].",31,[[["mutex",3],["arc",3]]]],[7,"DISKS","sunrise_ahci","Array of discovered disk.",null,null],[7,"HEADER","","",null,null],[7,"CAPABILITIES","","",null,null],[11,"from","","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"into","","",32,[[]]],[11,"try_into","","",32,[[],["result",4]]],[11,"borrow","","",32,[[]]],[11,"borrow_mut","","",32,[[]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"to_owned","","",32,[[]]],[11,"clone_into","","",32,[[]]],[11,"size","","",32,[[]]],[11,"is_cool","","",32,[[]]],[11,"from_raw_parts","","",32,[[]]],[11,"from_raw_parts_mut","","",32,[[]]],[11,"from","sunrise_ahci::pci","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"size","","",3,[[]]],[11,"is_cool","","",3,[[]]],[11,"from_raw_parts","","",3,[[]]],[11,"from_raw_parts_mut","","",3,[[]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"size","","",4,[[]]],[11,"is_cool","","",4,[[]]],[11,"from_raw_parts","","",4,[[]]],[11,"from_raw_parts_mut","","",4,[[]]],[11,"from","sunrise_ahci::hba","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"size","","",5,[[]]],[11,"is_cool","","",5,[[]]],[11,"from_raw_parts","","",5,[[]]],[11,"from_raw_parts_mut","","",5,[[]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"size","","",6,[[]]],[11,"is_cool","","",6,[[]]],[11,"from_raw_parts","","",6,[[]]],[11,"from_raw_parts_mut","","",6,[[]]],[11,"from","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"size","","",7,[[]]],[11,"is_cool","","",7,[[]]],[11,"from_raw_parts","","",7,[[]]],[11,"from_raw_parts_mut","","",7,[[]]],[11,"bit","","",7,[[]]],[11,"set_bit","","",7,[[]]],[11,"from","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"size","","",8,[[]]],[11,"is_cool","","",8,[[]]],[11,"from_raw_parts","","",8,[[]]],[11,"from_raw_parts_mut","","",8,[[]]],[11,"bit","","",8,[[]]],[11,"set_bit","","",8,[[]]],[11,"from","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"size","","",9,[[]]],[11,"is_cool","","",9,[[]]],[11,"from_raw_parts","","",9,[[]]],[11,"from_raw_parts_mut","","",9,[[]]],[11,"bit","","",9,[[]]],[11,"set_bit","","",9,[[]]],[11,"from","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"size","","",10,[[]]],[11,"is_cool","","",10,[[]]],[11,"from_raw_parts","","",10,[[]]],[11,"from_raw_parts_mut","","",10,[[]]],[11,"from","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"size","","",11,[[]]],[11,"is_cool","","",11,[[]]],[11,"from_raw_parts","","",11,[[]]],[11,"from_raw_parts_mut","","",11,[[]]],[11,"bit","","",11,[[]]],[11,"set_bit","","",11,[[]]],[11,"from","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"into","","",12,[[]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"size","","",12,[[]]],[11,"is_cool","","",12,[[]]],[11,"from_raw_parts","","",12,[[]]],[11,"from_raw_parts_mut","","",12,[[]]],[11,"bit","","",12,[[]]],[11,"set_bit","","",12,[[]]],[11,"from","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"into","","",13,[[]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"size","","",13,[[]]],[11,"is_cool","","",13,[[]]],[11,"from_raw_parts","","",13,[[]]],[11,"from_raw_parts_mut","","",13,[[]]],[11,"bit","","",13,[[]]],[11,"set_bit","","",13,[[]]],[11,"from","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"into","","",14,[[]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"size","","",14,[[]]],[11,"is_cool","","",14,[[]]],[11,"from_raw_parts","","",14,[[]]],[11,"from_raw_parts_mut","","",14,[[]]],[11,"bit","","",14,[[]]],[11,"set_bit","","",14,[[]]],[11,"from","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"into","","",15,[[]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"size","","",15,[[]]],[11,"is_cool","","",15,[[]]],[11,"from_raw_parts","","",15,[[]]],[11,"from_raw_parts_mut","","",15,[[]]],[11,"bit","","",15,[[]]],[11,"set_bit","","",15,[[]]],[11,"from","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"into","","",16,[[]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"size","","",16,[[]]],[11,"is_cool","","",16,[[]]],[11,"from_raw_parts","","",16,[[]]],[11,"from_raw_parts_mut","","",16,[[]]],[11,"from","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"into","","",17,[[]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"to_owned","","",17,[[]]],[11,"clone_into","","",17,[[]]],[11,"size","","",17,[[]]],[11,"is_cool","","",17,[[]]],[11,"from_raw_parts","","",17,[[]]],[11,"from_raw_parts_mut","","",17,[[]]],[11,"bit","","",17,[[]]],[11,"set_bit","","",17,[[]]],[11,"from","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"into","","",18,[[]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"size","","",18,[[]]],[11,"is_cool","","",18,[[]]],[11,"from_raw_parts","","",18,[[]]],[11,"from_raw_parts_mut","","",18,[[]]],[11,"from","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"into","","",19,[[]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"size","","",19,[[]]],[11,"is_cool","","",19,[[]]],[11,"from_raw_parts","","",19,[[]]],[11,"from_raw_parts_mut","","",19,[[]]],[11,"from","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"into","","",20,[[]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"size","","",20,[[]]],[11,"is_cool","","",20,[[]]],[11,"from_raw_parts","","",20,[[]]],[11,"from_raw_parts_mut","","",20,[[]]],[11,"from","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"into","","",21,[[]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"size","","",21,[[]]],[11,"is_cool","","",21,[[]]],[11,"from_raw_parts","","",21,[[]]],[11,"from_raw_parts_mut","","",21,[[]]],[11,"from","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"into","","",22,[[]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"size","","",22,[[]]],[11,"is_cool","","",22,[[]]],[11,"from_raw_parts","","",22,[[]]],[11,"from_raw_parts_mut","","",22,[[]]],[11,"from","sunrise_ahci::fis","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"into","","",23,[[]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"size","","",23,[[]]],[11,"is_cool","","",23,[[]]],[11,"from_raw_parts","","",23,[[]]],[11,"from_raw_parts_mut","","",23,[[]]],[11,"from","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"into","","",24,[[]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"size","","",24,[[]]],[11,"is_cool","","",24,[[]]],[11,"from_raw_parts","","",24,[[]]],[11,"from_raw_parts_mut","","",24,[[]]],[11,"from","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"into","","",25,[[]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"size","","",25,[[]]],[11,"is_cool","","",25,[[]]],[11,"from_raw_parts","","",25,[[]]],[11,"from_raw_parts_mut","","",25,[[]]],[11,"from","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"into","","",26,[[]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"size","","",26,[[]]],[11,"is_cool","","",26,[[]]],[11,"from_raw_parts","","",26,[[]]],[11,"from_raw_parts_mut","","",26,[[]]],[11,"from","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"into","","",27,[[]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"size","","",27,[[]]],[11,"is_cool","","",27,[[]]],[11,"from_raw_parts","","",27,[[]]],[11,"from_raw_parts_mut","","",27,[[]]],[11,"from","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"into","","",28,[[]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"size","","",28,[[]]],[11,"is_cool","","",28,[[]]],[11,"from_raw_parts","","",28,[[]]],[11,"from_raw_parts_mut","","",28,[[]]],[11,"from","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"into","","",29,[[]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow","","",29,[[]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"size","","",29,[[]]],[11,"is_cool","","",29,[[]]],[11,"from_raw_parts","","",29,[[]]],[11,"from_raw_parts_mut","","",29,[[]]],[11,"from","sunrise_ahci::disk","",30,[[]]],[11,"try_from","","",30,[[],["result",4]]],[11,"into","","",30,[[]]],[11,"try_into","","",30,[[],["result",4]]],[11,"borrow","","",30,[[]]],[11,"borrow_mut","","",30,[[]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"size","","",30,[[]]],[11,"is_cool","","",30,[[]]],[11,"from_raw_parts","","",30,[[]]],[11,"from_raw_parts_mut","","",30,[[]]],[11,"from","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"into","","",31,[[]]],[11,"try_into","","",31,[[],["result",4]]],[11,"borrow","","",31,[[]]],[11,"borrow_mut","","",31,[[]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"to_owned","","",31,[[]]],[11,"clone_into","","",31,[[]]],[11,"size","","",31,[[]]],[11,"is_cool","","",31,[[]]],[11,"from_raw_parts","","",31,[[]]],[11,"from_raw_parts_mut","","",31,[[]]],[11,"fmt","sunrise_ahci::pci","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_ahci::hba","Debug does not access reserved registers.",6,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","Debug does not access reserved registers.",10,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","Debug does not access reserved registers.",16,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","Debug does not access reserved registers.",20,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_ahci::disk","",30,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",31,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_ahci","",32,[[["formatter",3]],["result",6]]],[11,"drop","sunrise_ahci::disk","Dropping a disk brings the port to a stop, and clears the…",30,[[]]],[11,"clone","sunrise_ahci::pci","",1,[[],["pcidevice",3]]],[11,"clone","","",2,[[],["pciheader00",3]]],[11,"clone","","",3,[[],["pciheader",4]]],[11,"clone","","",4,[[],["bar",4]]],[11,"clone","sunrise_ahci::hba","",7,[[],["cap",3]]],[11,"clone","","",8,[[],["ghc",3]]],[11,"clone","","",9,[[],["cap2",3]]],[11,"clone","","",11,[[],["pxis",3]]],[11,"clone","","",12,[[],["pxie",3]]],[11,"clone","","",13,[[],["pxcmd",3]]],[11,"clone","","",14,[[],["pxtfd",3]]],[11,"clone","","",15,[[],["pxssts",3]]],[11,"clone","","",17,[[],["cmdheaderflags",3]]],[11,"clone","sunrise_ahci::disk","",31,[[],["idisk",3]]],[11,"clone","sunrise_ahci","",32,[[],["ahciinterface",3]]],[11,"default","","",32,[[],["ahciinterface",3]]],[11,"sector_count","sunrise_ahci::disk","Returns the number of addressable 512-octet sectors for…",31,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"read_dma","","Reads sectors from disk.",31,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"write_dma","","Writes sectors to disk.",31,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"discovered_disks_count","sunrise_ahci","Returns the number of discovered disks.",32,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"get_disk","","Gets the interface to a disk.",32,[[["workqueue",3]],[["idiskproxy",3],["error",4],["result",4]]]],[11,"bit_range","sunrise_ahci::hba","",7,[[]]],[11,"set_bit_range","","",7,[[]]],[11,"bit_range","","",8,[[]]],[11,"set_bit_range","","",8,[[]]],[11,"bit_range","","",9,[[]]],[11,"set_bit_range","","",9,[[]]],[11,"bit_range","","",11,[[]]],[11,"set_bit_range","","",11,[[]]],[11,"bit_range","","",12,[[]]],[11,"set_bit_range","","",12,[[]]],[11,"bit_range","","",13,[[]]],[11,"set_bit_range","","",13,[[]]],[11,"bit_range","","",14,[[]]],[11,"set_bit_range","","",14,[[]]],[11,"bit_range","","",15,[[]]],[11,"set_bit_range","","",15,[[]]],[11,"bit_range","","",17,[[]]],[11,"set_bit_range","","",17,[[]]]],"p":[[3,"PciConfigPortsPair"],[3,"PciDevice"],[3,"PciHeader00"],[4,"PciHeader"],[4,"BAR"],[3,"HbaMemoryRegisters"],[3,"GenericHostControl"],[3,"CAP"],[3,"GHC"],[3,"CAP2"],[3,"Px"],[3,"PxIS"],[3,"PxIE"],[3,"PxCMD"],[3,"PxTFD"],[3,"PxSSTS"],[3,"CmdHeader"],[3,"CmdHeaderFlags"],[3,"CmdHeaderArray"],[3,"CmdTable"],[3,"PrdtEntry"],[3,"ReceivedFis"],[19,"Cfis"],[3,"FisRegH2D"],[3,"FisRegD2H"],[3,"FisData"],[3,"FisPioSetup"],[3,"FisDmaSetup"],[3,"FisSetDeviceBits"],[4,"FisType"],[3,"Disk"],[3,"IDisk"],[3,"AhciInterface"]]},\
"sunrise_bootstrap":{"doc":"Bootstrap stage","i":[[3,"AlignedStack","sunrise_bootstrap","4 pages, PAGE_SIZE aligned.",null,null],[12,"0","","",0,null],[3,"EndTag","","",null,null],[12,"tag","","",1,null],[12,"flag","","",1,null],[12,"size","","",1,null],[3,"FramebufferTag","","",null,null],[12,"tag","","",2,null],[12,"flags","","",2,null],[12,"size","","",2,null],[12,"width","","",2,null],[12,"height","","",2,null],[12,"depth","","",2,null],[3,"ModuleAlignmentTag","","",null,null],[12,"tag","","",3,null],[12,"flags","","",3,null],[12,"size","","",3,null],[3,"MultiBootHeader","","The multiboot header structure of our binary.",null,null],[12,"magic","","",4,null],[12,"architecture","","",4,null],[12,"header_length","","",4,null],[12,"checksum","","",4,null],[12,"framebuffer","","",4,null],[12,"end","","",4,null],[5,"print_stack","","Prints raw hexdump of the stack. Use this if everything…",null,[[]]],[5,"bootstrap_start","","The very start.",null,[[]]],[5,"do_bootstrap","","bootstrap stage and call kernel",null,[[]]],[0,"bootstrap_logging","","bootstrap logging on rs232",null,null],[3,"Serial","sunrise_bootstrap::bootstrap_logging","A logger that sends its output to COM1.",null,null],[5,"init_bootstrap_log","","Init the rs232 COM1. Must be called before logging anything.",null,[[]]],[5,"bootstrap_log","","Sends a string to COM1.",null,[[]]],[5,"bootstrap_inb","","",null,[[]]],[5,"bootstrap_outb","","",null,[[]]],[17,"COM1","","",null,null],[0,"gdt","sunrise_bootstrap","GDT Handler",null,null],[3,"MAIN_TASK","sunrise_bootstrap::gdt","",null,null],[12,"__private_field","","",5,null],[3,"FAULT_TASK","","",null,null],[12,"__private_field","","",6,null],[3,"DescriptorTable","","A structure containing our GDT. We can have at most 16…",null,null],[12,"table","","",7,null],[3,"DescriptorTableEntry","","",null,null],[12,"0","","",8,null],[4,"SystemDescriptorTypes","","",null,null],[13,"AvailableTss16","","",9,null],[13,"Ldt","","",9,null],[13,"BusyTss16","","",9,null],[13,"CallGate16","","",9,null],[13,"TaskGate","","",9,null],[13,"InterruptGate16","","",9,null],[13,"TrapGate16","","",9,null],[13,"AvailableTss32","","",9,null],[13,"BusyTss32","","",9,null],[13,"CallGate32","","",9,null],[13,"InterruptGate32","","",9,null],[13,"TrapGate32","","",9,null],[5,"init_gdt","","",null,[[]]],[0,"segment_selector","","Types for the Global Descriptor Table and segment selectors.",null,null],[3,"SegmentSelector","sunrise_bootstrap::gdt::segment_selector","Specifies which element to load into a segment from…",null,null],[12,"0","","",10,null],[11,"new","","Creates a new SegmentSelector",10,[[["privilegelevel",4]],["segmentselector",3]]],[11,"index","","Returns the GDT index.",10,[[]]],[11,"rpl","","Returns the requested privilege level.",10,[[],["privilegelevel",4]]],[0,"i386","sunrise_bootstrap::gdt","This crate is x86_64\'s little brother. It provides i386…",null,null],[3,"TssStruct","sunrise_bootstrap::gdt::i386","The Task State Segment (TSS) is a special data structure…",null,null],[12,"_reserved1","","",11,null],[12,"link","","",11,null],[12,"esp0","","",11,null],[12,"_reserved2","","",11,null],[12,"ss0","","",11,null],[12,"esp1","","",11,null],[12,"_reserved3","","",11,null],[12,"ss1","","",11,null],[12,"esp2","","",11,null],[12,"_reserved4","","",11,null],[12,"ss2","","",11,null],[12,"cr3","","",11,null],[12,"eip","","",11,null],[12,"eflags","","",11,null],[12,"eax","","",11,null],[12,"ecx","","",11,null],[12,"edx","","",11,null],[12,"ebx","","",11,null],[12,"esp","","",11,null],[12,"ebp","","",11,null],[12,"esi","","",11,null],[12,"edi","","",11,null],[12,"_reserved5","","",11,null],[12,"es","","",11,null],[12,"_reserved6","","",11,null],[12,"cs","","",11,null],[12,"_reserved7","","",11,null],[12,"ss","","",11,null],[12,"_reserved8","","",11,null],[12,"ds","","",11,null],[12,"_reserved9","","",11,null],[12,"fs","","",11,null],[12,"_reserveda","","",11,null],[12,"gs","","",11,null],[12,"_reservedb","","",11,null],[12,"ldt_selector","","",11,null],[12,"iopboffset","","",11,null],[12,"_reservedc","","",11,null],[4,"PrivilegeLevel","","Represents a protection ring level.",null,null],[13,"Ring0","","Privilege-level 0 (most privilege): This level is used by…",12,null],[13,"Ring1","","Privilege-level 1 (moderate privilege): This level is used…",12,null],[13,"Ring2","","Privilege-level 2 (moderate privilege): Like level 1, this…",12,null],[13,"Ring3","","Privilege-level 3 (least privilege): This level is used by…",12,null],[0,"instructions","","Low level functions for special i386 instructions.",null,null],[0,"tables","sunrise_bootstrap::gdt::i386::instructions","Instructions for loading descriptor tables (GDT, IDT, etc.).",null,null],[3,"DescriptorTablePointer","sunrise_bootstrap::gdt::i386::instructions::tables","A struct describing a pointer to a descriptor table (GDT /…",null,null],[12,"limit","","Size of the DT.",13,null],[12,"base","","Pointer to the memory region containing the DT.",13,null],[5,"lgdt","","Load GDT table.",null,[[["descriptortablepointer",3]]]],[5,"lldt","","Load LDT table.",null,[[["segmentselector",3]]]],[5,"ltr","","Sets the task register to the given TSS segment.",null,[[["segmentselector",3]]]],[5,"lidt","","Load IDT table.",null,[[["descriptortablepointer",3]]]],[0,"segmentation","sunrise_bootstrap::gdt::i386::instructions","Provides functions to read and write segment registers.",null,null],[5,"set_cs","sunrise_bootstrap::gdt::i386::instructions::segmentation","Reload code segment register. Note this is special since…",null,[[["segmentselector",3]]]],[5,"load_ss","","Reload stack segment register.",null,[[["segmentselector",3]]]],[5,"load_ds","","Reload data segment register.",null,[[["segmentselector",3]]]],[5,"load_es","","Reload es segment register.",null,[[["segmentselector",3]]]],[5,"load_fs","","Reload fs segment register.",null,[[["segmentselector",3]]]],[5,"load_gs","","Reload gs segment register.",null,[[["segmentselector",3]]]],[5,"cs","","Returns the current value of the code segment register.",null,[[],["segmentselector",3]]],[0,"interrupts","sunrise_bootstrap::gdt::i386::instructions","Interrupt disabling functionality.",null,null],[5,"sti","sunrise_bootstrap::gdt::i386::instructions::interrupts","Enable interrupts",null,[[]]],[5,"cli","","Disable interrupts",null,[[]]],[11,"from_u16","sunrise_bootstrap::gdt::i386","Creates a `PrivilegeLevel` from a numeric value. The value…",12,[[],["privilegelevel",4]]],[11,"new","","",11,[[["segmentselector",3]],["tssstruct",3]]],[7,"GDT","sunrise_bootstrap::gdt","The GDT set-up by the bootstrap",null,null],[7,"GLOBAL_LDT","","The global LDT used by all the processes.",null,null],[11,"new","","",7,[[],["descriptortable",3]]],[11,"push","","",7,[[["descriptortableentry",3]]]],[11,"load_global","","",7,[[]]],[11,"null_descriptor","","",8,[[],["descriptortableentry",3]]],[11,"new","","Creates an empty GDT descriptor, but with some flags set…",8,[[["privilegelevel",4]],["descriptortableentry",3]]],[11,"new_system","","Creates an empty GDT descriptor, but with some flags set…",8,[[["systemdescriptortypes",4],["privilegelevel",4]],["descriptortableentry",3]]],[11,"new_ldt","","Creates a new LDT descriptor.",8,[[["descriptortable",3],["privilegelevel",4]],["descriptortableentry",3]]],[11,"new_tss","","Creates a GDT descriptor pointing to a TSS segment",8,[[["tssstruct",3],["privilegelevel",4]],["descriptortableentry",3]]],[11,"get_limit","","",8,[[]]],[11,"set_limit","","",8,[[]]],[11,"get_base","","",8,[[]]],[11,"set_base","","",8,[[]]],[11,"get_accessed","","",8,[[]]],[11,"is_readwrite_allowed","","",8,[[]]],[11,"is_comformant","","",8,[[]]],[11,"is_executable","","",8,[[]]],[11,"get_ring_level","","",8,[[],["privilegelevel",4]]],[11,"get_present","","",8,[[]]],[11,"is_4k_granularity","","",8,[[]]],[11,"set_4k_granularity","","",8,[[]]],[11,"is_32bit","","",8,[[]]],[0,"address","sunrise_bootstrap","Physical and Virtual address wrappers",null,null],[3,"PhysicalAddress","sunrise_bootstrap::address","Represents a Physical address",null,null],[12,"0","","",14,null],[3,"VirtualAddress","","Represents a Virtual address",null,null],[12,"0","","",15,null],[11,"addr","","Gets the address as a `usize`.",15,[[]]],[11,"addr","","Gets the address as a `usize`.",14,[[]]],[11,"floor","","Rounds down to PAGE_SIZE.",14,[[],["physicaladdress",3]]],[11,"ceil","","Rounds up PAGE_SIZE.",14,[[],["physicaladdress",3]]],[11,"floor","","Rounds down to PAGE_SIZE.",15,[[],["virtualaddress",3]]],[11,"ceil","","Rounds up PAGE_SIZE.",15,[[],["virtualaddress",3]]],[0,"paging","sunrise_bootstrap","Paging on i386",null,null],[3,"ActivePageTables","sunrise_bootstrap::paging","The page tables set currently in use.",null,null],[3,"InactivePageTables","","A set of PageTables that are not the ones currently in…",null,null],[12,"directory_physical_address","","",16,null],[3,"PagingOffPageSet","","Used at startup when paging is off to create and…",null,null],[12,"directory_physical_address","","",17,null],[3,"EntryFlags","","The flags of a table entry",null,null],[12,"bits","","",18,null],[3,"KernelLand","","The virtual memory belonging to kernel.",null,null],[3,"UserLand","","The virtual memory belonging to user.",null,null],[4,"MappingType","","The type of a Virtual Memory mapping. Can either be…",null,null],[13,"Present","","",19,null],[13,"Guard","","",19,null],[5,"is_paging_on","","Check if the paging is currently active.",null,[[]]],[5,"enable_paging","","",null,[[["physicaladdress",3]]]],[5,"flush_tlb","","Flush the Translation Lookaside Buffer…",null,[[]]],[5,"swap_cr3","","Changes the content of the cr3 register, and returns the…",null,[[["physicaladdress",3]],["physicaladdress",3]]],[5,"map_bootstrap","","Creates a set of page tables identity mapping the Bootstrap.",null,[[["bootinformation",3]],["pagingoffpageset",3]]],[5,"get_page","","Creates a mapping in the page tables with the given flags.…",null,[[],["virtualaddress",3]]],[0,"entry","","i386 page table entry",null,null],[3,"EntryFlags","sunrise_bootstrap::paging::entry","The flags of a table entry",null,null],[12,"bits","","",20,null],[3,"Entry","","An entry in a page table or page directory. An unused…",null,null],[12,"0","","",21,null],[4,"PageState","","Represent the current state of this Page Table Entry: It…",null,null],[13,"Available","","",22,null],[13,"Guarded","","",22,null],[13,"Present","","",22,null],[17,"ENTRY_PHYS_ADDRESS_MASK","","",null,null],[18,"PRESENT","","",20,null],[18,"WRITABLE","","",20,null],[18,"USER_ACCESSIBLE","","",20,null],[18,"WRITE_THROUGH","","",20,null],[18,"NO_CACHE","","",20,null],[18,"ACCESSED","","",20,null],[18,"DIRTY","","",20,null],[18,"HUGE_PAGE","","",20,null],[18,"GLOBAL","","",20,null],[18,"GUARD_PAGE","","",20,null],[18,"IS_FRAME_ALLOC","","",20,null],[18,"USER_DEFINED_3","","",20,null],[11,"empty","","Returns an empty set of flags",20,[[],["entryflags",3]]],[11,"all","","Returns the set containing all flags.",20,[[],["entryflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",20,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",20,[[],[["entryflags",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",20,[[],["entryflags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",20,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",20,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",20,[[["entryflags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",20,[[["entryflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",20,[[["entryflags",3]]]],[11,"remove","","Removes the specified flags in-place.",20,[[["entryflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",20,[[["entryflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",20,[[["entryflags",3]]]],[11,"is_unused","","Is the entry unused ?",21,[[]]],[11,"set_unused","","Clear the entry",21,[[],[["frame",3],["pagestate",4]]]],[11,"is_guard","","Is the entry a page guard ?",21,[[]]],[11,"flags","","Get the current entry flags",21,[[],["entryflags",3]]],[11,"pointed_frame","","Get the associated physical address, if available",21,[[],[["pagestate",4],["physicaladdress",3]]]],[11,"set","","Sets the entry",21,[[["frame",3],["entryflags",3]]]],[11,"set_guard","","Make this entry a page guard",21,[[]]],[11,"unwrap","","Move the value T out of the PageState if it is Present(T).",22,[[]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",22,[[],["pagestate",4]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",22,[[],["option",4]]],[0,"table","sunrise_bootstrap::paging","i386 page table / directory",null,null],[3,"PageTable","sunrise_bootstrap::paging::table","A page table",null,null],[12,"entries","","",23,null],[3,"PageDirectory","","A page directory",null,null],[12,"0","","",24,null],[3,"EntryFlags","","The flags of a table entry",null,null],[12,"bits","","",18,null],[3,"ActivePageTables","","The page tables set currently in use.",null,null],[3,"ActivePageDirectory","","The page directory currently in use.",null,null],[12,"0","","",25,null],[3,"ActivePageTable","","A page table currently in use.",null,null],[12,"0","","",26,null],[3,"SmartHierarchicalTable","","This is just a wrapper for a pointer to a Table or a…",null,null],[12,"0","","",27,null],[12,"1","","",27,null],[3,"InactivePageTables","","A set of PageTables that are not the ones currently in…",null,null],[12,"directory_physical_address","","",16,null],[3,"InactivePageDirectory","","A temporary mapped page directory.",null,null],[12,"0","","",28,null],[3,"InactivePageTable","","A temporary mapped page table.",null,null],[12,"0","","",29,null],[3,"PagingOffPageSet","","Used at startup when paging is off to create and…",null,null],[12,"directory_physical_address","","",17,null],[3,"PagingOffDirectory","","A directory we can modify by directly accessing physical…",null,null],[12,"0","","",30,null],[3,"PagingOffTable","","A table we can modify by directly accessing physical…",null,null],[12,"0","","",31,null],[3,"TlbFlush","","When passing this struct the TLB will be flushed. Used by…",null,null],[3,"NoFlush","","When passing this struct the TLB will not be flushed. Used…",null,null],[4,"MappingType","","The type of a Virtual Memory mapping. Can either be…",null,null],[13,"Present","","",19,null],[13,"Guard","","",19,null],[0,"entry","","i386 page table entry",null,null],[3,"EntryFlags","sunrise_bootstrap::paging::table::entry","The flags of a table entry",null,null],[12,"bits","","",32,null],[3,"Entry","","An entry in a page table or page directory. An unused…",null,null],[12,"0","","",33,null],[4,"PageState","","Represent the current state of this Page Table Entry: It…",null,null],[13,"Available","","",34,null],[13,"Guarded","","",34,null],[13,"Present","","",34,null],[17,"ENTRY_PHYS_ADDRESS_MASK","","",null,null],[18,"PRESENT","","",32,null],[18,"WRITABLE","","",32,null],[18,"USER_ACCESSIBLE","","",32,null],[18,"WRITE_THROUGH","","",32,null],[18,"NO_CACHE","","",32,null],[18,"ACCESSED","","",32,null],[18,"DIRTY","","",32,null],[18,"HUGE_PAGE","","",32,null],[18,"GLOBAL","","",32,null],[18,"GUARD_PAGE","","",32,null],[18,"IS_FRAME_ALLOC","","",32,null],[18,"USER_DEFINED_3","","",32,null],[11,"empty","","Returns an empty set of flags",32,[[],["entryflags",3]]],[11,"all","","Returns the set containing all flags.",32,[[],["entryflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",32,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",32,[[],[["option",4],["entryflags",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",32,[[],["entryflags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",32,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",32,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",32,[[["entryflags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",32,[[["entryflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",32,[[["entryflags",3]]]],[11,"remove","","Removes the specified flags in-place.",32,[[["entryflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",32,[[["entryflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",32,[[["entryflags",3]]]],[11,"is_unused","","Is the entry unused ?",33,[[]]],[11,"set_unused","","Clear the entry",33,[[],[["pagestate",4],["frame",3]]]],[11,"is_guard","","Is the entry a page guard ?",33,[[]]],[11,"flags","","Get the current entry flags",33,[[],["entryflags",3]]],[11,"pointed_frame","","Get the associated physical address, if available",33,[[],[["pagestate",4],["physicaladdress",3]]]],[11,"set","","Sets the entry",33,[[["frame",3],["entryflags",3]]]],[11,"set_guard","","Make this entry a page guard",33,[[]]],[11,"unwrap","","Move the value T out of the PageState if it is Present(T).",34,[[]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",34,[[],["pagestate",4]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",34,[[],["option",4]]],[0,"detail","sunrise_bootstrap::paging::table","",null,null],[8,"I386PageTablesSet","sunrise_bootstrap::paging::table::detail","A trait describing the interface of a PageTable hierarchy.",null,null],[16,"PageDirectoryType","","",35,null],[10,"get_directory","","Gets a reference to the directory",35,[[],["smarthierarchicaltable",3]]],[17,"DIRECTORY_RECURSIVE_ADDRESS","sunrise_bootstrap::paging::table","When paging is on, accessing this address loops back to…",null,null],[8,"HierarchicalTable","","A table of entries, either the directory or one of the…",null,null],[10,"entries","","",36,[[]]],[10,"entries_mut","","",36,[[]]],[11,"zero","","zero out the whole table",36,[[]]],[11,"map_nth_entry","","Creates a mapping on the nth entry of a table T is a…",36,[[["frame",3],["i386entryflags",3]]]],[11,"guard_nth_entry","","Marks the nth entry as guard page T is a flusher…",36,[[]]],[11,"flush_cache","","",36,[[]]],[8,"PageTableTrait","","",null,null],[16,"FlusherType","","",37,null],[11,"map_whole_table","","Used at startup when creating the first page tables.",37,[[["i386entryflags",3],["physicaladdress",3]]]],[11,"map_guard_whole_table","","Used at startup when creating the first page tables.",37,[[]]],[8,"PageDirectoryTrait","","A trait describing all the things that a PageDirectory can…",null,null],[16,"PageTableType","","",38,null],[16,"FlusherType","","",38,null],[10,"get_table","","Gets a reference to a page table",38,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[10,"create_table","","Allocates a page table, zero it and add an entry to the…",38,[[],["smarthierarchicaltable",3]]],[11,"get_table_or_create","","Gets the page table at given index, or creates it if it…",38,[[],["smarthierarchicaltable",3]]],[11,"map_to","","Creates a mapping in the page tables with the given flags",38,[[["frame",3],["virtualaddress",3],["i386entryflags",3]]]],[11,"guard","","Creates a guard page",38,[[["virtualaddress",3]]]],[11,"__unmap","","Deletes a mapping in the page tables, returning the frame…",38,[[["virtualaddress",3]],[["pagestate",4],["frame",3]]]],[11,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",38,[[],[["option",4],["virtualaddress",3]]]],[8,"PageTablesSet","","",null,null],[10,"map_to","","Creates a mapping in the page tables with the given flags",39,[[["virtualaddress",3],["mappingtype",4]]]],[10,"get_phys","","Gets the current mapping state of this Virtual Address.",39,[[["virtualaddress",3]],[["pagestate",4],["physicaladdress",3]]]],[10,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",39,[[],[["option",4],["virtualaddress",3]]]],[11,"print_mapping","","Prints the current mapping.",39,[[]]],[10,"unmap","","Deletes a mapping in the page tables, returning the Frame…",39,[[["virtualaddress",3]],[["pagestate",4],["frame",3]]]],[11,"map_allocate_to","","Creates a mapping in the page tables with the given flags.…",39,[[["virtualaddress",3],["entryflags",3]]]],[11,"map_frame","","Maps a given frame in the page tables. Takes care of…",39,[[["frame",3],["entryflags",3]],["virtualaddress",3]]],[11,"get_page","","Creates a mapping in the page tables with the given flags.…",39,[[],["virtualaddress",3]]],[11,"map_page_guard","","Reserves a given page as guard page. This affects only…",39,[[["virtualaddress",3]]]],[11,"map_range_page_guard","","Reserve a given region as guard pages. If the region spans…",39,[[["virtualaddress",3]]]],[11,"map_range","","Maps the given physical address range to the given virtual…",39,[[["virtualaddress",3],["entryflags",3],["physicaladdress",3]]]],[11,"map_range_allocate","","Maps a given number of consecutive pages at a given…",39,[[["virtualaddress",3],["entryflags",3]]]],[11,"identity_map","","Maps a memory frame to the same virtual address",39,[[["frame",3],["entryflags",3]]]],[11,"identity_map_region","","Identity maps a range of frames",39,[[["entryflags",3],["physicaladdress",3]]]],[11,"find_available_virtual_space","","Finds a virtual space hole that can contain page_nb…",39,[[],[["option",4],["virtualaddress",3]]]],[11,"set_page_readonly","","Sets a previously mapped page as readonly",39,[[["virtualaddress",3]]]],[11,"set_region_readonly","","Sets a previously mapped range of pages readonly",39,[[["virtualaddress",3]]]],[8,"Flusher","","A trait used to decide if the TLB cache should be flushed…",null,null],[11,"flush_cache","","",40,[[]]],[18,"WRITABLE","sunrise_bootstrap::paging","",18,null],[18,"USER_ACCESSIBLE","","",18,null],[11,"empty","","Returns an empty set of flags",18,[[],["entryflags",3]]],[11,"all","","Returns the set containing all flags.",18,[[],["entryflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",18,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",18,[[],[["option",4],["entryflags",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",18,[[],["entryflags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",18,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",18,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",18,[[["entryflags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",18,[[["entryflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",18,[[["entryflags",3]]]],[11,"remove","","Removes the specified flags in-place.",18,[[["entryflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",18,[[["entryflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",18,[[["entryflags",3]]]],[11,"get_table_address","sunrise_bootstrap::paging::table","reduce recursive mapping by one time to get further down…",25,[[],["pagestate",4]]],[11,"new","","",27,[[],["smarthierarchicaltable",3]]],[11,"new","sunrise_bootstrap::paging","Creates a new set of inactive page tables",16,[[],["inactivepagetables",3]]],[11,"switch_to","","Switch to this page tables set. Returns the old active…",16,[[],["inactivepagetables",3]]],[11,"delete","","",16,[[]]],[11,"delete_userspace","sunrise_bootstrap::paging::table","",28,[[]]],[11,"copy_active_kernelspace","","Copies all the entries in the directory mapping tables…",28,[[]]],[11,"free_all_frames","","Frees all pages mapped by this table, and mark the frames…",29,[[]]],[11,"paging_off_create_page_set","sunrise_bootstrap::paging","Used at startup when the paging is disabled and creating…",17,[[]]],[11,"enable_paging","","Enables paging with this tables as active tables",17,[[]]],[11,"init_directory","sunrise_bootstrap::paging::table","Initializes the directory. This function does two things:",30,[[]]],[7,"ACTIVE_PAGE_TABLES","sunrise_bootstrap::paging","Currently active page tables.",null,null],[17,"PAGE_SIZE","","The size of a single page.",null,null],[17,"ENTRY_COUNT","","",null,null],[8,"PageTablesSet","","",null,null],[10,"map_to","","Creates a mapping in the page tables with the given flags",39,[[["virtualaddress",3],["mappingtype",4]]]],[10,"get_phys","","Gets the current mapping state of this Virtual Address.",39,[[["virtualaddress",3]],[["pagestate",4],["physicaladdress",3]]]],[10,"find_available_virtual_space_aligned","","Finds a virtual space hole that can contain page_nb…",39,[[],[["option",4],["virtualaddress",3]]]],[11,"print_mapping","sunrise_bootstrap::paging::table","Prints the current mapping.",39,[[]]],[10,"unmap","sunrise_bootstrap::paging","Deletes a mapping in the page tables, returning the Frame…",39,[[["virtualaddress",3]],[["pagestate",4],["frame",3]]]],[11,"map_allocate_to","sunrise_bootstrap::paging::table","Creates a mapping in the page tables with the given flags.…",39,[[["virtualaddress",3],["entryflags",3]]]],[11,"map_frame","","Maps a given frame in the page tables. Takes care of…",39,[[["frame",3],["entryflags",3]],["virtualaddress",3]]],[11,"get_page","","Creates a mapping in the page tables with the given flags.…",39,[[],["virtualaddress",3]]],[11,"map_page_guard","","Reserves a given page as guard page. This affects only…",39,[[["virtualaddress",3]]]],[11,"map_range_page_guard","","Reserve a given region as guard pages. If the region spans…",39,[[["virtualaddress",3]]]],[11,"map_range","","Maps the given physical address range to the given virtual…",39,[[["virtualaddress",3],["entryflags",3],["physicaladdress",3]]]],[11,"map_range_allocate","","Maps a given number of consecutive pages at a given…",39,[[["virtualaddress",3],["entryflags",3]]]],[11,"identity_map","","Maps a memory frame to the same virtual address",39,[[["frame",3],["entryflags",3]]]],[11,"identity_map_region","","Identity maps a range of frames",39,[[["entryflags",3],["physicaladdress",3]]]],[11,"find_available_virtual_space","","Finds a virtual space hole that can contain page_nb…",39,[[],[["option",4],["virtualaddress",3]]]],[11,"set_page_readonly","","Sets a previously mapped page as readonly",39,[[["virtualaddress",3]]]],[11,"set_region_readonly","","Sets a previously mapped range of pages readonly",39,[[["virtualaddress",3]]]],[8,"VirtualSpaceLand","sunrise_bootstrap::paging","A trait describing the splitting of virtual memory between…",null,null],[10,"start_addr","","The first address in this land.",41,[[],["virtualaddress",3]]],[10,"end_addr","","The last address in this land.",41,[[],["virtualaddress",3]]],[11,"start_table","","The index in page directory of the first table of this land",41,[[]]],[11,"end_table","","The index in page directory of the last table of this land",41,[[]]],[11,"start_addr","","",42,[[],["virtualaddress",3]]],[11,"end_addr","","",42,[[],["virtualaddress",3]]],[11,"start_addr","","",43,[[],["virtualaddress",3]]],[11,"end_addr","","",43,[[],["virtualaddress",3]]],[0,"frame_alloc","sunrise_bootstrap","A module implementing a physical memory manager that…",null,null],[3,"AllocatorBitmap","sunrise_bootstrap::frame_alloc","A big bitmap denoting for every frame if it is free or not",null,null],[12,"memory_bitmap","","",44,null],[12,"initialized","","",44,null],[3,"Frame","","A pointer to a physical frame",null,null],[12,"physical_addr","","",45,null],[12,"is_allocated","","",45,null],[3,"FrameAllocator","","A physical memory manger to allocate and free memory frames",null,null],[5,"addr_to_frame","","Gets the frame number from a physical address",null,[[]]],[5,"frame_to_addr","","Gets the physical address from a frame number",null,[[]]],[5,"round_to_page","","Rounds an address to its page address",null,[[]]],[5,"round_to_page_upper","","Rounds an address to the next page address except if its…",null,[[]]],[7,"FRAMES_BITMAP","","A big bitmap denoting for every frame if it is free or not",null,null],[17,"MEMORY_FRAME_SIZE","","A memory frame is the same size as a page",null,null],[17,"FRAME_OFFSET_MASK","","",null,null],[17,"FRAME_BASE_MASK","","",null,null],[17,"FRAME_BASE_LOG","","",null,null],[17,"FRAMES_BITMAP_SIZE","","When testing we use a much smaller array.",null,null],[17,"FRAME_FREE","","",null,null],[17,"FRAME_OCCUPIED","","",null,null],[11,"address","","Get the physical address of this Frame",45,[[],["physicaladdress",3]]],[11,"is_allocated","","Gets the current allocation state",45,[[]]],[11,"from_physical_addr","","Constructs a frame structure from a physical address",45,[[["physicaladdress",3]],["frame",3]]],[11,"from_allocated_addr","","Constructs a frame structure from a physical address",45,[[["physicaladdress",3]],["frame",3]]],[11,"init","","Initialize the FrameAllocator by parsing the multiboot…",46,[[["bootinformation",3]]]],[11,"check_initialized","","Panics if the frames bitmap was not initialized",46,[[["allocatorbitmap",3]]]],[11,"mark_area_reserved","","Marks a physical memory area as reserved and will never…",46,[[]]],[11,"mark_area_free","","Marks a physical memory area as free for frame allocation",46,[[]]],[11,"alloc_frame","","Allocates a free frame",46,[[],["frame",3]]],[11,"alloc_contiguous_frames","","Allocates count contiguous frames.",46,[[],["physicaladdress",3]]],[11,"free_frame","","Frees an allocated frame.",46,[[["frame",3]]]],[0,"elf_loader","sunrise_bootstrap","Loads the kernel in high memory",null,null],[5,"load_kernel","sunrise_bootstrap::elf_loader","Loads the kernel in high memory Returns address of entry…",null,[[["pagingoffpageset",3],["bootinformation",3]]]],[5,"load_segment","","Loads an elf segment by coping file_size bytes to the…",null,[[["pagingoffpageset",3],["elffile",3],["programheader",4]]]],[0,"bootstrap_stack","sunrise_bootstrap","Bootstrap stack",null,null],[3,"BootstrapStack","sunrise_bootstrap::bootstrap_stack","A structure representing a kernel stack",null,null],[12,"stack_address","","",47,null],[17,"STACK_SIZE","","The size of a kernel stack in pages, not accounting for…",null,null],[17,"STACK_SIZE_WITH_GUARD","","The size of a kernel stack in pages, with the page guard.",null,null],[17,"STACK_SIZE_WITH_GUARD_IN_BYTES","","The size of the kernel stack, with the page guard, as a…",null,null],[17,"STACK_ALIGNMENT","","The alignment of the stack.",null,null],[11,"allocate_stack","","Allocates the bootstrap stack",47,[[],[["bootstrapstack",3],["option",4]]]],[18,"STACK_POISON_SIZE","","We keep 2 poison pointers for fake saved ebp and saved esp…",47,null],[11,"create_poison_pointers","","Puts two poisons pointers at the base of the stack for the…",47,[[]]],[11,"get_stack_start","","Get the address of the beginning of usable stack. Used for…",47,[[]]],[7,"STACK","sunrise_bootstrap","The stack we start on.",null,null],[7,"MULTIBOOT_HEADER","","The multiboot header of our binary.",null,null],[11,"default","","",1,[[],["endtag",3]]],[11,"new","","",2,[[],["framebuffertag",3]]],[11,"new","","",3,[[],["modulealignmenttag",3]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::bootstrap_logging","",48,[[]]],[11,"try_from","","",48,[[],["result",4]]],[11,"into","","",48,[[]]],[11,"try_into","","",48,[[],["result",4]]],[11,"borrow","","",48,[[]]],[11,"borrow_mut","","",48,[[]]],[11,"type_id","","",48,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::gdt","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"from","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"from","sunrise_bootstrap::gdt::segment_selector","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::gdt::i386","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"from","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"into","","",12,[[]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"from","sunrise_bootstrap::gdt::i386::instructions::tables","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"into","","",13,[[]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::address","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"into","","",14,[[]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"to_string","","",14,[[],["string",3]]],[11,"from","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"into","","",15,[[]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"to_string","","",15,[[],["string",3]]],[11,"from","sunrise_bootstrap::paging","",49,[[]]],[11,"try_from","","",49,[[],["result",4]]],[11,"into","","",49,[[]]],[11,"try_into","","",49,[[],["result",4]]],[11,"borrow","","",49,[[]]],[11,"borrow_mut","","",49,[[]]],[11,"type_id","","",49,[[],["typeid",3]]],[11,"from","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"into","","",16,[[]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"into","","",17,[[]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"into","","",18,[[]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"to_owned","","",18,[[]]],[11,"clone_into","","",18,[[]]],[11,"from","","",42,[[]]],[11,"try_from","","",42,[[],["result",4]]],[11,"into","","",42,[[]]],[11,"try_into","","",42,[[],["result",4]]],[11,"borrow","","",42,[[]]],[11,"borrow_mut","","",42,[[]]],[11,"type_id","","",42,[[],["typeid",3]]],[11,"from","","",43,[[]]],[11,"try_from","","",43,[[],["result",4]]],[11,"into","","",43,[[]]],[11,"try_into","","",43,[[],["result",4]]],[11,"borrow","","",43,[[]]],[11,"borrow_mut","","",43,[[]]],[11,"type_id","","",43,[[],["typeid",3]]],[11,"from","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"into","","",19,[[]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::paging::entry","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"into","","",20,[[]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"to_owned","","",20,[[]]],[11,"clone_into","","",20,[[]]],[11,"from","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"into","","",21,[[]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"to_owned","","",21,[[]]],[11,"clone_into","","",21,[[]]],[11,"from","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"into","","",22,[[]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::paging::table","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"into","","",23,[[]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"into","","",24,[[]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"into","","",25,[[]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"into","","",26,[[]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"into","","",27,[[]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"into","","",28,[[]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"from","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"into","","",29,[[]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow","","",29,[[]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"from","","",30,[[]]],[11,"try_from","","",30,[[],["result",4]]],[11,"into","","",30,[[]]],[11,"try_into","","",30,[[],["result",4]]],[11,"borrow","","",30,[[]]],[11,"borrow_mut","","",30,[[]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"from","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"into","","",31,[[]]],[11,"try_into","","",31,[[],["result",4]]],[11,"borrow","","",31,[[]]],[11,"borrow_mut","","",31,[[]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"from","","",50,[[]]],[11,"try_from","","",50,[[],["result",4]]],[11,"into","","",50,[[]]],[11,"try_into","","",50,[[],["result",4]]],[11,"borrow","","",50,[[]]],[11,"borrow_mut","","",50,[[]]],[11,"type_id","","",50,[[],["typeid",3]]],[11,"from","","",51,[[]]],[11,"try_from","","",51,[[],["result",4]]],[11,"into","","",51,[[]]],[11,"try_into","","",51,[[],["result",4]]],[11,"borrow","","",51,[[]]],[11,"borrow_mut","","",51,[[]]],[11,"type_id","","",51,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::paging::table::entry","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"into","","",32,[[]]],[11,"try_into","","",32,[[],["result",4]]],[11,"borrow","","",32,[[]]],[11,"borrow_mut","","",32,[[]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"to_owned","","",32,[[]]],[11,"clone_into","","",32,[[]]],[11,"from","","",33,[[]]],[11,"try_from","","",33,[[],["result",4]]],[11,"into","","",33,[[]]],[11,"try_into","","",33,[[],["result",4]]],[11,"borrow","","",33,[[]]],[11,"borrow_mut","","",33,[[]]],[11,"type_id","","",33,[[],["typeid",3]]],[11,"to_owned","","",33,[[]]],[11,"clone_into","","",33,[[]]],[11,"from","","",34,[[]]],[11,"try_from","","",34,[[],["result",4]]],[11,"into","","",34,[[]]],[11,"try_into","","",34,[[],["result",4]]],[11,"borrow","","",34,[[]]],[11,"borrow_mut","","",34,[[]]],[11,"type_id","","",34,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::frame_alloc","",44,[[]]],[11,"try_from","","",44,[[],["result",4]]],[11,"into","","",44,[[]]],[11,"try_into","","",44,[[],["result",4]]],[11,"borrow","","",44,[[]]],[11,"borrow_mut","","",44,[[]]],[11,"type_id","","",44,[[],["typeid",3]]],[11,"from","","",45,[[]]],[11,"try_from","","",45,[[],["result",4]]],[11,"into","","",45,[[]]],[11,"try_into","","",45,[[],["result",4]]],[11,"borrow","","",45,[[]]],[11,"borrow_mut","","",45,[[]]],[11,"type_id","","",45,[[],["typeid",3]]],[11,"from","","",46,[[]]],[11,"try_from","","",46,[[],["result",4]]],[11,"into","","",46,[[]]],[11,"try_into","","",46,[[],["result",4]]],[11,"borrow","","",46,[[]]],[11,"borrow_mut","","",46,[[]]],[11,"type_id","","",46,[[],["typeid",3]]],[11,"from","sunrise_bootstrap::bootstrap_stack","",47,[[]]],[11,"try_from","","",47,[[],["result",4]]],[11,"into","","",47,[[]]],[11,"try_into","","",47,[[],["result",4]]],[11,"borrow","","",47,[[]]],[11,"borrow_mut","","",47,[[]]],[11,"type_id","","",47,[[],["typeid",3]]],[11,"entries","sunrise_bootstrap::paging::table","",23,[[]]],[11,"entries_mut","","",23,[[]]],[11,"entries","","",24,[[]]],[11,"entries_mut","","",24,[[]]],[11,"entries","","",25,[[]]],[11,"entries_mut","","",25,[[]]],[11,"entries","","",26,[[]]],[11,"entries_mut","","",26,[[]]],[11,"entries","","",28,[[]]],[11,"entries_mut","","",28,[[]]],[11,"entries","","",29,[[]]],[11,"entries_mut","","",29,[[]]],[11,"entries","","",30,[[]]],[11,"entries_mut","","",30,[[]]],[11,"entries","","",31,[[]]],[11,"entries_mut","","",31,[[]]],[11,"get_table","","Gets a reference to a page table through recursive mapping",25,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[11,"create_table","","Allocates a page table, zero it and add an entry to the…",25,[[],["smarthierarchicaltable",3]]],[11,"get_table","","Temporary map the table",28,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[11,"create_table","","Allocates a page table, temporarily map it, zero it and…",28,[[],["smarthierarchicaltable",3]]],[11,"get_table","","Simply cast pointed frame as PageTable",30,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[11,"create_table","","Allocates a page table, zero it and add an entry to the…",30,[[],["smarthierarchicaltable",3]]],[11,"get_directory","sunrise_bootstrap::paging","",49,[[],[["activepagedirectory",3],["smarthierarchicaltable",3]]]],[11,"get_directory","","Temporary map the directory",16,[[],[["inactivepagedirectory",3],["smarthierarchicaltable",3]]]],[11,"get_directory","","",17,[[],["smarthierarchicaltable",3]]],[11,"flush_cache","sunrise_bootstrap::paging::table","",50,[[]]],[11,"flush_cache","","",51,[[]]],[11,"start_addr","sunrise_bootstrap::paging","",42,[[],["virtualaddress",3]]],[11,"end_addr","","",42,[[],["virtualaddress",3]]],[11,"start_addr","","",43,[[],["virtualaddress",3]]],[11,"end_addr","","",43,[[],["virtualaddress",3]]],[11,"deref","sunrise_bootstrap::gdt","",5,[[],["tssstruct",3]]],[11,"deref","","",6,[[],["tssstruct",3]]],[11,"deref","sunrise_bootstrap::paging::table","",25,[[]]],[11,"deref","","",26,[[]]],[11,"deref","","",27,[[]]],[11,"deref","","",28,[[]]],[11,"deref","","",29,[[]]],[11,"deref","","",30,[[]]],[11,"deref","","",31,[[]]],[11,"deref_mut","","",25,[[]]],[11,"deref_mut","","",26,[[]]],[11,"deref_mut","","",27,[[]]],[11,"deref_mut","","",28,[[]]],[11,"deref_mut","","",29,[[]]],[11,"deref_mut","","",30,[[]]],[11,"deref_mut","","",31,[[]]],[11,"from","sunrise_bootstrap::paging::entry","",20,[[["entryflags",3]],["entryflags",3]]],[11,"from","sunrise_bootstrap::paging::table::entry","",32,[[["entryflags",3]],["entryflags",3]]],[11,"fmt","sunrise_bootstrap::gdt::segment_selector","",10,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::gdt::i386","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::gdt","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::address","",14,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",15,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","sunrise_bootstrap::paging::entry","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging::table::entry","",32,[[["formatter",3]],["result",6]]],[11,"fmt","","",33,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",34,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging","",18,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::frame_alloc","",45,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::bootstrap_stack","",47,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::address","",14,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",15,[[["formatter",3]],[["error",3],["result",4]]]],[11,"sub","","Subtracting a length from an address gives another address",15,[[],["virtualaddress",3]]],[11,"sub","","Subtracting a length from an address gives another address",14,[[],["physicaladdress",3]]],[11,"sub","","Subtracting two address gives their distance",15,[[["virtualaddress",3]]]],[11,"sub","","Subtracting two address gives their distance",14,[[["physicaladdress",3]]]],[11,"sub","sunrise_bootstrap::paging::entry","Returns the set difference of the two sets of flags.",20,[[["entryflags",3]],["entryflags",3]]],[11,"sub","sunrise_bootstrap::paging::table::entry","Returns the set difference of the two sets of flags.",32,[[["entryflags",3]],["entryflags",3]]],[11,"sub","sunrise_bootstrap::paging","Returns the set difference of the two sets of flags.",18,[[["entryflags",3]],["entryflags",3]]],[11,"eq","sunrise_bootstrap::gdt::i386","",12,[[["privilegelevel",4]]]],[11,"eq","sunrise_bootstrap::address","",14,[[["physicaladdress",3]]]],[11,"ne","","",14,[[["physicaladdress",3]]]],[11,"eq","","",15,[[["virtualaddress",3]]]],[11,"ne","","",15,[[["virtualaddress",3]]]],[11,"eq","sunrise_bootstrap::paging::entry","",20,[[["entryflags",3]]]],[11,"ne","","",20,[[["entryflags",3]]]],[11,"eq","sunrise_bootstrap::paging::table::entry","",32,[[["entryflags",3]]]],[11,"ne","","",32,[[["entryflags",3]]]],[11,"eq","sunrise_bootstrap::paging","",18,[[["entryflags",3]]]],[11,"ne","","",18,[[["entryflags",3]]]],[11,"cmp","sunrise_bootstrap::address","",14,[[["physicaladdress",3]],["ordering",4]]],[11,"cmp","","",15,[[["virtualaddress",3]],["ordering",4]]],[11,"cmp","sunrise_bootstrap::paging::entry","",20,[[["entryflags",3]],["ordering",4]]],[11,"cmp","sunrise_bootstrap::paging::table::entry","",32,[[["entryflags",3]],["ordering",4]]],[11,"cmp","sunrise_bootstrap::paging","",18,[[["entryflags",3]],["ordering",4]]],[11,"partial_cmp","sunrise_bootstrap::address","",14,[[["physicaladdress",3]],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[["physicaladdress",3]]]],[11,"le","","",14,[[["physicaladdress",3]]]],[11,"gt","","",14,[[["physicaladdress",3]]]],[11,"ge","","",14,[[["physicaladdress",3]]]],[11,"partial_cmp","","",15,[[["virtualaddress",3]],[["option",4],["ordering",4]]]],[11,"lt","","",15,[[["virtualaddress",3]]]],[11,"le","","",15,[[["virtualaddress",3]]]],[11,"gt","","",15,[[["virtualaddress",3]]]],[11,"ge","","",15,[[["virtualaddress",3]]]],[11,"partial_cmp","sunrise_bootstrap::paging::entry","",20,[[["entryflags",3]],[["option",4],["ordering",4]]]],[11,"lt","","",20,[[["entryflags",3]]]],[11,"le","","",20,[[["entryflags",3]]]],[11,"gt","","",20,[[["entryflags",3]]]],[11,"ge","","",20,[[["entryflags",3]]]],[11,"partial_cmp","sunrise_bootstrap::paging::table::entry","",32,[[["entryflags",3]],[["option",4],["ordering",4]]]],[11,"lt","","",32,[[["entryflags",3]]]],[11,"le","","",32,[[["entryflags",3]]]],[11,"gt","","",32,[[["entryflags",3]]]],[11,"ge","","",32,[[["entryflags",3]]]],[11,"partial_cmp","sunrise_bootstrap::paging","",18,[[["entryflags",3]],[["option",4],["ordering",4]]]],[11,"lt","","",18,[[["entryflags",3]]]],[11,"le","","",18,[[["entryflags",3]]]],[11,"gt","","",18,[[["entryflags",3]]]],[11,"ge","","",18,[[["entryflags",3]]]],[11,"add","sunrise_bootstrap::address","Adding a length to an address gives another address",15,[[],["virtualaddress",3]]],[11,"add","","Adding a length to an address gives another address",14,[[],["physicaladdress",3]]],[11,"add_assign","","Adding a length to an address gives another address",15,[[]]],[11,"add_assign","","Adding a length to an address gives another address",14,[[]]],[11,"sub_assign","","Subtracting a length from an address gives another address",15,[[]]],[11,"sub_assign","","Subtracting a length from an address gives another address",14,[[]]],[11,"sub_assign","sunrise_bootstrap::paging::entry","Disables all flags enabled in the set.",20,[[["entryflags",3]]]],[11,"sub_assign","sunrise_bootstrap::paging::table::entry","Disables all flags enabled in the set.",32,[[["entryflags",3]]]],[11,"sub_assign","sunrise_bootstrap::paging","Disables all flags enabled in the set.",18,[[["entryflags",3]]]],[11,"not","sunrise_bootstrap::paging::entry","Returns the complement of this set of flags.",20,[[],["entryflags",3]]],[11,"not","sunrise_bootstrap::paging::table::entry","Returns the complement of this set of flags.",32,[[],["entryflags",3]]],[11,"not","sunrise_bootstrap::paging","Returns the complement of this set of flags.",18,[[],["entryflags",3]]],[11,"bitand","sunrise_bootstrap::paging::entry","Returns the intersection between the two sets of flags.",20,[[["entryflags",3]],["entryflags",3]]],[11,"bitand","sunrise_bootstrap::paging::table::entry","Returns the intersection between the two sets of flags.",32,[[["entryflags",3]],["entryflags",3]]],[11,"bitand","sunrise_bootstrap::paging","Returns the intersection between the two sets of flags.",18,[[["entryflags",3]],["entryflags",3]]],[11,"bitor","sunrise_bootstrap::paging::entry","Returns the union of the two sets of flags.",20,[[["entryflags",3]],["entryflags",3]]],[11,"bitor","sunrise_bootstrap::paging::table::entry","Returns the union of the two sets of flags.",32,[[["entryflags",3]],["entryflags",3]]],[11,"bitor","sunrise_bootstrap::paging","Returns the union of the two sets of flags.",18,[[["entryflags",3]],["entryflags",3]]],[11,"bitxor","sunrise_bootstrap::paging::entry","Returns the left flags, but with all the right flags…",20,[[["entryflags",3]],["entryflags",3]]],[11,"bitxor","sunrise_bootstrap::paging::table::entry","Returns the left flags, but with all the right flags…",32,[[["entryflags",3]],["entryflags",3]]],[11,"bitxor","sunrise_bootstrap::paging","Returns the left flags, but with all the right flags…",18,[[["entryflags",3]],["entryflags",3]]],[11,"bitand_assign","sunrise_bootstrap::paging::entry","Disables all flags disabled in the set.",20,[[["entryflags",3]]]],[11,"bitand_assign","sunrise_bootstrap::paging::table::entry","Disables all flags disabled in the set.",32,[[["entryflags",3]]]],[11,"bitand_assign","sunrise_bootstrap::paging","Disables all flags disabled in the set.",18,[[["entryflags",3]]]],[11,"bitor_assign","sunrise_bootstrap::paging::entry","Adds the set of flags.",20,[[["entryflags",3]]]],[11,"bitor_assign","sunrise_bootstrap::paging::table::entry","Adds the set of flags.",32,[[["entryflags",3]]]],[11,"bitor_assign","sunrise_bootstrap::paging","Adds the set of flags.",18,[[["entryflags",3]]]],[11,"bitxor_assign","sunrise_bootstrap::paging::entry","Toggles the set of flags.",20,[[["entryflags",3]]]],[11,"bitxor_assign","sunrise_bootstrap::paging::table::entry","Toggles the set of flags.",32,[[["entryflags",3]]]],[11,"bitxor_assign","sunrise_bootstrap::paging","Toggles the set of flags.",18,[[["entryflags",3]]]],[11,"drop","sunrise_bootstrap::paging::table","",27,[[]]],[11,"drop","","",28,[[]]],[11,"drop","","",29,[[]]],[11,"drop","sunrise_bootstrap::frame_alloc","",45,[[]]],[11,"index","sunrise_bootstrap::paging::table","",24,[[],["entry",3]]],[11,"index","","",23,[[],["entry",3]]],[11,"index","","",25,[[],["entry",3]]],[11,"index","","",26,[[],["entry",3]]],[11,"index","","",28,[[],["entry",3]]],[11,"index","","",29,[[],["entry",3]]],[11,"index","","",30,[[],["entry",3]]],[11,"index","","",31,[[],["entry",3]]],[11,"index_mut","","",24,[[],["entry",3]]],[11,"index_mut","","",23,[[],["entry",3]]],[11,"index_mut","","",25,[[],["entry",3]]],[11,"index_mut","","",26,[[],["entry",3]]],[11,"index_mut","","",28,[[],["entry",3]]],[11,"index_mut","","",29,[[],["entry",3]]],[11,"index_mut","","",30,[[],["entry",3]]],[11,"index_mut","","",31,[[],["entry",3]]],[11,"hash","sunrise_bootstrap::address","",14,[[]]],[11,"hash","","",15,[[]]],[11,"hash","sunrise_bootstrap::paging::entry","",20,[[]]],[11,"hash","sunrise_bootstrap::paging::table::entry","",32,[[]]],[11,"hash","sunrise_bootstrap::paging","",18,[[]]],[11,"extend","sunrise_bootstrap::paging::entry","",20,[[["intoiterator",8]]]],[11,"extend","sunrise_bootstrap::paging::table::entry","",32,[[["intoiterator",8]]]],[11,"extend","sunrise_bootstrap::paging","",18,[[["intoiterator",8]]]],[11,"from_iter","sunrise_bootstrap::paging::entry","",20,[[["intoiterator",8]],["entryflags",3]]],[11,"from_iter","sunrise_bootstrap::paging::table::entry","",32,[[["intoiterator",8]],["entryflags",3]]],[11,"from_iter","sunrise_bootstrap::paging","",18,[[["intoiterator",8]],["entryflags",3]]],[11,"write_str","sunrise_bootstrap::bootstrap_logging","Writes a string to COM1.",48,[[],[["result",4],["error",3]]]],[11,"fmt","sunrise_bootstrap::paging::entry","",20,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging::table::entry","",32,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging","",18,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging::entry","",20,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging::table::entry","",32,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging","",18,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::address","",14,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",15,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","sunrise_bootstrap::paging::entry","",20,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging::table::entry","",32,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging","",18,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging::entry","",20,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging::table::entry","",32,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_bootstrap::paging","",18,[[["formatter",3]],["result",6]]],[11,"clone","sunrise_bootstrap::gdt::i386","",12,[[],["privilegelevel",4]]],[11,"clone","","",11,[[],["tssstruct",3]]],[11,"clone","sunrise_bootstrap::gdt","",9,[[],["systemdescriptortypes",4]]],[11,"clone","","",8,[[],["descriptortableentry",3]]],[11,"clone","sunrise_bootstrap::address","",14,[[],["physicaladdress",3]]],[11,"clone","","",15,[[],["virtualaddress",3]]],[11,"clone","sunrise_bootstrap::paging::entry","",20,[[],["entryflags",3]]],[11,"clone","","",21,[[],["entry",3]]],[11,"clone","sunrise_bootstrap::paging::table::entry","",32,[[],["entryflags",3]]],[11,"clone","","",33,[[],["entry",3]]],[11,"clone","sunrise_bootstrap::paging","",18,[[],["entryflags",3]]],[11,"default","sunrise_bootstrap::gdt::i386","",11,[[],["tssstruct",3]]],[11,"default","sunrise_bootstrap::paging","",16,[[],["inactivepagetables",3]]],[11,"initialize","sunrise_bootstrap::gdt","",5,[[]]],[11,"initialize","","",6,[[]]]],"p":[[3,"AlignedStack"],[3,"EndTag"],[3,"FramebufferTag"],[3,"ModuleAlignmentTag"],[3,"MultiBootHeader"],[3,"MAIN_TASK"],[3,"FAULT_TASK"],[3,"DescriptorTable"],[3,"DescriptorTableEntry"],[4,"SystemDescriptorTypes"],[3,"SegmentSelector"],[3,"TssStruct"],[4,"PrivilegeLevel"],[3,"DescriptorTablePointer"],[3,"PhysicalAddress"],[3,"VirtualAddress"],[3,"InactivePageTables"],[3,"PagingOffPageSet"],[3,"EntryFlags"],[4,"MappingType"],[3,"EntryFlags"],[3,"Entry"],[4,"PageState"],[3,"PageTable"],[3,"PageDirectory"],[3,"ActivePageDirectory"],[3,"ActivePageTable"],[3,"SmartHierarchicalTable"],[3,"InactivePageDirectory"],[3,"InactivePageTable"],[3,"PagingOffDirectory"],[3,"PagingOffTable"],[3,"EntryFlags"],[3,"Entry"],[4,"PageState"],[8,"I386PageTablesSet"],[8,"HierarchicalTable"],[8,"PageTableTrait"],[8,"PageDirectoryTrait"],[8,"PageTablesSet"],[8,"Flusher"],[8,"VirtualSpaceLand"],[3,"KernelLand"],[3,"UserLand"],[3,"AllocatorBitmap"],[3,"Frame"],[3,"FrameAllocator"],[3,"BootstrapStack"],[3,"Serial"],[3,"ActivePageTables"],[3,"TlbFlush"],[3,"NoFlush"]]},\
"sunrise_fs":{"doc":"Filesystem sysmodule","i":[[5,"main","sunrise_fs","",null,[[]]],[0,"detail","","Detail module",null,null],[3,"PartitionManager","sunrise_fs::detail","Manage partition of a IStorage.",null,null],[12,"inner","","The IStorage used.",0,null],[3,"PartitionIterator","","Iterator over GPT partitions",null,null],[12,"inner","","The IStorage used.",1,null],[12,"partition_table_start","","Partition sector start.",1,null],[12,"partition_entry_count","","Partition count.",1,null],[12,"partition_entry_size","","Partition entry size",1,null],[12,"position","","Current position of the iterator.",1,null],[12,"block_at_free_entry","","Stop the iterator at free entries.",1,null],[3,"FileSystemProxy","","Entry point of the file system interface.",null,null],[0,"driver","","Contains driver implementations of file system.",null,null],[3,"DriverManager","sunrise_fs::detail::driver","Instance handling drivers registration and usage.",null,null],[12,"registry","","The registry of the drivers availaible.",2,null],[12,"drives","","The drives actually opened.",2,null],[12,"partitions","","The partitions opened in drives.",2,null],[12,"ahci_interface","","AHCI IPC interface.",2,null],[3,"DRIVER_MANAGER","","",null,null],[12,"__private_field","","",3,null],[3,"AhciDiskStorage","","A wrapper to a ahci IDisk.",null,null],[12,"inner","","The inner IDisk.",4,null],[0,"fat","","FAT driver implementation layer",null,null],[3,"FATDriver","sunrise_fs::detail::driver::fat","A FAT driver.",null,null],[0,"directory","","FAT filesystem implementation of DirectoryOperations",null,null],[3,"DirectoryFilterPredicate","sunrise_fs::detail::driver::fat::directory","Predicate helper used to filter directory entries.",null,null],[3,"DirectoryInterface","","A libfat directory reader implementing…",null,null],[12,"base_path","","The opened directory path. Used to get the complete path…",5,null],[12,"inner_fs","","libfat filesystem interface.",5,null],[12,"internal_iter","","The iterator used to iter over libfat\'s directory entries.",5,null],[12,"filter_fn","","The filter required by the user.",5,null],[12,"entry_count","","The number of entries in the directory after `filter_fn`.",5,null],[11,"all","","Accept all entries except \\\".\\\" & \\\"..\\\".",6,[[["fatdirectoryentry",3]]]],[11,"dirs","","Only accept directory entries.",6,[[["fatdirectoryentry",3]]]],[11,"files","","Only accept file entries.",6,[[["fatdirectoryentry",3]]]],[11,"new","","Create a new DirectoryInterface.",5,[[["arraystring",3],["arc",3],["fatdirectoryentryiterator",3],["mutex",3]]]],[11,"convert_entry","","convert libfat\'s DirectoryEntry to libfs\'s DirectoryEntry.",5,[[["arraystring",3],["fatdirectoryentry",3]],[["directoryentry",3],["libuserresult",6]]]],[0,"file","sunrise_fs::detail::driver::fat","FAT filesystem implementation of FileOperations",null,null],[3,"FileInterface","sunrise_fs::detail::driver::fat::file","A libfat file interface implementing `FileOperations`.",null,null],[12,"inner_fs","","libfat filesystem interface.",7,null],[12,"file_inner","","The libfat\'s directory entry of this file.",7,null],[12,"mode","","File mode flags.",7,null],[11,"new","","Create a new FileInterface.",7,[[["arc",3],["file",3],["mutex",3],["filemodeflags",3]]]],[0,"filesystem","sunrise_fs::detail::driver::fat","IFileSystem implementation using libfat.",null,null],[3,"FatFileSystem","sunrise_fs::detail::driver::fat::filesystem","A wrapper arround libfat `FatFileSystem` implementing…",null,null],[12,"inner","","libfat filesystem interface.",8,null],[11,"new","","Create a new FAT filesystem instance.",8,[[["fatfilesystem",3],["box",3]]]],[11,"from_storage","","Construct a FAT filesystem instance with an IStorage.",8,[[["storagedevice",8],["box",3]],["libuserresult",6]]],[0,"error","sunrise_fs::detail::driver::fat","Error utils for the libuser <=> libfat",null,null],[5,"from_driver","sunrise_fs::detail::driver::fat::error","Convert a FatError to a libuser Error",null,[[["faterror",4]],["error",4]]],[6,"PartitionHashMap","sunrise_fs::detail::driver","A type to let clippy slide over it.",null,null],[6,"BoxedIStorage","","A boxed IStorage using the proper Error type.",null,null],[11,"register_driver","","Register a new driver",2,[[["box",3],["filesystemdriver",8]]]],[11,"add_opened_drive","","Add a new drive to the open hashmap.",2,[[["arc",3],["diskid",6],["mutex",3]]]],[11,"init_drives","","Do the disk init using AHCI",2,[[],["libuserresult",6]]],[11,"open_disk_storage","","Open a AHCI disk as a IStorage.",2,[[["diskid",6]],[["arc",3],["libuserresult",6]]]],[11,"get_disks_count","","Get the count of disks availaible.",2,[[]]],[11,"construct_filesystem_from_disk_partition","","Open an instance of a filesystem.",2,[[["partitionstorage",3],["diskid",6],["partitionid",6]],[["arc",3],["libuserresult",6]]]],[11,"format_disk_partition","","Format a partition storage to a given filesystem.",2,[[["filesystemtype",3],["partitionstorage",3]],["libuserresult",6]]],[11,"new","","Create a new AhciDiskStorage.",4,[[["idiskproxy",3]]]],[0,"gpt","sunrise_fs::detail","GPT definition module.",null,null],[3,"RawUUID","sunrise_fs::detail::gpt","A raw uuid representation.",null,null],[12,"d1","","Low part.",9,null],[12,"d2","","Mid part.",9,null],[12,"d3","","High part and version.",9,null],[12,"d4","","Node.",9,null],[3,"GPTHeader","","The header of a GPT table.",null,null],[12,"signature","","Signature of a GPT header.",10,null],[12,"revision","","GPT revision.",10,null],[12,"header_size","","Header size.",10,null],[12,"crc32","","CRC over the header.",10,null],[12,"reserved","","Reserved field.",10,null],[12,"current_lba","","The LBA of this header.",10,null],[12,"backup_lba","","The LBA of the backup header.",10,null],[12,"first_usable","","The first usable LBA. (partition table entries)",10,null],[12,"last_usable","","The last usable LBA.",10,null],[12,"disk_guid","","The GUID of this disk.",10,null],[12,"partition_table_start","","The LBA of the first partition entry.",10,null],[12,"partition_entry_count","","The count of partition entries.",10,null],[12,"partition_entry_size","","The size of a partition entry.",10,null],[12,"partition_table_crc32","","The CRC over all partition entries.",10,null],[3,"GPTPartitionEntry","","A GPT partition entry.",null,null],[12,"partition_type","","Partition type GUID.",11,null],[12,"unique_id","","Partition GUID.",11,null],[12,"first_lba","","First LBA of the partition.",11,null],[12,"last_lba","","Last LBA of the partition (inclusive).",11,null],[12,"attribute","","Attribute flags.",11,null],[12,"partition_name","","Partition name in UTF16LE.",11,null],[11,"from_fields","","Create a RawUUID from raw parts",9,[[]]],[11,"to_uuid","","Convert to a UUID instance.",9,[[],["uuid",3]]],[11,"from_uuid","","Convert a UUID to a RawUUID.",9,[[["uuid",3]]]],[11,"from_slice_le","","Create a RawUUID from a little endian slice of bytes.",9,[[]]],[11,"to_bytes_le","","Convert to a little endian byte array.",9,[[]]],[11,"set_partition_type","","Set the partition type GUID.",11,[[["uuid",3]]]],[11,"get_partition_type","","Get the partition type GUID.",11,[[],["uuid",3]]],[11,"set_unique_id","","Set the unique partition GUID.",11,[[["uuid",3]]]],[11,"get_unique_id","","Get the unique partition GUID.",11,[[],["uuid",3]]],[11,"set_name","","Set the name of the partition.",11,[[]]],[11,"from_bytes","","Create a GPTPartitionEntry from bytes.",11,[[]]],[11,"read","","Read the content of a raw array into a GPTPartitionEntry.",11,[[]]],[11,"write","","Conver the structure data to a raw array.",11,[[]]],[18,"MAGIC","","The magic of a GPT header (\\\"EFI PART\\\")",10,null],[11,"from_storage_device","","Read the GPT header from the disk",10,[[["istorage",8]],["libuserresult",6]]],[11,"from_bytes","","Create a GPTHeader from a raw array.",10,[[]]],[11,"read","","Read the content of a raw array into a GPTHeader.",10,[[]]],[11,"write","","Conver the structure data to a raw array.",10,[[]]],[11,"update_header_crc","","Update the CRC32 of the header.",10,[[]]],[11,"is_valid","","Check if the GPT Header looks valid.",10,[[]]],[11,"set_disk_guid","","Set the disk GUID.",10,[[["uuid",3]]]],[11,"get_disk_guid","","Get the disk GUID.",10,[[],["uuid",3]]],[0,"utils","sunrise_fs::detail","Utils of the detail module.",null,null],[5,"calculate_crc32","sunrise_fs::detail::utils","Compute the CRC32 of a given slice.",null,[[]]],[5,"lba_to_cls","","Convert a LBA to a CLS address.",null,[[]]],[17,"MBR_LEN","sunrise_fs::detail","Size of an MBR header.",null,null],[17,"MBR_LEN_U64","","Size of an MBR header in u64.",null,null],[17,"BLOCK_SIZE","","Size of a block.",null,null],[17,"BLOCK_SIZE_U64","","Size of a block in u64.",null,null],[11,"new","","Create a new partition manager.",0,[[["istorage",8]]]],[11,"is_valid","","Check if the partition table is valid.",0,[[]]],[11,"create_protective_mbr","","Create a protective MBR",0,[[],["libuserresult",6]]],[11,"initialize","","Initialize a IStorage partition table.",0,[[],["libuserresult",6]]],[11,"new","","Create a new partition iterator.",1,[[["istorage",8]],["libuserresult",6]]],[11,"open_disk_partition","","Open a disk partition filesystem. This may fail if no…",12,[[["diskid",6],["partitionid",6]],[["arc",3],["libuserresult",6]]]],[11,"open_disk_storage","","Open a disk as a block device. This may fail if no…",12,[[["diskid",6]],[["arc",3],["libuserresult",6]]]],[11,"get_disks_count","","Get the count of disks availaible.",12,[[],["libuserresult",6]]],[11,"format_disk_partition","","Format a disk partition to the given filesystem type.",12,[[["diskid",6],["filesystemtype",3],["partitionid",6]],["libuserresult",6]]],[11,"initialize_disk","","Initialize a disk partition table",12,[[["diskid",6]],["libuserresult",6]]],[0,"interface","sunrise_fs","Interface module This module contains trait that are used…",null,null],[0,"driver","sunrise_fs::interface","Driver interfaces Allows to detect and select filesystem…",null,null],[8,"FileSystemDriver","sunrise_fs::interface::driver","Driver instance.",null,null],[10,"construct","","Construct a new filesystem instance if the driver…",13,[[["storagedevice",8],["box",3]],[["libuserresult",6],["box",3]]]],[10,"probe","","Proble the detected filesystem on the given partition.",13,[[["storagedevice",8]],[["option",4],["filesystemtype",3]]]],[10,"is_supported","","Check if this driver support the given filesystem type.",13,[[["filesystemtype",3]]]],[10,"format","","Format a given storage to hold a filesystem supported by…",13,[[["storagedevice",8],["filesystemtype",3],["box",3]],["libuserresult",6]]],[0,"filesystem","sunrise_fs::interface","Interface to manipulate filesystem",null,null],[3,"FileModeFlags","sunrise_fs::interface::filesystem","Flags indicating the way a file should be open.",null,null],[12,"bits","","",14,null],[3,"DirFilterFlags","","Flags indicating the filters when walking a directory.",null,null],[12,"bits","","",15,null],[5,"convert_path","","Import a UTF8 raw path to a slice of str",null,[[],["libuserresult",6]]],[17,"PATH_LEN","","Represent the max path size (in bytes) supported.",null,null],[8,"FileOperations","","Represent the operation on a file.",null,null],[10,"read","","Read the content of a file at a given `offset` in `buf`.",16,[[],["libuserresult",6]]],[10,"write","","Write the content given `buf` at the given `offset` in the…",16,[[],["libuserresult",6]]],[10,"flush","","Flush any data not written on the filesystem.",16,[[],["libuserresult",6]]],[10,"set_len","","Resize the file with the given `size`. If the file isn\'t…",16,[[],["libuserresult",6]]],[10,"get_len","","Return the current file size.",16,[[],["libuserresult",6]]],[8,"DirectoryOperations","","Represent the operation on a directory.",null,null],[10,"read","","Read the next directory entries and return the number of…",17,[[],["libuserresult",6]]],[10,"entry_count","","Return the count of entries in the directory.",17,[[],["libuserresult",6]]],[8,"FileSystemOperations","","Represent the operation on a filesystem.",null,null],[10,"create_file","","Create a file with a given `size` at the specified `path`.",18,[[],["libuserresult",6]]],[10,"create_directory","","Create a directory at the specified `path`.",18,[[],["libuserresult",6]]],[10,"rename_file","","Rename a file at `old_path` into `new_path`.",18,[[],["libuserresult",6]]],[10,"rename_directory","","Rename a directory at `old_path` into `new_path`",18,[[],["libuserresult",6]]],[10,"delete_file","","Delete a file at the specified `path`.",18,[[],["libuserresult",6]]],[10,"delete_directory","","Delete a directory at the specified `path`.",18,[[],["libuserresult",6]]],[10,"get_entry_type","","Get the informations about an entry on the filesystem.",18,[[],[["libuserresult",6],["directoryentrytype",3]]]],[10,"open_file","","Open a file at the specified `path` with the given `mode`…",18,[[["filemodeflags",3]],[["libuserresult",6],["box",3]]]],[10,"open_directory","","Open a directory at the specified `path` with the given…",18,[[["dirfilterflags",3]],[["box",3],["libuserresult",6]]]],[10,"get_free_space_size","","Get the total availaible space on the given filesystem.",18,[[],["libuserresult",6]]],[10,"get_total_space_size","","Get the total size of the filesystem.",18,[[],["libuserresult",6]]],[10,"get_file_timestamp_raw","","Return the attached timestamps on a resource at the given…",18,[[],[["filetimestampraw",3],["libuserresult",6]]]],[10,"get_filesystem_type","","Get the type of the filesystem",18,[[],["filesystemtype",3]]],[18,"READABLE","","",14,null],[18,"WRITABLE","","",14,null],[18,"APPENDABLE","","",14,null],[11,"empty","","Returns an empty set of flags",14,[[],["filemodeflags",3]]],[11,"all","","Returns the set containing all flags.",14,[[],["filemodeflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",14,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",14,[[],[["option",4],["filemodeflags",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",14,[[],["filemodeflags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",14,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",14,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",14,[[["filemodeflags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",14,[[["filemodeflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",14,[[["filemodeflags",3]]]],[11,"remove","","Removes the specified flags in-place.",14,[[["filemodeflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",14,[[["filemodeflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",14,[[["filemodeflags",3]]]],[18,"DIRECTORY","","Accept directories.",15,null],[18,"FILE","","Accept files.",15,null],[18,"ALL","","Do not filter anything.",15,null],[11,"empty","","Returns an empty set of flags",15,[[],["dirfilterflags",3]]],[11,"all","","Returns the set containing all flags.",15,[[],["dirfilterflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",15,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",15,[[],[["dirfilterflags",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",15,[[],["dirfilterflags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",15,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",15,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",15,[[["dirfilterflags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",15,[[["dirfilterflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",15,[[["dirfilterflags",3]]]],[11,"remove","","Removes the specified flags in-place.",15,[[["dirfilterflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",15,[[["dirfilterflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",15,[[["dirfilterflags",3]]]],[0,"storage","sunrise_fs::interface","Storage related interfaces Those interface allows to…",null,null],[3,"PartitionStorage","sunrise_fs::interface::storage","Wrapper over a IStorage that permit to access only a…",null,null],[12,"inner","","The backing IStorage implementation",19,null],[12,"partition_start","","The start of the partition.",19,null],[12,"partition_len","","The size of the partition.",19,null],[3,"FileStorage","","Wrapper around a [FileOperations] exposing a StorageDevice…",null,null],[12,"0","","",20,null],[8,"IStorage","","This is the interface for a raw device, usually a block…",null,null],[10,"set_size","","Set the total size of the storage in bytes.",21,[[],["libuserresult",6]]],[11,"new","","Create a new PartitionStorage",19,[[["arc",3],["mutex",3]]]],[11,"new","","Creates a new StorageDevice from the given FileOperations.",20,[[],["filestorage",3]]],[0,"ipc","sunrise_fs","IPC module This contains all IPC interfaces definition of…",null,null],[3,"Storage","sunrise_fs::ipc","This is the ipc interface for a raw device, usually a…",null,null],[12,"inner","","The detail implementation of this ipc interface.",22,null],[3,"FileSystemService","","Entry point of the file system interface.",null,null],[12,"inner","","The detail implementation of this ipc interface.",23,null],[3,"Pipe","","Represent a file in the IPC.",null,null],[12,"inner","","The detail implementation of this ipc interface.",24,null],[12,"cursor","","Position from which to read/write in the file. Every…",24,null],[3,"File","","Represent a file in the IPC.",null,null],[12,"inner","","The detail implementation of this ipc interface.",25,null],[3,"Directory","","Represent a file in the IPC.",null,null],[12,"inner","","The detail implementation of this ipc interface.",26,null],[3,"FileSystem","","Represent a filesystem in the IPC.",null,null],[12,"inner","","The detail implementation of this ipc interface.",27,null],[11,"new","","Create a new instance of IStorage using a boxed detail.",22,[[["arc",3],["mutex",3]]]],[11,"new","","Create a new pipe from the given file.",24,[[["fileoperations",8],["box",3]]]],[11,"new","","Create a new IFile instance from it\'s detail.",25,[[["fileoperations",8],["box",3]]]],[11,"new","","Create a new IFile instance from it\'s detail.",26,[[["box",3],["directoryoperations",8]]]],[11,"new","","Create a new FileSystem instance from it\'s detail.",27,[[["arc",3],["mutex",3]]]],[6,"LibUserResult","sunrise_fs","A libuser result.",null,null],[7,"HEADER","","",null,null],[7,"CAPABILITIES","","",null,null],[11,"from","sunrise_fs::detail","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into_iter","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"from","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"into","","",12,[[]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"size","","",12,[[]]],[11,"is_cool","","",12,[[]]],[11,"from_raw_parts","","",12,[[]]],[11,"from_raw_parts_mut","","",12,[[]]],[11,"from","sunrise_fs::detail::driver","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"size","","",3,[[]]],[11,"is_cool","","",3,[[]]],[11,"from_raw_parts","","",3,[[]]],[11,"from_raw_parts_mut","","",3,[[]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"size","","",4,[[]]],[11,"is_cool","","",4,[[]]],[11,"from_raw_parts","","",4,[[]]],[11,"from_raw_parts_mut","","",4,[[]]],[11,"from","sunrise_fs::detail::driver::fat","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"into","","",28,[[]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"size","","",28,[[]]],[11,"is_cool","","",28,[[]]],[11,"from_raw_parts","","",28,[[]]],[11,"from_raw_parts_mut","","",28,[[]]],[11,"from","sunrise_fs::detail::driver::fat::directory","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"size","","",6,[[]]],[11,"is_cool","","",6,[[]]],[11,"from_raw_parts","","",6,[[]]],[11,"from_raw_parts_mut","","",6,[[]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"size","","",5,[[]]],[11,"is_cool","","",5,[[]]],[11,"from_raw_parts","","",5,[[]]],[11,"from_raw_parts_mut","","",5,[[]]],[11,"from","sunrise_fs::detail::driver::fat::file","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"size","","",7,[[]]],[11,"is_cool","","",7,[[]]],[11,"from_raw_parts","","",7,[[]]],[11,"from_raw_parts_mut","","",7,[[]]],[11,"from","sunrise_fs::detail::driver::fat::filesystem","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"size","","",8,[[]]],[11,"is_cool","","",8,[[]]],[11,"from_raw_parts","","",8,[[]]],[11,"from_raw_parts_mut","","",8,[[]]],[11,"from","sunrise_fs::detail::gpt","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"size","","",9,[[]]],[11,"is_cool","","",9,[[]]],[11,"from_raw_parts","","",9,[[]]],[11,"from_raw_parts_mut","","",9,[[]]],[11,"from","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"size","","",10,[[]]],[11,"is_cool","","",10,[[]]],[11,"from_raw_parts","","",10,[[]]],[11,"from_raw_parts_mut","","",10,[[]]],[11,"from","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"size","","",11,[[]]],[11,"is_cool","","",11,[[]]],[11,"from_raw_parts","","",11,[[]]],[11,"from_raw_parts_mut","","",11,[[]]],[11,"from","sunrise_fs::interface::filesystem","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"into","","",14,[[]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"size","","",14,[[]]],[11,"is_cool","","",14,[[]]],[11,"from_raw_parts","","",14,[[]]],[11,"from_raw_parts_mut","","",14,[[]]],[11,"from","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"into","","",15,[[]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"size","","",15,[[]]],[11,"is_cool","","",15,[[]]],[11,"from_raw_parts","","",15,[[]]],[11,"from_raw_parts_mut","","",15,[[]]],[11,"from","sunrise_fs::interface::storage","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"into","","",19,[[]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"size","","",19,[[]]],[11,"is_cool","","",19,[[]]],[11,"from_raw_parts","","",19,[[]]],[11,"from_raw_parts_mut","","",19,[[]]],[11,"from","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"into","","",20,[[]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"size","","",20,[[]]],[11,"is_cool","","",20,[[]]],[11,"from_raw_parts","","",20,[[]]],[11,"from_raw_parts_mut","","",20,[[]]],[11,"from","sunrise_fs::ipc","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"into","","",22,[[]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"to_owned","","",22,[[]]],[11,"clone_into","","",22,[[]]],[11,"size","","",22,[[]]],[11,"is_cool","","",22,[[]]],[11,"from_raw_parts","","",22,[[]]],[11,"from_raw_parts_mut","","",22,[[]]],[11,"from","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"into","","",23,[[]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"to_owned","","",23,[[]]],[11,"clone_into","","",23,[[]]],[11,"size","","",23,[[]]],[11,"is_cool","","",23,[[]]],[11,"from_raw_parts","","",23,[[]]],[11,"from_raw_parts_mut","","",23,[[]]],[11,"from","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"into","","",24,[[]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"to_owned","","",24,[[]]],[11,"clone_into","","",24,[[]]],[11,"size","","",24,[[]]],[11,"is_cool","","",24,[[]]],[11,"from_raw_parts","","",24,[[]]],[11,"from_raw_parts_mut","","",24,[[]]],[11,"from","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"into","","",25,[[]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"to_owned","","",25,[[]]],[11,"clone_into","","",25,[[]]],[11,"size","","",25,[[]]],[11,"is_cool","","",25,[[]]],[11,"from_raw_parts","","",25,[[]]],[11,"from_raw_parts_mut","","",25,[[]]],[11,"from","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"into","","",26,[[]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"to_owned","","",26,[[]]],[11,"clone_into","","",26,[[]]],[11,"size","","",26,[[]]],[11,"is_cool","","",26,[[]]],[11,"from_raw_parts","","",26,[[]]],[11,"from_raw_parts_mut","","",26,[[]]],[11,"from","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"into","","",27,[[]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"to_owned","","",27,[[]]],[11,"clone_into","","",27,[[]]],[11,"size","","",27,[[]]],[11,"is_cool","","",27,[[]]],[11,"from_raw_parts","","",27,[[]]],[11,"from_raw_parts_mut","","",27,[[]]],[11,"construct","sunrise_fs::detail::driver::fat","",28,[[["storagedevice",8],["box",3]],[["libuserresult",6],["box",3]]]],[11,"probe","","",28,[[["storagedevice",8]],[["option",4],["filesystemtype",3]]]],[11,"is_supported","","",28,[[["filesystemtype",3]]]],[11,"format","","",28,[[["storagedevice",8],["filesystemtype",3],["box",3]],["libuserresult",6]]],[11,"read","sunrise_fs::detail::driver::fat::file","Read the content of a file at a given `offset` in `buf`.",7,[[],["libuserresult",6]]],[11,"write","","",7,[[],["libuserresult",6]]],[11,"flush","","",7,[[],["libuserresult",6]]],[11,"set_len","","",7,[[],["libuserresult",6]]],[11,"get_len","","",7,[[],["libuserresult",6]]],[11,"read","sunrise_fs::detail::driver::fat::directory","",5,[[],["libuserresult",6]]],[11,"entry_count","","",5,[[],["libuserresult",6]]],[11,"create_file","sunrise_fs::detail::driver::fat::filesystem","",8,[[],["libuserresult",6]]],[11,"create_directory","","",8,[[],["libuserresult",6]]],[11,"rename_file","","",8,[[],["libuserresult",6]]],[11,"rename_directory","","",8,[[],["libuserresult",6]]],[11,"delete_file","","",8,[[],["libuserresult",6]]],[11,"delete_directory","","",8,[[],["libuserresult",6]]],[11,"get_entry_type","","",8,[[],[["libuserresult",6],["directoryentrytype",3]]]],[11,"open_file","","",8,[[["filemodeflags",3]],[["libuserresult",6],["box",3]]]],[11,"open_directory","","",8,[[["dirfilterflags",3]],[["box",3],["libuserresult",6]]]],[11,"get_free_space_size","","",8,[[],["libuserresult",6]]],[11,"get_total_space_size","","",8,[[],["libuserresult",6]]],[11,"get_file_timestamp_raw","","",8,[[],[["filetimestampraw",3],["libuserresult",6]]]],[11,"get_filesystem_type","","",8,[[],["filesystemtype",3]]],[11,"set_size","sunrise_fs::interface::storage","",19,[[],["libuserresult",6]]],[11,"set_size","","Set the total size of the storage in bytes.",20,[[],["libuserresult",6]]],[11,"deref","sunrise_fs::detail::driver","",3,[[],["mutex",3]]],[11,"fmt","sunrise_fs::detail::driver::fat::directory","",5,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_fs::detail::driver::fat::file","",7,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_fs::detail::driver::fat::filesystem","",8,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_fs::detail::driver","",4,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_fs::detail::gpt","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_fs::detail","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_fs::interface::filesystem","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_fs::interface::storage","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_fs::ipc","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",23,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",26,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"sub","sunrise_fs::interface::filesystem","Returns the set difference of the two sets of flags.",14,[[["filemodeflags",3]],["filemodeflags",3]]],[11,"sub","","Returns the set difference of the two sets of flags.",15,[[["dirfilterflags",3]],["dirfilterflags",3]]],[11,"eq","sunrise_fs::detail::gpt","",9,[[["rawuuid",3]]]],[11,"ne","","",9,[[["rawuuid",3]]]],[11,"eq","","",10,[[["gptheader",3]]]],[11,"ne","","",10,[[["gptheader",3]]]],[11,"eq","sunrise_fs::interface::filesystem","",14,[[["filemodeflags",3]]]],[11,"ne","","",14,[[["filemodeflags",3]]]],[11,"eq","","",15,[[["dirfilterflags",3]]]],[11,"ne","","",15,[[["dirfilterflags",3]]]],[11,"cmp","","",14,[[["filemodeflags",3]],["ordering",4]]],[11,"cmp","","",15,[[["dirfilterflags",3]],["ordering",4]]],[11,"partial_cmp","","",14,[[["filemodeflags",3]],[["option",4],["ordering",4]]]],[11,"lt","","",14,[[["filemodeflags",3]]]],[11,"le","","",14,[[["filemodeflags",3]]]],[11,"gt","","",14,[[["filemodeflags",3]]]],[11,"ge","","",14,[[["filemodeflags",3]]]],[11,"partial_cmp","","",15,[[["dirfilterflags",3]],[["option",4],["ordering",4]]]],[11,"lt","","",15,[[["dirfilterflags",3]]]],[11,"le","","",15,[[["dirfilterflags",3]]]],[11,"gt","","",15,[[["dirfilterflags",3]]]],[11,"ge","","",15,[[["dirfilterflags",3]]]],[11,"sub_assign","","Disables all flags enabled in the set.",14,[[["filemodeflags",3]]]],[11,"sub_assign","","Disables all flags enabled in the set.",15,[[["dirfilterflags",3]]]],[11,"not","","Returns the complement of this set of flags.",14,[[],["filemodeflags",3]]],[11,"not","","Returns the complement of this set of flags.",15,[[],["dirfilterflags",3]]],[11,"bitand","","Returns the intersection between the two sets of flags.",14,[[["filemodeflags",3]],["filemodeflags",3]]],[11,"bitand","","Returns the intersection between the two sets of flags.",15,[[["dirfilterflags",3]],["dirfilterflags",3]]],[11,"bitor","","Returns the union of the two sets of flags.",14,[[["filemodeflags",3]],["filemodeflags",3]]],[11,"bitor","","Returns the union of the two sets of flags.",15,[[["dirfilterflags",3]],["dirfilterflags",3]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",14,[[["filemodeflags",3]],["filemodeflags",3]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",15,[[["dirfilterflags",3]],["dirfilterflags",3]]],[11,"bitand_assign","","Disables all flags disabled in the set.",14,[[["filemodeflags",3]]]],[11,"bitand_assign","","Disables all flags disabled in the set.",15,[[["dirfilterflags",3]]]],[11,"bitor_assign","","Adds the set of flags.",14,[[["filemodeflags",3]]]],[11,"bitor_assign","","Adds the set of flags.",15,[[["dirfilterflags",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",14,[[["filemodeflags",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",15,[[["dirfilterflags",3]]]],[11,"hash","","",14,[[]]],[11,"hash","","",15,[[]]],[11,"next","sunrise_fs::detail","",1,[[],["option",4]]],[11,"extend","sunrise_fs::interface::filesystem","",14,[[["intoiterator",8]]]],[11,"extend","","",15,[[["intoiterator",8]]]],[11,"from_iter","","",14,[[["intoiterator",8]],["filemodeflags",3]]],[11,"from_iter","","",15,[[["intoiterator",8]],["dirfilterflags",3]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"clone","sunrise_fs::detail::gpt","",9,[[],["rawuuid",3]]],[11,"clone","","",10,[[],["gptheader",3]]],[11,"clone","","",11,[[],["gptpartitionentry",3]]],[11,"clone","sunrise_fs::detail","",12,[[],["filesystemproxy",3]]],[11,"clone","sunrise_fs::interface::filesystem","",14,[[],["filemodeflags",3]]],[11,"clone","","",15,[[],["dirfilterflags",3]]],[11,"clone","sunrise_fs::ipc","",22,[[],["storage",3]]],[11,"clone","","",23,[[],["filesystemservice",3]]],[11,"clone","","",24,[[],["pipe",3]]],[11,"clone","","",25,[[],["file",3]]],[11,"clone","","",26,[[],["directory",3]]],[11,"clone","","",27,[[],["filesystem",3]]],[11,"default","sunrise_fs::detail::driver","",2,[[]]],[11,"default","sunrise_fs::detail::gpt","",9,[[]]],[11,"default","","",11,[[]]],[11,"default","","",10,[[]]],[11,"default","sunrise_fs::detail","",12,[[],["filesystemproxy",3]]],[11,"default","sunrise_fs::ipc","",23,[[],["filesystemservice",3]]],[11,"read","","",25,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"write","","",25,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"flush","","",25,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"set_size","","",25,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"get_size","","",25,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"read","","",26,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"get_entry_count","","",26,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"read","","",22,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"write","","",22,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"flush","","",22,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"set_size","","",22,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"get_size","","",22,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"create_file","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"delete_file","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"create_directory","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"delete_directory","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"rename_file","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"rename_directory","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"open_file","","",27,[[["filesystempath",6],["workqueue",3]],[["ifileproxy",3],["result",4],["error",4]]]],[11,"open_file_as_ipipe","","",27,[[["filesystempath",6],["workqueue",3]],[["ipipeproxy",3],["error",4],["result",4]]]],[11,"open_directory","","",27,[[["filesystempath",6],["workqueue",3]],[["error",4],["result",4],["idirectoryproxy",3]]]],[11,"get_free_space_size","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"get_total_space_size","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"get_file_timestamp_raw","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4],["filetimestampraw",3]]]],[11,"get_entry_type","","",27,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4],["directoryentrytype",3]]]],[11,"get_filesystem_type","","",27,[[["workqueue",3]],[["error",4],["result",4],["filesystemtype",3]]]],[11,"open_disk_partition","","",23,[[["partitionid",6],["diskid",6],["workqueue",3]],[["ifilesystemproxy",3],["error",4],["result",4]]]],[11,"open_disk_storage","","",23,[[["diskid",6],["workqueue",3]],[["istorageproxy",3],["result",4],["error",4]]]],[11,"get_disks_count","","",23,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"format_disk_partition","","",23,[[["diskid",6],["filesystemtype",3],["partitionid",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"initialize_disk","","",23,[[["diskid",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"read","","",24,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"write","","",24,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"initialize","sunrise_fs::detail::driver","",3,[[]]],[11,"read","sunrise_fs::interface::storage","",19,[[],[["result",4],["error",4]]]],[11,"write","","",19,[[],[["result",4],["error",4]]]],[11,"flush","","",19,[[],["libuserresult",6]]],[11,"len","","",19,[[],[["result",4],["error",4]]]],[11,"read","","Read the data at the given `offset` in the storage into a…",20,[[],["libuserresult",6]]],[11,"write","","Write the data from the given buffer at the given `offset`…",20,[[],["libuserresult",6]]],[11,"flush","","Writes every dirty data to the storage.",20,[[],["libuserresult",6]]],[11,"len","","",20,[[],[["result",4],["error",4]]]],[11,"read","sunrise_fs::detail::driver","Read blocks from the block device starting at the given…",4,[[["blockindex",3]],[["result",4],["error",4]]]],[11,"write","","Write blocks to the block device starting at the given…",4,[[["blockindex",3]],[["result",4],["error",4]]]],[11,"count","","Return the amount of blocks hold by the block device.",4,[[],[["blockcount",3],["error",4],["result",4]]]]],"p":[[3,"PartitionManager"],[3,"PartitionIterator"],[3,"DriverManager"],[3,"DRIVER_MANAGER"],[3,"AhciDiskStorage"],[3,"DirectoryInterface"],[3,"DirectoryFilterPredicate"],[3,"FileInterface"],[3,"FatFileSystem"],[3,"RawUUID"],[3,"GPTHeader"],[3,"GPTPartitionEntry"],[3,"FileSystemProxy"],[8,"FileSystemDriver"],[3,"FileModeFlags"],[3,"DirFilterFlags"],[8,"FileOperations"],[8,"DirectoryOperations"],[8,"FileSystemOperations"],[3,"PartitionStorage"],[3,"FileStorage"],[8,"IStorage"],[3,"Storage"],[3,"FileSystemService"],[3,"Pipe"],[3,"File"],[3,"Directory"],[3,"FileSystem"],[3,"FATDriver"]]},\
"sunrise_kernel":{"doc":"Sunrise kernel","i":[[5,"force_double_fault","sunrise_kernel","Forces a double fault by stack overflowing.",null,[[]]],[5,"main","","The kernel\'s `main`.",null,[[]]],[5,"start","","The entry point of our kernel.",null,[[]]],[5,"common_start","","CRT0 starts here.",null,[[]]],[0,"paging","","Paging.",null,null],[3,"InactiveHierarchy","sunrise_kernel::paging","A currently inactive hierarchy of directory and tables.",null,null],[12,"directory_physical_address","","The address we must put in cr3 to switch to these pages.",0,null],[3,"MappingAccessRights","","The flags of a mapping.",null,null],[12,"bits","","",1,null],[4,"PageState","","A hierarchical paging is composed of entries. An entry can…",null,null],[13,"Available","","Available, aka unused. Will page fault on use.",2,null],[13,"Guarded","","Guarded. Reserved and will cause a pagefault on use. Used…",2,null],[13,"Present","","Present. Used and has a backing physical address.",2,null],[5,"read_cr2","","Reads the value of cr2, retrieving the address that caused…",null,[[],["virtualaddress",3]]],[5,"read_cr3","","Reads the value of cr3, retrieving the current page…",null,[[],["physicaladdress",3]]],[0,"process_memory","","The management of a process\' memory",null,null],[3,"ProcessMemory","sunrise_kernel::paging::process_memory","The struct representing a process\' memory, stored in the…",null,null],[12,"userspace_bookkeping","","The list of mappings in this address space.",3,null],[12,"table_hierarchy","","The architecture-dependent paging hierarchy.",3,null],[12,"heap_base_address","","The start of the heap of this process. The heap is managed…",3,null],[4,"QueryMemory","","Because we do not store Available mappings internally, we…",null,null],[13,"Available","","The address fell in an available range.",4,null],[13,"Used","","The address fell in an existing mapping.",4,null],[4,"DynamicHierarchy","","Page tables selector.",null,null],[13,"Active","","The process\'s hierarchy is already the currently active one.",5,null],[13,"Inactive","","The process\'s hierarchy an inactive one.",5,null],[11,"get_hierarchy","","If these tables are the one currently in use, we return…",3,[[],["dynamichierarchy",4]]],[11,"map_phys_region_to","","Maps a single physical regions to a given virtual address.…",3,[[["physicalmemregion",3],["virtualaddress",3],["memorytype",4],["mappingaccessrights",3]],[["result",4],["kernelerror",4]]]],[11,"create_regular_mapping","","Allocates the physical regions, and maps them to specified…",3,[[["virtualaddress",3],["memorytype",4],["mappingaccessrights",3]],[["result",4],["kernelerror",4]]]],[11,"map_partial_shared_mapping","","Maps a previously created shared mapping to specified…",3,[[["virtualaddress",3],["spinrwlock",3],["memorytype",4],["arc",3],["mappingaccessrights",3]],[["result",4],["kernelerror",4]]]],[11,"guard","","Guards a range of addresses",3,[[["virtualaddress",3],["memorytype",4]],[["result",4],["kernelerror",4]]]],[11,"unmap","","Deletes a mapping in the page tables.",3,[[["virtualaddress",3]],[["mapping",3],["result",4],["kernelerror",4]]]],[11,"query_memory","","Reads the state of the mapping at a given address.",3,[[["virtualaddress",3]],["querymemory",4]]],[11,"expand_mapping","","Expand the Heap at `address` to `new_size`.",3,[[["virtualaddress",3]],[["result",4],["kernelerror",4]]]],[11,"find_available_space","","Finds a hole in virtual space at least `length` long.",3,[[],[["virtualaddress",3],["kernelerror",4],["result",4]]]],[11,"mirror_mapping","","Retrieves the mapping that `address` falls into, and…",3,[[["virtualaddress",3]],[["result",4],["crossprocessmapping",3],["kernelerror",4]]]],[11,"resize_heap","","Resize the heap of this process, just like a brk. It can…",3,[[],[["virtualaddress",3],["kernelerror",4],["result",4]]]],[11,"switch_to","","Switches to this process memory",3,[[]]],[11,"check_range","","Checks that the given memory range is homogenous (that is,…",3,[[["virtualaddress",3],["memoryattributes",3],["memorystate",3],["memorypermissions",3]],[["result",4],["kernelerror",4]]]],[0,"kernel_memory","sunrise_kernel::paging","The management of kernel memory",null,null],[3,"KernelMemory","sunrise_kernel::paging::kernel_memory","A struct that acts on KernelLand and RecursiveTablesLand.",null,null],[12,"tables","","The currently active page tables.",6,null],[5,"get_kernel_memory","","Locks the KERNEL_MEMORY",null,[[],[["kernelmemory",3],["spinlockirqguard",3]]]],[7,"KERNEL_MEMORY","","A mutex protecting the KernelMemory manager.",null,null],[11,"find_virtual_space_aligned","","Finds a hole in the virtual space at least \'length\' long,…",6,[[],[["virtualaddress",3],["kernelerror",4],["result",4]]]],[11,"find_virtual_space","","Finds a hole in the virtual space at least \'length\' long.",6,[[],[["virtualaddress",3],["kernelerror",4],["result",4]]]],[11,"map_phys_region_to","","Maps a single physical regions to a given virtual address.",6,[[["physicalmemregion",3],["virtualaddress",3],["mappingaccessrights",3]]]],[11,"map_phys_region","","Maps a single physical region anywhere.",6,[[["physicalmemregion",3],["mappingaccessrights",3]],["virtualaddress",3]]],[11,"map_phys_regions","","Maps a list of physical region anywhere.",6,[[["mappingaccessrights",3]],["virtualaddress",3]]],[11,"map_frame_iterator_to","","Maps a list of physical region yielded by an iterator.",6,[[["virtualaddress",3],["mappingaccessrights",3]]]],[11,"map_frame_iterator","","Maps a list of physical region yielded by the iterator.…",6,[[["mappingaccessrights",3]],["virtualaddress",3]]],[11,"get_page","","Allocates and maps a single page, choosing a spot in VMEM…",6,[[],["virtualaddress",3]]],[11,"map_allocate_to","","Allocates non-contiguous frames, and map them at the given…",6,[[["virtualaddress",3],["mappingaccessrights",3]]]],[11,"get_pages","","Allocates and maps the given length, chosing a spot in…",6,[[],["virtualaddress",3]]],[11,"guard","","Guards a range of addresses.",6,[[["virtualaddress",3]]]],[11,"mapping_state","","Reads the state of the mapping at a given address.",6,[[["virtualaddress",3]],[["pagestate",4],["physicaladdress",3]]]],[11,"unmap","","Deletes a mapping in the page tables. This functions…",6,[[["virtualaddress",3]]]],[11,"unmap_no_dealloc","","Deletes a mapping in the page tables, but does not free…",6,[[["virtualaddress",3]]]],[11,"reserve_kernel_land_frames","","Marks all frames mapped in KernelLand as reserve This is…",6,[[]]],[11,"get_hierarchy","","Safe access to the active page tables.",6,[[],["activehierarchy",3]]],[11,"dump_kernelland_state","","Prints the state of the KernelLand by parsing the page…",6,[[]]],[0,"lands","sunrise_kernel::paging","Module describing the split between the UserSpace and…",null,null],[3,"KernelLand","sunrise_kernel::paging::lands","The virtual memory belonging to kernel.",null,null],[3,"UserLand","","The virtual memory belonging to user.",null,null],[3,"RecursiveTablesLand","","The virtual memory pointing to active page tables by…",null,null],[8,"VirtualSpaceLand","","A trait describing the splitting of virtual memory between…",null,null],[18,"START","","The first address in this land.",7,null],[18,"END","","The last address in this land.",7,null],[11,"start_addr","","The first address in this land.",7,[[],["virtualaddress",3]]],[11,"end_addr","","The last address in this land.",7,[[],["virtualaddress",3]]],[11,"length","","The length of this land.",7,[[]]],[11,"contains_address","","Is the address contained in this Land ?",7,[[["virtualaddress",3]]]],[11,"contains_region","","Is the region fully contained in this Land ?",7,[[["virtualaddress",3]]]],[11,"check_contains_address","","Checks that a given address falls in this land, or return…",7,[[["virtualaddress",3]],[["result",4],["kernelerror",4]]]],[11,"check_contains_region","","Checks that a given region falls in this land, or return…",7,[[["virtualaddress",3]],[["result",4],["kernelerror",4]]]],[0,"mapping","sunrise_kernel::paging","Mapping",null,null],[3,"Mapping","sunrise_kernel::paging::mapping","A memory mapping. Stores the address, the length, and the…",null,null],[12,"address","","The first address of this mapping.",8,null],[12,"length","","The length of this mapping.",8,null],[12,"state","","The type of this mapping.",8,null],[12,"frames","","The frames this mapping is referencing.",8,null],[12,"offset","","Physical frame offset of this mapping,",8,null],[12,"flags","","The access rights of this mapping.",8,null],[4,"MappingFrames","","Frames associated with a [Mapping].",null,null],[13,"Shared","","The frames are Shared between multiple mappings.",9,null],[13,"Owned","","The frames are Owned by this mapping.",9,null],[13,"None","","This Mapping has no frames.",9,null],[11,"new","","Tries to construct a mapping.",8,[[["virtualaddress",3],["mappingframes",4],["memorytype",4],["mappingaccessrights",3]],[["mapping",3],["result",4],["kernelerror",4]]]],[11,"address","","Returns the address of this mapping.",8,[[],["virtualaddress",3]]],[11,"length","","Returns the address of this mapping.",8,[[]]],[11,"frames","","Returns the frames in this mapping.",8,[[],["mappingframes",4]]],[11,"frames_it","","Returns an iterator over the Physical Addresses mapped by…",8,[[]]],[11,"phys_offset","","Returns the offset in `frames` this mapping starts from.",8,[[]]],[11,"state","","Returns the [MemoryState] of this mapping.",8,[[],["memorystate",3]]],[11,"flags","","Returns the type of this mapping.",8,[[],["mappingaccessrights",3]]],[0,"cross_process","sunrise_kernel::paging","Cross Process Mapping",null,null],[3,"CrossProcessMapping","sunrise_kernel::paging::cross_process","A struct representing a UserLand mapping mirrored in…",null,null],[12,"kernel_address","","The KernelLand address it was remapped to. Has the desired…",10,null],[12,"len","","Length of the region that was requested to be remapped.…",10,null],[12,"mapping","","The frames this mapping covers.",10,null],[11,"mirror_mapping","","Creates an `CrossProcessMapping`.",10,[[["mapping",3]],[["result",4],["crossprocessmapping",3],["kernelerror",4]]]],[11,"addr","","The address of the region asked to be remapped.",10,[[],["virtualaddress",3]]],[11,"len","","The length of the region asked to be remapped.",10,[[]]],[0,"hierarchical_table","sunrise_kernel::paging","Arch-independent traits for architectures that implement…",null,null],[3,"NoFlush","sunrise_kernel::paging::hierarchical_table","Flusher that doesn\'t flush.",null,null],[3,"SmartHierarchicalTable","","This is just a wrapper for a pointer to a table. It…",null,null],[12,"0","","",11,null],[12,"1","","",11,null],[4,"PageState","","A hierarchical paging is composed of entries. An entry can…",null,null],[13,"Available","","Available, aka unused. Will page fault on use.",2,null],[13,"Guarded","","Guarded. Reserved and will cause a pagefault on use. Used…",2,null],[13,"Present","","Present. Used and has a backing physical address.",2,null],[8,"HierarchicalEntry","","A hierarchical paging is composed of entries. All entries…",null,null],[16,"EntryFlagsType","","An entry comports some flags. They are often represented…",12,null],[10,"is_unused","","Is the entry unused ?",12,[[]]],[10,"set_unused","","Clear the entry",12,[[],[["pagestate",4],["physicaladdress",3]]]],[10,"is_guard","","Is the entry a page guard ?",12,[[]]],[10,"flags","","Get the current entry flags",12,[[]]],[10,"pointed_frame","","Get the associated physical address, if available",12,[[],[["pagestate",4],["physicaladdress",3]]]],[10,"set","","Sets the entry",12,[[["physicaladdress",3]]]],[10,"set_guard","","Make this entry a page guard",12,[[]]],[8,"HierarchicalTable","","A hierarchical paging is composed of tables. All tables…",null,null],[16,"EntryType","","The Entry our table has",13,null],[16,"CacheFlusherType","","A Flusher that should be called on table modifications",13,null],[16,"ChildTableType","","If we\'re a parent table, the type of our child tables. If…",13,null],[10,"entries","","gets the raw array of entries",13,[[]]],[11,"zero","","zero out the whole table",13,[[]]],[11,"guard_all_entries","","Makes all entries guarded",13,[[]]],[11,"map_nth_entry","","Creates a mapping on the nth entry of a table",13,[[["physicaladdress",3]]]],[11,"guard_nth_entry","","Marks the nth entry as guard page",13,[[]]],[11,"unmap_nth_entry","","Marks the nth entry as guard page",13,[[]]],[10,"table_level","","Called to check if this table\'s entries should be treated…",13,[[]]],[11,"entry_vm_size","","the size an entry in this table spans in virtual memory.…",13,[[]]],[10,"get_child_table","","Gets a reference to a child page table.",13,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[10,"create_child_table","","Allocates a child page table, zero it and add an entry…",13,[[],["smarthierarchicaltable",3]]],[11,"get_child_table_or_create","","Gets the child page table at given index, or creates it if…",13,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[8,"PagingCacheFlusher","","Most implementations of paging have are accelerated with a…",null,null],[10,"flush_whole_cache","","Flushes the whole cache.",14,[[]]],[8,"TableHierarchy","","A trait operating on a whole hierarchy of tables.",null,null],[16,"TopLevelTableType","","The type of the top level table.",15,null],[10,"get_top_level_table","","Gets a reference to the top level table, either through…",15,[[],["smarthierarchicaltable",3]]],[11,"map_to_from_iterator","","Creates a mapping in the page tables with the given flags.",15,[[["virtualaddress",3],["mappingaccessrights",3]]]],[11,"guard","","Creates a span of guard pages",15,[[["virtualaddress",3]]]],[11,"unmap","","Unmaps a range of virtual address. On every frames mapped…",15,[[["virtualaddress",3]]]],[11,"for_every_entry","","Iters in the page tables, applying closure on every…",15,[[["virtualaddress",3]]]],[11,"find_available_virtual_space_aligned","","Finds a virtual space hole that is at least length long,…",15,[[["virtualaddress",3]],[["virtualaddress",3],["option",4]]]],[8,"InactiveHierarchyTrait","","A trait implemented by inactive table hierarchies.",null,null],[10,"new","","Creates a hierarchy. Allocates at least a top level…",16,[[]]],[10,"switch_to","","Switches to this hierarchy.",16,[[]]],[10,"copy_active_kernel_space","","Performs a shallow copy of the top level-directory section…",16,[[]]],[10,"is_currently_active","","Checks if this inactive hierarchy is actually the…",16,[[]]],[10,"from_currently_active","","Returns the currently active hierarchy as an inactive…",16,[[]]],[11,"unwrap","sunrise_kernel::paging","Move the value T out of the PageState if it is Present(T).",2,[[]]],[11,"map","","Maps a PageState to PageState by applying a function to a…",2,[[],["pagestate",4]]],[11,"as_option","","Turns the PageState into an Option, setting both Guarded…",2,[[],["option",4]]],[11,"new","sunrise_kernel::paging::hierarchical_table","Wraps the given pointer in a `SmartHierarchicalTable`.",11,[[],["smarthierarchicaltable",3]]],[0,"arch","sunrise_kernel::paging","Arch-specific implementations of paging",null,null],[0,"i386","sunrise_kernel::paging::arch","Paging implementation on i386",null,null],[5,"is_paging_on","sunrise_kernel::paging::arch::i386","Check if the paging is currently active.",null,[[]]],[5,"enable_paging","","Not used anymore, bootstrap\'s job",null,[[["physicaladdress",3]]]],[5,"flush_tlb","","Flush the Translation Lookaside Buffer…",null,[[]]],[5,"swap_cr3","","Changes the content of the cr3 register, and returns the…",null,[[["physicaladdress",3]],["physicaladdress",3]]],[5,"read_cr3","","Reads the value of cr3, retrieving the current page…",null,[[],["physicaladdress",3]]],[5,"read_cr2","","Reads the value of cr2, retrieving the address that caused…",null,[[],["virtualaddress",3]]],[0,"entry","","i386 page table entry",null,null],[3,"I386EntryFlags","sunrise_kernel::paging::arch::i386::entry","The flags of a table entry",null,null],[12,"bits","","",17,null],[3,"I386Entry","","An entry in a page table or page directory. An unused…",null,null],[12,"0","","",18,null],[17,"ENTRY_PHYS_ADDRESS_MASK","","The part of an entry that encodes the physical address.",null,null],[18,"PRESENT","","",17,null],[18,"WRITABLE","","",17,null],[18,"USER_ACCESSIBLE","","",17,null],[18,"WRITE_THROUGH","","",17,null],[18,"NO_CACHE","","",17,null],[18,"ACCESSED","","",17,null],[18,"DIRTY","","",17,null],[18,"HUGE_PAGE","","",17,null],[18,"GLOBAL","","",17,null],[18,"GUARD_PAGE","","",17,null],[18,"USER_DEFINED_2","","",17,null],[18,"USER_DEFINED_3","","",17,null],[11,"empty","","Returns an empty set of flags",17,[[],["i386entryflags",3]]],[11,"all","","Returns the set containing all flags.",17,[[],["i386entryflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",17,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",17,[[],[["option",4],["i386entryflags",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",17,[[],["i386entryflags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",17,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",17,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",17,[[["i386entryflags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",17,[[["i386entryflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",17,[[["i386entryflags",3]]]],[11,"remove","","Removes the specified flags in-place.",17,[[["i386entryflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",17,[[["i386entryflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",17,[[["i386entryflags",3]]]],[0,"table","sunrise_kernel::paging::arch::i386","i386 Page Tables hierarchy",null,null],[3,"Table","sunrise_kernel::paging::arch::i386::table","A page table or directory in memory.",null,null],[12,"entries","","The array of entries making up this table.",19,null],[3,"ActivePageTable","","A currently active page table.",null,null],[12,"0","","",20,null],[3,"ActivePageDirectory","","A currently active page directory.",null,null],[12,"0","","",21,null],[3,"ActiveHierarchy","","The currently active hierarchy of directory and tables.…",null,null],[3,"InactivePageTable","","A currently inactive page table.",null,null],[12,"0","","",22,null],[3,"InactivePageDirectory","","A currently inactive page directory.",null,null],[12,"0","","",23,null],[3,"InactiveHierarchy","","A currently inactive hierarchy of directory and tables.",null,null],[12,"directory_physical_address","","The address we must put in cr3 to switch to these pages.",0,null],[3,"TlbFlush","","When passing this struct the TLB will be flushed. Used by…",null,null],[11,"get_table_address","","reduce recursive mapping by one time to get further down…",21,[[],["pagestate",4]]],[0,"lands","sunrise_kernel::paging::arch::i386","i386 Virtual Memory Layout",null,null],[3,"KernelLand","sunrise_kernel::paging::arch::i386::lands","The virtual memory belonging to kernel.",null,null],[3,"UserLand","","The virtual memory belonging to user.",null,null],[3,"RecursiveTablesLand","","The virtual memory pointing to active page tables by…",null,null],[17,"DIRECTORY_RECURSIVE_ADDRESS","","When paging is on, accessing this address loops back to…",null,null],[17,"USERLAND_START_TABLE","","The index in page directory of the first table of UserLand.",null,null],[17,"USERLAND_END_TABLE","","The index in page directory of the last table of UserLand.",null,null],[17,"KERNELLAND_START_TABLE","","The index in page directory of the first table of…",null,null],[17,"KERNELLAND_END_TABLE","","The index in page directory of the last table of KernelLand.",null,null],[17,"PAGE_SIZE","sunrise_kernel::paging::arch::i386","The page size. Dictated by the MMU. In simple, elegant,…",null,null],[17,"ENTRY_COUNT","","The number of entries a page table has. On i386 a page…",null,null],[0,"bookkeeping","sunrise_kernel::paging","Bookkeeping of mappings in UserLand",null,null],[3,"UserspaceBookkeeping","sunrise_kernel::paging::bookkeeping","A bookkeeping is just a list of Mappings",null,null],[12,"mappings","","The list of mappings of this process.",24,null],[4,"QueryMemory","","Because we do not store Available mappings internally, we…",null,null],[13,"Available","","The address fell in an available range.",4,null],[13,"Used","","The address fell in an existing mapping.",4,null],[11,"mapping","sunrise_kernel::paging::process_memory","Returns a reference to the underlying mapping.",4,[[],["mapping",3]]],[11,"new","sunrise_kernel::paging::bookkeeping","Constructs a UserspaceBookkeeping",24,[[]]],[11,"mapping_at_or_following","","Returns the mapping `address` falls into, or if it is…",24,[[["virtualaddress",3]],[["option",4],["mapping",3]]]],[11,"mapping_at_or_preceding","","Returns the mapping `address` falls into, or if it is…",24,[[["virtualaddress",3]],[["option",4],["mapping",3]]]],[11,"mapping_at","","Returns the mapping `address` falls into.",24,[[["virtualaddress",3]],["querymemory",4]]],[11,"occupied_mapping_at","","Returns the mapping `address` falls into.",24,[[["virtualaddress",3]],[["result",4],["mapping",3],["kernelerror",4]]]],[11,"is_vacant","","Checks that a given range is unoccupied.",24,[[["virtualaddress",3]],[["result",4],["kernelerror",4]]]],[11,"check_vacant","","Asserts that a given range is unoccupied",24,[[["virtualaddress",3]],[["result",4],["kernelerror",4]]]],[11,"add_mapping","","Adds a mapping to the list of tracked mappings",24,[[["mapping",3]],[["result",4],["kernelerror",4]]]],[11,"remove_mapping","","Removes a mapping from the tracked mappings, and returns it.",24,[[["virtualaddress",3]],[["mapping",3],["result",4],["kernelerror",4]]]],[11,"remove_mapping_split","","Removes part of a mapping from the tracked mappings, and…",24,[[["virtualaddress",3]],[["mapping",3],["result",4],["kernelerror",4]]]],[11,"find_available_space","","Finds a hole in virtual space at least `length` long.",24,[[],[["virtualaddress",3],["kernelerror",4],["result",4]]]],[17,"PAGE_SIZE","sunrise_kernel::paging","The page size. Dictated by the MMU. In simple, elegant,…",null,null],[8,"InactiveHierarchyTrait","","A trait implemented by inactive table hierarchies.",null,null],[10,"new","","Creates a hierarchy. Allocates at least a top level…",16,[[]]],[10,"switch_to","","Switches to this hierarchy.",16,[[]]],[10,"copy_active_kernel_space","","Performs a shallow copy of the top level-directory section…",16,[[]]],[10,"is_currently_active","","Checks if this inactive hierarchy is actually the…",16,[[]]],[10,"from_currently_active","","Returns the currently active hierarchy as an inactive…",16,[[]]],[18,"READABLE","","Mapping is readable.",1,null],[18,"WRITABLE","","Mapping is writable.",1,null],[18,"EXECUTABLE","","Mapping is executable.",1,null],[18,"USER_ACCESSIBLE","","Mapping can be accessed from userland, with the same…",1,null],[11,"empty","","Returns an empty set of flags",1,[[],["mappingaccessrights",3]]],[11,"all","","Returns the set containing all flags.",1,[[],["mappingaccessrights",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",1,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",1,[[],[["option",4],["mappingaccessrights",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",1,[[],["mappingaccessrights",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",1,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",1,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",1,[[["mappingaccessrights",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",1,[[["mappingaccessrights",3]]]],[11,"insert","","Inserts the specified flags in-place.",1,[[["mappingaccessrights",3]]]],[11,"remove","","Removes the specified flags in-place.",1,[[["mappingaccessrights",3]]]],[11,"toggle","","Toggles the specified flags in-place.",1,[[["mappingaccessrights",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",1,[[["mappingaccessrights",3]]]],[11,"k_r","","Shorthand for READABLE",1,[[],["mappingaccessrights",3]]],[11,"k_w","","Shorthand for WRITABLE",1,[[],["mappingaccessrights",3]]],[11,"k_rw","","Shorthand for READABLE | WRITABLE",1,[[],["mappingaccessrights",3]]],[11,"k_rx","","Shorthand for READABLE | EXECUTABLE",1,[[],["mappingaccessrights",3]]],[11,"u_r","","Shorthand for USER_ACCESSIBLE | READABLE",1,[[],["mappingaccessrights",3]]],[11,"u_w","","Shorthand for USER_ACCESSIBLE | WRITABLE",1,[[],["mappingaccessrights",3]]],[11,"u_rw","","Shorthand for USER_ACCESSIBLE | WRITABLE",1,[[],["mappingaccessrights",3]]],[11,"u_rx","","Shorthand for USER_ACCESSIBLE | WRITABLE",1,[[],["mappingaccessrights",3]]],[0,"event","sunrise_kernel","The core event handling primitives of Sunrise.",null,null],[3,"Event","sunrise_kernel::event","The underlying shared object of a…",null,null],[12,"state","","The state determines whether the event is signaled or not.…",25,null],[12,"waiting_processes","","List of processes waiting on this IRQ. When this IRQ is…",25,null],[3,"ReadableEvent","","The readable part of an event. The user shall use this end…",null,null],[12,"parent","","Pointer to the shared event representation.",26,null],[3,"WritableEvent","","The writable part of an event. The user shall use this end…",null,null],[12,"parent","","Pointer to the shared event representation.",27,null],[3,"IRQEvent","","An event waiting for an IRQ.",null,null],[12,"state","","The global state of the IRQ this event is listening on.…",28,null],[12,"ack","","Acknowledgement counter for this IRQEvent instance. Each…",28,null],[3,"IRQState","","Global state of an IRQ.",null,null],[12,"irqnum","","The irq number this state represents. Only used for debug…",29,null],[12,"counter","","The number of time this IRQ was triggered from kernel boot.",29,null],[12,"waiting_processes","","List of processes waiting on this IRQ. When this IRQ is…",29,null],[5,"wait","","Waits for an event to occur on one of the given Waitable…",null,[[],[["result",4],["waitable",8],["userspaceerror",3]]]],[5,"new_pair","","Create a new pair of [WritableEvent]/[ReadableEvent].",null,[[]]],[5,"dispatch_event","","Signal the scheduler and waiters that an IRQ has been…",null,[[]]],[5,"wait_event","","Creates an IRQEvent waiting for the given IRQ number.",null,[[],["irqevent",3]]],[7,"IRQ_STATES","","Global state for all the IRQ handled by the IOAPIC.",null,null],[8,"Waitable","","A waitable item.",null,null],[10,"is_signaled","","Checks whether the Waitable was signalled.",30,[[]]],[10,"register","","Register the waitable with the scheduler.",30,[[]]],[11,"clear_signal","","Clears the signaled state.",26,[[],[["result",4],["kernelerror",4]]]],[11,"signal","","Signals the event, setting its state to signaled and…",27,[[]]],[11,"clear_signal","","Clears the signaled state.",27,[[],[["result",4],["kernelerror",4]]]],[11,"new","","Create a new IRQState for the given IRQ number, with the…",29,[[],["irqstate",3]]],[0,"error","sunrise_kernel","UserspaceError and KernelError",null,null],[3,"UserspaceError","sunrise_kernel::error","Kernel syscall error codes.",null,null],[12,"0","","",31,null],[4,"KernelError","","Kernel Error.",null,null],[13,"NotImplemented","","",32,null],[12,"msg","sunrise_kernel::error::KernelError","",33,null],[12,"backtrace","","",33,null],[13,"PhysicalMemoryExhaustion","sunrise_kernel::error","",32,null],[12,"backtrace","sunrise_kernel::error::KernelError","",34,null],[13,"VirtualMemoryExhaustion","sunrise_kernel::error","",32,null],[12,"backtrace","sunrise_kernel::error::KernelError","",35,null],[13,"InvalidAddress","sunrise_kernel::error","",32,null],[12,"address","sunrise_kernel::error::KernelError","",36,null],[12,"backtrace","","",36,null],[13,"InvalidSize","sunrise_kernel::error","",32,null],[12,"size","sunrise_kernel::error::KernelError","",37,null],[12,"backtrace","","",37,null],[13,"ProcessKilled","sunrise_kernel::error","",32,null],[12,"backtrace","sunrise_kernel::error::KernelError","",38,null],[13,"InvalidState","sunrise_kernel::error","",32,null],[12,"backtrace","sunrise_kernel::error::KernelError","",39,null],[13,"InvalidCombination","sunrise_kernel::error","",32,null],[12,"backtrace","sunrise_kernel::error::KernelError","",40,null],[13,"ExceedingMaximum","sunrise_kernel::error","",32,null],[12,"value","sunrise_kernel::error::KernelError","",41,null],[12,"maximum","","",41,null],[12,"backtrace","","",41,null],[13,"InvalidKernelCaps","sunrise_kernel::error","",32,null],[12,"kcap","sunrise_kernel::error::KernelError","",42,null],[12,"backtrace","","",42,null],[13,"IpcError","sunrise_kernel::error","",32,null],[12,"backtrace","sunrise_kernel::error::KernelError","",43,null],[13,"WrongMappingFramesForTy","sunrise_kernel::error","",32,null],[12,"ty","sunrise_kernel::error::KernelError","",44,null],[12,"backtrace","","",44,null],[13,"InvalidMemState","sunrise_kernel::error","",32,null],[12,"address","sunrise_kernel::error::KernelError","",45,null],[12,"ty","","",45,null],[12,"backtrace","","",45,null],[13,"ReservedValue","sunrise_kernel::error","",32,null],[12,"backtrace","sunrise_kernel::error::KernelError","",46,null],[0,"log_impl","sunrise_kernel","A simple log implementation based on env_logger",null,null],[3,"Logger","sunrise_kernel::log_impl","",null,null],[12,"filter","","",47,null],[5,"early_init","","Initializes the Logger in a heapless environment.",null,[[]]],[5,"init","","Reinitializes the logger using the cmdline. This requires…",null,[[]]],[0,"filter","","Filtering for log records.",null,null],[3,"Filter","sunrise_kernel::log_impl::filter","A log filter.",null,null],[12,"directives","","",48,null],[12,"filter","","",48,null],[3,"Builder","","A builder for a log filter.",null,null],[12,"directives","","",49,null],[12,"filter","","",49,null],[3,"Directive","","",null,null],[12,"name","","",50,null],[12,"level","","",50,null],[5,"parse_spec","","Parse a logging specification string (e.g:…",null,[[]]],[5,"enabled","","",null,[[["level",4]]]],[0,"inner","","",null,null],[3,"Filter","sunrise_kernel::log_impl::filter::inner","",null,null],[12,"inner","","",51,null],[11,"new","","",51,[[],[["string",3],["filter",3],["result",4]]]],[11,"is_match","","",51,[[]]],[11,"filter","sunrise_kernel::log_impl::filter","Returns the maximum `LevelFilter` that this filter…",48,[[],["levelfilter",4]]],[11,"matches","","Checks if this record matches the configured filter.",48,[[["record",3]]]],[11,"enabled","","Determines if a log message with the specified metadata…",48,[[["metadata",3]]]],[11,"new","","Initializes the filter builder with defaults.",49,[[],["builder",3]]],[11,"filter_module","","Initializes the filter builder from an environment. Adds a…",49,[[["levelfilter",4]]]],[11,"filter_level","","Adds a directive to the filter for all modules.",49,[[["levelfilter",4]]]],[11,"filter","","Adds a directive to the filter.",49,[[["option",4],["levelfilter",4]]]],[11,"parse","","Parses the directives string.",49,[[]]],[11,"build","","Build a log filter.",49,[[],["filter",3]]],[7,"LOGGER","sunrise_kernel::log_impl","",null,null],[0,"i386","sunrise_kernel","This crate is x86_64\'s little brother. It provides i386…",null,null],[3,"TssStruct","sunrise_kernel::i386","The Task State Segment (TSS) is a special data structure…",null,null],[12,"link","","",52,null],[12,"_reserved1","","",52,null],[12,"esp0","","",52,null],[12,"ss0","","",52,null],[12,"_reserved2","","",52,null],[12,"esp1","","",52,null],[12,"ss1","","",52,null],[12,"_reserved3","","",52,null],[12,"esp2","","",52,null],[12,"ss2","","",52,null],[12,"_reserved4","","",52,null],[12,"cr3","","",52,null],[12,"eip","","",52,null],[12,"eflags","","",52,null],[12,"eax","","",52,null],[12,"ecx","","",52,null],[12,"edx","","",52,null],[12,"ebx","","",52,null],[12,"esp","","",52,null],[12,"ebp","","",52,null],[12,"esi","","",52,null],[12,"edi","","",52,null],[12,"es","","",52,null],[12,"_reserved5","","",52,null],[12,"cs","","",52,null],[12,"_reserved6","","",52,null],[12,"ss","","",52,null],[12,"_reserved7","","",52,null],[12,"ds","","",52,null],[12,"_reserved8","","",52,null],[12,"fs","","",52,null],[12,"_reserved9","","",52,null],[12,"gs","","",52,null],[12,"_reserveda","","",52,null],[12,"ldt_selector","","",52,null],[12,"_reservedb","","",52,null],[12,"_reservedc","","",52,null],[12,"iopboffset","","",52,null],[4,"PrivilegeLevel","","Represents a protection ring level.",null,null],[13,"Ring0","","Privilege-level 0 (most privilege): This level is used by…",53,null],[13,"Ring1","","Privilege-level 1 (moderate privilege): This level is used…",53,null],[13,"Ring2","","Privilege-level 2 (moderate privilege): Like level 1, this…",53,null],[13,"Ring3","","Privilege-level 3 (least privilege): This level is used by…",53,null],[0,"acpi","","ACPI detection",null,null],[3,"MemoryHandler","sunrise_kernel::i386::acpi","ACPI Memory handler",null,null],[5,"get_acpi_information","","Get a reference to the ACPI information.",null,[[],["acpi",3]]],[5,"try_get_acpi_information","","Tries to get a pointer to the acpi information structure.",null,[[],[["acpi",3],["option",4]]]],[5,"parse_rsdp_tag","","Parse RSDP from multiboot2 a tag.",null,[[["memoryhandler",3]]]],[5,"init","","Parse ACPI tables and store them.",null,[[]]],[7,"ACPI_INFO","","Stores the ACPI data",null,null],[0,"registers","sunrise_kernel::i386","i386 registers reading",null,null],[5,"eip","sunrise_kernel::i386::registers","Gets the current $eip.",null,[[]]],[0,"eflags","","Processor state stored in the EFLAGS register.",null,null],[3,"EFlags","sunrise_kernel::i386::registers::eflags","The EFLAGS register.",null,null],[12,"bits","","",54,null],[5,"read","","Returns the current value of the EFLAGS register.",null,[[],["eflags",3]]],[5,"read_raw","","Returns the raw current value of the EFLAGS register.",null,[[]]],[5,"write","","Writes the EFLAGS register, preserves reserved bits.",null,[[["eflags",3]]]],[5,"write_raw","","Writes the EFLAGS register.",null,[[]]],[18,"ID","","Processor feature identification flag.",54,null],[18,"VIRTUAL_INTERRUPT_PENDING","","Indicates that an external, maskable interrupt is pending.",54,null],[18,"VIRTUAL_INTERRUPT","","Virtual image of the INTERRUPT_FLAG bit.",54,null],[18,"ALIGNMENT_CHECK","","Enable automatic alignment checking if CR0.AM is set. Only…",54,null],[18,"VIRTUAL_8086_MODE","","Enable the virtual-8086 mode.",54,null],[18,"RESUME_FLAG","","Allows to restart an instruction following an instrucion…",54,null],[18,"NESTED_TASK","","Used by `iret` in hardware task switch mode to determine…",54,null],[18,"IOPL_HIGH","","The high bit of the I/O Privilege Level field.",54,null],[18,"IOPL_LOW","","The low bit of the I/O Privilege Level field.",54,null],[18,"OVERFLOW_FLAG","","Set by hardware to indicate that the sign bit of the…",54,null],[18,"DIRECTION_FLAG","","Determines the order in which strings are processed.",54,null],[18,"INTERRUPT_FLAG","","Enable interrupts.",54,null],[18,"TRAP_FLAG","","Enable single-step mode for debugging.",54,null],[18,"SIGN_FLAG","","Set by hardware if last arithmetic operation resulted in a…",54,null],[18,"ZERO_FLAG","","Set by hardware if last arithmetic operation resulted in a…",54,null],[18,"AUXILIARY_CARRY_FLAG","","Set by hardware if last arithmetic operation generated a…",54,null],[18,"PARITY_FLAG","","Set by hardware if last result has an even number of 1…",54,null],[18,"CARRY_FLAG","","Set by hardware if last arithmetic operation generated a…",54,null],[11,"empty","","Returns an empty set of flags",54,[[],["eflags",3]]],[11,"all","","Returns the set containing all flags.",54,[[],["eflags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",54,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",54,[[],[["eflags",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",54,[[],["eflags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",54,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",54,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",54,[[["eflags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",54,[[["eflags",3]]]],[11,"insert","","Inserts the specified flags in-place.",54,[[["eflags",3]]]],[11,"remove","","Removes the specified flags in-place.",54,[[["eflags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",54,[[["eflags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",54,[[["eflags",3]]]],[0,"stack","sunrise_kernel::i386","Kernel stack",null,null],[3,"KernelStack","sunrise_kernel::i386::stack","A structure representing a kernel stack.",null,null],[12,"stack_address","","The aligned address at the beginning of the stack.",55,null],[3,"StackDumpSource","","The minimal information needed to perform a stack dump.",null,null],[12,"esp","","The initial top of the stack.",56,null],[12,"ebp","","The initial bottom of the first stack frame.",56,null],[12,"eip","","The initial pc.",56,null],[5,"dump_stack","","Dumps the stack from the given information, displaying it…",null,[[["option",4],["stackdumpsource",3]]]],[5,"dump_stack_from_slice","","Dumps a stack, displaying it in a frame-by-frame format.",null,[[["option",4]]]],[17,"STACK_SIZE","","The size of a kernel stack in pages, not accounting for…",null,null],[17,"STACK_SIZE_WITH_GUARD","","The size of a kernel stack in pages, with the page guard.",null,null],[17,"STACK_SIZE_WITH_GUARD_IN_BYTES","","The size of the kernel stack, with the page guard, as a…",null,null],[17,"STACK_ALIGNMENT","","The alignment of the stack.",null,null],[11,"allocate_stack","","Allocates the kernel stack of a process.",55,[[],[["kernelerror",4],["result",4],["kernelstack",3]]]],[11,"align_to_stack_bottom","","Aligns down a pointer to what would be the beginning of…",55,[[]]],[11,"get_current_stack_bottom","","Gets the bottom of the stack by `and`ing `$esp` with…",55,[[]]],[11,"get_current_stack","","Retrieves the current stack from `$esp`.",55,[[],["kernelstack",3]]],[18,"STACK_POISON_SIZE","","We keep 2 poison pointers for fake `saved ebp` and `saved…",55,null],[11,"create_poison_pointers","","Puts two poisons pointers at the base of the stack for the…",55,[[]]],[11,"get_stack_start","","Get the address of the beginning of usable stack.",55,[[]]],[11,"dump_current_stack","","Dumps the stack, displaying it in a frame-by-frame format.",55,[[["option",4]]]],[11,"new","","Creates a StackDumpSource from :",56,[[]]],[0,"multiboot","sunrise_kernel::i386","Multiboot Information",null,null],[5,"get_boot_information","sunrise_kernel::i386::multiboot","Get a pointer to the multiboot information structure.",null,[[],["bootinformation",3]]],[5,"try_get_boot_information","","Tries to get a pointer to the multiboot information…",null,[[],[["bootinformation",3],["option",4]]]],[5,"init","","Initializes the boot information module, allowing the…",null,[[["bootinformation",3]]]],[7,"BOOT_INFO","","Stores the address of the multiboot.",null,null],[0,"structures","sunrise_kernel::i386","Representations of various x86 specific structures and…",null,null],[0,"gdt","sunrise_kernel::i386::structures","Types for the Global Descriptor Table and segment selectors.",null,null],[3,"SegmentSelector","sunrise_kernel::i386::structures::gdt","Specifies which element to load into a segment from…",null,null],[12,"0","","",57,null],[11,"new","","Creates a new SegmentSelector",57,[[["privilegelevel",4]],["segmentselector",3]]],[11,"index","","Returns the GDT index.",57,[[]]],[11,"rpl","","Returns the requested privilege level.",57,[[],["privilegelevel",4]]],[11,"is_ldt","","If true, this descriptor is backed by the LDT. If false,…",57,[[]]],[0,"idt","sunrise_kernel::i386::structures","Provides types for the Interrupt Descriptor Table and its…",null,null],[3,"Idt","sunrise_kernel::i386::structures::idt","An Interrupt Descriptor Table with 256 entries.",null,null],[12,"divide_by_zero","","A divide by zero exception (`#DE`) occurs when the…",58,null],[12,"debug","","When the debug-exception mechanism is enabled, a `#DB`…",58,null],[12,"non_maskable_interrupt","","An non maskable interrupt exception (NMI) occurs as a…",58,null],[12,"breakpoint","","A breakpoint (`#BP`) exception occurs when an `INT3`…",58,null],[12,"overflow","","An overflow exception (`#OF`) occurs as a result of…",58,null],[12,"bound_range_exceeded","","A bound-range exception (`#BR`) exception can occur as a…",58,null],[12,"invalid_opcode","","An invalid opcode exception (`#UD`) occurs when an attempt…",58,null],[12,"device_not_available","","A device not available exception (`#NM`) occurs under any…",58,null],[12,"double_fault","","A double fault (`#DF`) exception can occur when a second…",58,null],[12,"coprocessor_segment_overrun","","This interrupt vector is reserved. It is for a…",58,null],[12,"invalid_tss","","An invalid TSS exception (`#TS`) occurs only as a result…",58,null],[12,"segment_not_present","","An segment-not-present exception (`#NP`) occurs when an…",58,null],[12,"stack_segment_fault","","An stack segment exception (`#SS`) can occur in the…",58,null],[12,"general_protection_fault","","A general protection fault (`#GP`) can occur in various…",58,null],[12,"page_fault","","A page fault (`#PF`) can occur during a memory access in…",58,null],[12,"reserved_1","","vector nr. 15",58,null],[12,"x87_floating_point","","The x87 Floating-Point Exception-Pending exception (`#MF`)…",58,null],[12,"alignment_check","","An alignment check exception (`#AC`) occurs when an…",58,null],[12,"machine_check","","The machine check exception (`#MC`) is model specific.…",58,null],[12,"simd_floating_point","","The SIMD Floating-Point Exception (`#XF`) is used to…",58,null],[12,"virtualization","","vector nr. 20",58,null],[12,"reserved_2","","vector nr. 21-29",58,null],[12,"security_exception","","The Security Exception (`#SX`) signals security-sensitive…",58,null],[12,"reserved_3","","vector nr. 31",58,null],[12,"interrupts","","User-defined interrupts can be initiated either by system…",58,null],[3,"IdtEntry","","An Interrupt Descriptor Table entry.",null,null],[12,"pointer_low","","Low word of the interrupt handler\'s virtual address. In an…",59,null],[12,"gdt_selector","","A segment selector.",59,null],[12,"zero","","Unused.",59,null],[12,"options","","Option bitfield.",59,null],[12,"pointer_high","","High word of the interrupt handler\'s virtual address.",59,null],[12,"phantom","","Type-safety guarantee: ensure that the function handler…",59,null],[3,"EntryOptions","","Represents the options field of an IDT entry.",null,null],[12,"0","","",60,null],[3,"ExceptionStackFrame","","Represents the exception stack frame pushed by the CPU on…",null,null],[12,"instruction_pointer","","This value points to the instruction that should be…",61,null],[12,"code_segment","","The code segment selector, padded with zeros.",61,null],[12,"cpu_flags","","The flags register before the interrupt handler was invoked.",61,null],[12,"stack_pointer","","The stack pointer at the time of the interrupt.",61,null],[12,"stack_segment","","The stack segment descriptor at the time of the interrupt…",61,null],[3,"PageFaultErrorCode","","Describes an page fault error code.",null,null],[12,"bits","","",62,null],[4,"GateType","","Represents the type of an IDT descriptor (called a gate).",null,null],[13,"TaskGate32","","",63,null],[13,"InterruptGate16","","",63,null],[13,"TrapGate16","","",63,null],[13,"InterruptGate32","","",63,null],[13,"TrapGate32","","",63,null],[6,"HandlerFunc","","A handler function for an interrupt or an exception…",null,null],[6,"HandlerFuncWithErrCode","","A handler function for an exception that pushes an error…",null,null],[6,"PageFaultHandlerFunc","","A page fault handler function that pushes a page fault…",null,null],[11,"init","","Creates a new IDT filled with non-present entries.",58,[[]]],[11,"load","","Loads the IDT in the CPU using the `lidt` command.",58,[[]]],[11,"missing","","Creates a non-present IDT entry (but sets the must-be-one…",59,[[]]],[11,"set_interrupt_gate_addr","","Set an interrupt gate function for the IDT entry and sets…",59,[[],["entryoptions",3]]],[11,"set_handler_task_gate","","Set a task gate for the IDT entry and sets the present bit.",59,[[["segmentselector",3]]]],[11,"set_handler_fn","","Set an interrupt gate function for the IDT entry and sets…",59,[[],["entryoptions",3]]],[11,"gate_type","","Type of the interrupt handler. Its value determines the…",60,[[],["gatetype",4]]],[11,"privilege_level","","",60,[[],["privilegelevel",4]]],[11,"is_present","","",60,[[]]],[11,"set_is_present","","",60,[[]]],[11,"minimal","","Creates a minimal options field with all the must-be-one…",60,[[]]],[11,"set_gate_type","","Set the kind of gate this IdtEntry represents.",60,[[["gatetype",4]]]],[11,"set_privilege_level","","Set the required privilege level (DPL) for invoking the…",60,[[["privilegelevel",4]]]],[11,"set_present_interrupt","","Set or reset the preset bit.",60,[[]]],[11,"set_present_task","","Set or reset the preset bit.",60,[[]]],[11,"disable_interrupts","","Let the CPU disable hardware interrupts when the handler…",60,[[]]],[18,"PROTECTION_VIOLATION","","If this flag is set, the page fault was caused by a…",62,null],[18,"CAUSED_BY_WRITE","","If this flag is set, the memory access that caused the…",62,null],[18,"USER_MODE","","If this flag is set, an access in user mode (CPL=3) caused…",62,null],[18,"MALFORMED_TABLE","","If this flag is set, the page fault is a result of the…",62,null],[18,"INSTRUCTION_FETCH","","If this flag is set, it indicates that the access that…",62,null],[11,"empty","","Returns an empty set of flags",62,[[],["pagefaulterrorcode",3]]],[11,"all","","Returns the set containing all flags.",62,[[],["pagefaulterrorcode",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",62,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",62,[[],[["option",4],["pagefaulterrorcode",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",62,[[],["pagefaulterrorcode",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",62,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",62,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",62,[[["pagefaulterrorcode",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",62,[[["pagefaulterrorcode",3]]]],[11,"insert","","Inserts the specified flags in-place.",62,[[["pagefaulterrorcode",3]]]],[11,"remove","","Removes the specified flags in-place.",62,[[["pagefaulterrorcode",3]]]],[11,"toggle","","Toggles the specified flags in-place.",62,[[["pagefaulterrorcode",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",62,[[["pagefaulterrorcode",3]]]],[0,"process_switch","sunrise_kernel::i386","Arch-specific process switch functions",null,null],[3,"ThreadHardwareContext","sunrise_kernel::i386::process_switch","The hardware context of a paused thread. It contains just…",null,null],[12,"esp","","The top of the stack, where all other registers are saved.",64,null],[5,"process_switch","","Performs the process switch, switching from currently…",null,[[["threadstruct",3],["arc",3]],[["threadstruct",3],["arc",3]]]],[5,"prepare_for_first_schedule","","Prepares the thread for its first schedule by writing…",null,[[["threadstruct",3]]]],[5,"first_schedule","","The function ret\'d on, on a thread\'s first schedule - as…",null,[[]]],[5,"jump_to_entrypoint","","Jumps to Userspace, and run a userspace program.",null,[[]]],[0,"gdt","sunrise_kernel::i386","GDT Handler",null,null],[3,"GdtManager","sunrise_kernel::i386::gdt","Safety wrapper that manages the lifetime of GDT tables.",null,null],[12,"table_a","","One of the two tables.",65,null],[12,"table_b","","One of the two tables.",65,null],[12,"table_selector","","The table currently pointed to by GDTR. `0` is `table_a`,…",65,null],[3,"MainTask","","The main TSS. See [MAIN_TASK].",null,null],[12,"tss","","TssStruct of the main task.",66,null],[12,"iopb","","Array of bits representing the io-space permissions:",66,null],[3,"DoubleFaultTaskStack","","The stack used while handling a double fault.",null,null],[12,"0","","",67,null],[3,"DescriptorTable","","A structure containing our GDT.",null,null],[12,"table","","The GDT table, an array of DescriptorTableEntry.",68,null],[3,"DescriptorTableEntry","","An entry in the GDT/LDT.",null,null],[12,"0","","",69,null],[4,"GdtIndex","","Index in the GDT of each segment descriptor.",null,null],[13,"Null","","The index in the GDT of the null descriptor.",70,null],[13,"KCode","","The index in the GDT of the Kernel code segment descriptor.",70,null],[13,"KData","","The index in the GDT of the Kernel data segment descriptor.",70,null],[13,"KTls","","The index in the GDT of the Kernel thread local storage…",70,null],[13,"KStack","","The index in the GDT of the Kernel stack segment descriptor.",70,null],[13,"UCode","","The index in the GDT of the Userland code segment…",70,null],[13,"UData","","The index in the GDT of the Userland data segment…",70,null],[13,"UTlsRegion","","The index in the GDT of the Userland thread local storage…",70,null],[13,"UTlsElf","","The index in the GDT of the Userland thread local storage…",70,null],[13,"UStack","","The index in the GDT of the Userland stack segment…",70,null],[13,"LDT","","The index in the GDT of the LDT descriptor.",70,null],[13,"TSS","","The index in the GDT of the main TSS descriptor.",70,null],[13,"FTSS","","The index in the GDT of the double fault TSS descriptor.",70,null],[13,"DescCount","","The number of descriptors in the GDT.",70,null],[4,"SystemDescriptorTypes","","Lists the valid values of System Descriptor Types.",null,null],[13,"AvailableTss16","","",71,null],[13,"Ldt","","",71,null],[13,"BusyTss16","","",71,null],[13,"CallGate16","","",71,null],[13,"AvailableTss32","","",71,null],[13,"BusyTss32","","",71,null],[13,"CallGate32","","",71,null],[5,"init_gdt","","Initializes the GDT.",null,[[]]],[7,"GDT","","The global GDT. Needs to be initialized with [init_gdt].",null,null],[7,"GLOBAL_LDT","","The global LDT used by all the processes.",null,null],[7,"MAIN_TASK","","Main TSS",null,null],[7,"DOUBLE_FAULT_TASK","","Double fault TSS",null,null],[7,"DOUBLE_FAULT_TASK_STACK","","The stack used while handling a double fault. See…",null,null],[11,"selector","","Turns a segment descriptor index to a segment selector.",70,[[],["segmentselector",3]]],[11,"commit","","Commit the changes in the currently unloaded table, and…",65,[[["option",4],["segmentselector",3]]]],[11,"empty","","Creates an empty TSS.",66,[[],["maintask",3]]],[11,"init","","Fills the TSS.",66,[[]]],[11,"load_global","","Load this descriptor table into the GDTR, and reload the…",68,[[["option",4],["segmentselector",3]]]],[11,"null_descriptor","","Returns an empty descriptor. Using this descriptor is an…",69,[[],["descriptortableentry",3]]],[11,"new","","Creates an empty GDT descriptor, but with some flags set…",69,[[["privilegelevel",4]],["descriptortableentry",3]]],[11,"new_system","","Creates an empty GDT system descriptor of the given type.",69,[[["privilegelevel",4],["systemdescriptortypes",4]],["descriptortableentry",3]]],[11,"new_ldt","","Creates a new LDT descriptor.",69,[[["privilegelevel",4],["descriptortable",3]],["descriptortableentry",3]]],[11,"new_tss","","Creates a GDT descriptor pointing to a TSS segment",69,[[["tssstruct",3],["privilegelevel",4]],["descriptortableentry",3]]],[11,"get_limit","","Gets the byte length of the entry, minus 1.",69,[[]]],[11,"set_limit","","Sets the entry\'s byte length to the given number plus one.…",69,[[]]],[11,"get_base","","Gets the base address of the entry.",69,[[]]],[11,"set_base","","Sets the base address of the entry.",69,[[]]],[11,"get_accessed","","CPU sets this bit to true when the segment is accessed.",69,[[]]],[11,"is_readwrite_allowed","","",69,[[]]],[11,"is_comformant","","",69,[[]]],[11,"is_executable","","Determines whether the segment is a code segment or a data…",69,[[]]],[11,"get_ring_level","","The privilege level associated with this segment.",69,[[],["privilegelevel",4]]],[11,"get_present","","A segment needs to be present to have an effect. Using a…",69,[[]]],[11,"is_4k_granularity","","If true, the limit is a count of 4k pages. If false, it is…",69,[[]]],[11,"set_4k_granularity","","If true, the limit is a count of 4k pages. If false, it is…",69,[[]]],[11,"is_32bit","","If true, this is a 32-bit segment. If false, it is a…",69,[[]]],[0,"interrupt","sunrise_kernel::i386","Arch-generic interrupt handling.",null,null],[3,"InterruptHandler","sunrise_kernel::i386::interrupt","Global state for the interrupt handler.",null,null],[12,"root_lapic","","Root CPU\'s Local APIC.",72,null],[12,"ioapics","","Vector of all the IO-APICs.",72,null],[12,"isa_mappings","","List of interrupt mappings.",72,null],[5,"init","","Initialize the interrupt handler.",null,[[]]],[5,"acknowledge","","Acknowledge the given IRQ.",null,[[]]],[5,"unmask","","Unmasks the given IRQ.",null,[[]]],[5,"isa_to_ioapic_irq","","Gets the IOAPIC pin associated with an ISA (i8259) IRQ.",null,[[]]],[7,"INTERRUPT_HANDLER","","Global state for the interrupt handler.",null,null],[0,"interrupt_service_routines","sunrise_kernel::i386","i386 exceptions + irq + syscall handling",null,null],[3,"UserspaceHardwareContext","sunrise_kernel::i386::interrupt_service_routines","Represents a register backup.",null,null],[12,"esp","","",73,null],[12,"gs","","",73,null],[12,"ebp","","",73,null],[12,"edi","","",73,null],[12,"esi","","",73,null],[12,"edx","","",73,null],[12,"ecx","","",73,null],[12,"ebx","","",73,null],[12,"eax","","",73,null],[12,"errcode","","",73,null],[12,"eip","","",73,null],[12,"cs","","",73,null],[12,"eflags","","",73,null],[3,"IDT","","IDT address. Initialized in `init()`.",null,null],[12,"__private_field","","",74,null],[5,"check_thread_killed","","Checks if our thread was killed, in which case unschedule…",null,[[]]],[5,"divide_by_zero_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"divide_by_zero_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"debug_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"debug_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"nmi_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"nmi_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"breakpoint_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"breakpoint_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"overflow_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"overflow_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"bound_range_exceeded_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"bound_range_exceeded_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"invalid_opcode_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"invalid_opcode_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"device_not_available_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"device_not_available_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"double_fault_handler","","Double fault handler. Panics the kernel unconditionally.",null,[[]]],[5,"invalid_tss_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"invalid_tss_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"segment_not_present_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"segment_not_present_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"stack_fault_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"stack_fault_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"general_protection_fault_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"general_protection_fault_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"page_fault_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"page_fault_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"kernel_page_fault_panic","","Overriding the default panic strategy so we can display cr2",null,[[["userspacehardwarecontext",3]]]],[5,"user_page_fault_panic","","Overriding the default panic strategy so we can display cr2",null,[[["userspacehardwarecontext",3]]]],[5,"user_page_fault_handler","","Overriding the default kill strategy so we can display cr2",null,[[["userspacehardwarecontext",3]]]],[5,"x87_floating_point_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"x87_floating_point_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"alignment_check_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"alignment_check_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"machine_check_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"machinee_check_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"simd_floating_point_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"simd_floating_point_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"virtualization_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"virtualization_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"security_exception_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"security_exception_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"syscall_interrupt_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"syscall_interrupt_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"syscall_interrupt_dispatcher","","This is the function called on int 0x80.",null,[[["userspacehardwarecontext",3]]]],[5,"pit_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"pit_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"pit_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"keyboard_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"keyboard_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"keyboard_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"cascade_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"cascade_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"cascade_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"serial2_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"serial2_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"serial2_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"serial1_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"serial1_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"serial1_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"sound_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"sound_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"sound_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"floppy_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"floppy_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"floppy_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"parallel1_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"parallel1_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"parallel1_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"rtc_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"rtc_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"rtc_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"acpi_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"acpi_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"acpi_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"irq10_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"irq10_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"irq10_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"irq11_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"irq11_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"irq11_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"mouse_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"mouse_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"mouse_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"irq13_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"irq13_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"irq13_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"primary_ata_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"primary_ata_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"primary_ata_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"secondary_ata_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"secondary_ata_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"secondary_ata_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"hpet_handler","","Auto generated irq handler. See [`irq_handler`].",null,[[["userspacehardwarecontext",3]]]],[5,"hpet_handler_asm_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[]]],[5,"hpet_handler_rust_wrapper","","Auto generated function. See [generate_trap_gate_handler].",null,[[["userspacehardwarecontext",3]]]],[5,"init","","Initialize the interrupt subsystem. Sets up the PIC and…",null,[[]]],[7,"INSIDE_INTERRUPT_COUNT","","Contains the number of interrupts we are currently inside.",null,null],[7,"IRQ_HANDLERS","","Array of interrupt handlers.",null,null],[11,"apply0","","Update the Registers with the passed result.",73,[[["result",4],["userspaceerror",3]]]],[11,"apply1","","Update the Registers with the passed result.",73,[[["result",4],["userspaceerror",3]]]],[11,"apply2","","Update the Registers with the passed result.",73,[[["userspaceerror",3],["result",4]]]],[11,"apply3","","Update the Registers with the passed result.",73,[[["userspaceerror",3],["result",4]]]],[11,"apply4","","Update the Registers with the passed result.",73,[[["result",4],["userspaceerror",3]]]],[0,"pio","sunrise_kernel::i386","Port IO",null,null],[3,"Pio","sunrise_kernel::i386::pio","Port IO accessor.",null,null],[12,"port","","The io port address.",75,null],[12,"value","","The width of the port.",75,null],[0,"instructions","sunrise_kernel::i386","Low level functions for special i386 instructions.",null,null],[0,"tables","sunrise_kernel::i386::instructions","Instructions for loading descriptor tables (GDT, IDT, etc.).",null,null],[3,"DescriptorTablePointer","sunrise_kernel::i386::instructions::tables","A struct describing a pointer to a descriptor table (GDT /…",null,null],[12,"limit","","Size of the DT.",76,null],[12,"base","","Physical address of the memory region containing the DT.",76,null],[5,"lgdt","","Load GDT table.",null,[[["descriptortablepointer",3]]]],[5,"sgdt","","Store GDT table.",null,[[],["descriptortablepointer",3]]],[5,"lldt","","Load LDT table.",null,[[["segmentselector",3]]]],[5,"ltr","","Sets the task register to the given TSS segment.",null,[[["segmentselector",3]]]],[5,"lidt","","Load IDT table.",null,[[["descriptortablepointer",3]]]],[0,"segmentation","sunrise_kernel::i386::instructions","Provides functions to read and write segment registers.",null,null],[5,"set_cs","sunrise_kernel::i386::instructions::segmentation","Reload code segment register. Note this is special since…",null,[[["segmentselector",3]]]],[5,"load_ss","","Reload stack segment register.",null,[[["segmentselector",3]]]],[5,"load_ds","","Reload data segment register.",null,[[["segmentselector",3]]]],[5,"load_es","","Reload es segment register.",null,[[["segmentselector",3]]]],[5,"load_fs","","Reload fs segment register.",null,[[["segmentselector",3]]]],[5,"load_gs","","Reload gs segment register.",null,[[["segmentselector",3]]]],[5,"cs","","Returns the current value of the code segment register.",null,[[],["segmentselector",3]]],[5,"ss","","Read the value of the stack segment register.",null,[[],["segmentselector",3]]],[5,"ds","","Read the value of the data segment register.",null,[[],["segmentselector",3]]],[5,"es","","Read the value of the es segment register.",null,[[],["segmentselector",3]]],[5,"fs","","Read the value of the fs segment register.",null,[[],["segmentselector",3]]],[5,"gs","","Read the value of the gs segment register.",null,[[],["segmentselector",3]]],[0,"interrupts","sunrise_kernel::i386::instructions","Interrupt disabling functionality.",null,null],[5,"sti","sunrise_kernel::i386::instructions::interrupts","Enable interrupts",null,[[]]],[5,"cli","","Disable interrupts",null,[[]]],[5,"hlt","","Waits until an interrupt is fired",null,[[]]],[5,"are_enabled","","Returns whether interrupts are enabled.",null,[[]]],[5,"without_interrupts","","Run a closue with disabled interrupts.",null,[[]]],[11,"from_u8","sunrise_kernel::i386","Creates a `PrivilegeLevel` from a numeric value. The value…",53,[[],["privilegelevel",4]]],[11,"empty","","Creates an empty TssStruct.",52,[[],["tssstruct",3]]],[11,"init","","Fills the TSS.",52,[[]]],[11,"set_esp0_stack","","Set the stack pointer used to handle interrupts occuring…",52,[[]]],[11,"set_ip","","Set the IP of the current task struct. When we hardware…",52,[[]]],[0,"syscalls","sunrise_kernel","Syscall implementations",null,null],[5,"set_heap_size","sunrise_kernel::syscalls","Resize the heap of a process, just like a brk. It can both…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"map_framebuffer","","Maps the vga frame buffer mmio in userspace memory",null,[[],[["result",4],["userspaceerror",3]]]],[5,"create_interrupt_event","","Create an event handle for the given IRQ number. Waiting…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"query_physical_address","","Gets the physical region a given virtual address maps.",null,[[],[["userspaceerror",3],["result",4]]]],[5,"wait_synchronization","","Waits for one of the handles to signal an event.",null,[[["userspaceptr",3]],[["result",4],["userspaceerror",3]]]],[5,"output_debug_string","","Print the passed string to the serial port.",null,[[["userspaceptr",3]],[["result",4],["userspaceerror",3]]]],[5,"exit_process","","Kills our own process.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"connect_to_port","","Connects to the given ClientPort.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"exit_thread","","Kills our own thread.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"create_thread","","Creates a thread in the current process. The thread can…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"start_thread","","Starts a previously created thread.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"connect_to_named_port","","Connects to the given named port. The name should be a…",null,[[["userspaceptr",3]],[["result",4],["userspaceerror",3]]]],[5,"manage_named_port","","Creates a new ServerPort for the given named port. The…",null,[[["userspaceptr",3]],[["result",4],["userspaceerror",3]]]],[5,"accept_session","","Waits for an incoming connection on the given ServerPort…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"send_sync_request_with_user_buffer","","Send an IPC request through the ClientSession, and blocks…",null,[[["userspaceptrmut",3]],[["result",4],["userspaceerror",3]]]],[5,"reply_and_receive_with_user_buffer","","If ReplyTarget is not zero, a reply from the given buffer…",null,[[["userspaceptrmut",3],["userspaceptr",3]],[["result",4],["userspaceerror",3]]]],[5,"close_handle","","Closed the passed handle.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"sleep_thread","","Sleep for a specified amount of time, or yield thread.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"signal_event","","Sets the \\\"signaled\\\" state of an event. Calling this on an…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"clear_event","","Clear the \\\"signaled\\\" state of an event. After calling this…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"create_port","","Create a new Port pair. Those ports are linked to…",null,[[["userspaceptr",3]],[["userspaceerror",3],["result",4]]]],[5,"create_shared_memory","","Allocate a new SharedMemory region. This is a memory…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"map_shared_memory","","Maps the block supplied by the handle. The required…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"unmap_shared_memory","","Unmaps this shared memory region. This cannot be used to…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"query_memory","","Query information about an address. Will always fetch the…",null,[[["userspaceptrmut",3],["memoryinfo",3]],[["result",4],["userspaceerror",3]]]],[5,"create_session","","Create a new Session pair. Those sessions are linked to…",null,[[],[["userspaceerror",3],["result",4]]]],[5,"create_event","","Create a [WritableEvent]/[ReadableEvent] pair. Signals on…",null,[[],[["userspaceerror",3],["result",4]]]],[5,"map_mmio_region","","Maps a physical region in the address space of the process.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"set_thread_area","","Set thread local area pointer.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"set_process_memory_permission","","Change permission of a page-aligned memory region.…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"map_process_memory","","Maps the given src memory range from a remote process into…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"unmap_process_memory","","Unmaps a memory range mapped with [map_process_memory()].…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"create_process","","Creates a new process. This will create an empty address…",null,[[["userspaceptr",3],["userspaceptr",3],["procinfo",3]],[["result",4],["userspaceerror",3]]]],[5,"start_process","","Start the given process on the provided CPU with the…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"get_process_info","","Extract information from a process.",null,[[],[["result",4],["userspaceerror",3]]]],[5,"reset_signal","","Clear the \\\"signaled\\\" state of a readable event or process.…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"get_process_id","","Gets the PID of the given Process handle. Alias handles…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"terminate_process","","Kills the given process, terminating the execution of all…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"get_process_list","","Fills the provided array with the pids of currently living…",null,[[],[["result",4],["userspaceerror",3]]]],[0,"frame_allocator","sunrise_kernel","Physical memory manager.",null,null],[3,"FrameAllocator","sunrise_kernel::frame_allocator","The physical memory manager.",null,null],[5,"init","","Initialize the [FrameAllocator] by parsing the multiboot…",null,[[["bootinformation",3]]]],[5,"mark_frame_bootstrap_allocated","","Marks a physical memory frame as already allocated…",null,[[["physicaladdress",3]]]],[0,"physical_mem_region","","PhysicalMemRegion",null,null],[3,"PhysicalMemRegion","sunrise_kernel::frame_allocator::physical_mem_region","A span of adjacent physical frames. A frame is [PAGE_SIZE].",null,null],[12,"frames","","The number of frames in this region.",77,null],[12,"start_addr","","The (physical) address of the start of this region.",77,null],[12,"should_free_on_drop","","Denotes if the frames held in this region should be freed…",77,null],[3,"PhysicalMemRegionIter","","An iterator over a physical region. Yields the address of…",null,null],[12,"0","","",78,null],[12,"1","","",78,null],[11,"address","","Get the start address of this PhysicalMemRegion.",77,[[],["physicaladdress",3]]],[11,"size","","Get the size this PhysicalMemRegion spans.",77,[[]]],[11,"on_fixed_mmio","","Constructs a `PhysicalMemRegion` by circumventing the…",77,[[["physicaladdress",3]],[["result",4],["kernelerror",4]]]],[11,"new_unchecked","","Construct a `PhysicalMemRegion` by circumventing the…",77,[[["physicaladdress",3]]]],[11,"reconstruct","","Constructs a `PhysicalMemRegion` from a physical address,…",77,[[["physicaladdress",3]]]],[11,"reconstruct_no_dealloc","","Constructs a `PhysicalMemRegion` from a physical address,…",77,[[["physicaladdress",3]]]],[0,"i386","sunrise_kernel::frame_allocator","Architecture specific-behaviour i386 implementation of the…",null,null],[3,"FrameAllocatori386","sunrise_kernel::frame_allocator::i386","A frame allocator backed up by a giant bitmap.",null,null],[12,"memory_bitmap","","A big bitmap denoting for every frame if it is free or not",79,null],[12,"initialized","","All operations have to check that the Allocator has been…",79,null],[3,"FrameAllocator","","The physical memory manager.",null,null],[5,"addr_to_frame","","Gets the frame number from a physical address",null,[[]]],[5,"frame_to_addr","","Gets the physical address from a frame number",null,[[]]],[5,"init","","Initialize the [FrameAllocator] by parsing the multiboot…",null,[[["bootinformation",3]]]],[5,"mark_area_reserved","","Marks a physical memory area as reserved and will never…",null,[[]]],[5,"mark_area_free","","Marks a physical memory area as free for frame allocation",null,[[]]],[5,"mark_frame_bootstrap_allocated","","Marks a physical memory frame as already allocated…",null,[[["physicaladdress",3]]]],[7,"FRAME_ALLOCATOR","","A physical memory manger to allocate and free memory frames",null,null],[17,"FRAME_OFFSET_MASK","","The offset part in a [PhysicalAddress]. ``` let…",null,null],[17,"FRAME_BASE_MASK","","The frame part in [PhysicalAddress]. ``` let phys_address…",null,null],[17,"FRAME_BASE_LOG","","The right shift to perform to a Physical address to get…",null,null],[17,"FRAMES_BITMAP_SIZE","","For unit tests we use a much smaller array.",null,null],[17,"FRAME_FREE","","In the the bitmap, 1 means the frame is free.",null,null],[17,"FRAME_OCCUPIED","","In the the bitmap, 0 means the frame is occupied.",null,null],[11,"new","","Called to initialize the [FRAME_ALLOCATOR] global.",79,[[]]],[0,"private","sunrise_kernel::frame_allocator","Private FrameAllocator API",null,null],[8,"FrameAllocatorTraitPrivate","sunrise_kernel::frame_allocator::private","An arch-specifig FrameAllocator must expose the following…",null,null],[10,"free_region","","Marks a region as deallocated. Called when a…",80,[[["physicalmemregion",3]]]],[10,"check_is_allocated","","Checks if a region is marked allocated.",80,[[["physicaladdress",3]]]],[10,"check_is_reserved","","Checks if a region is marked reserved.",80,[[["physicaladdress",3]]]],[8,"FrameAllocatorTrait","sunrise_kernel::frame_allocator","An arch-specific FrameAllocator must expose the following…",null,null],[10,"allocate_region","","Allocates a single PhysicalMemRegion. Frames are…",81,[[],[["physicalmemregion",3],["result",4],["kernelerror",4]]]],[10,"allocate_frames_fragmented","","Allocates physical frames, possibly fragmented across…",81,[[],[["vec",3],["kernelerror",4],["result",4]]]],[11,"allocate_frame","","Allocates a single physical frame.",81,[[],[["physicalmemregion",3],["result",4],["kernelerror",4]]]],[0,"heap_allocator","sunrise_kernel","Virtual heap allocator.",null,null],[3,"Allocator","sunrise_kernel::heap_allocator","Simple wrapper around linked_list_allocator, growing heap…",null,null],[12,"0","","",82,null],[17,"RESERVED_HEAP_SIZE","","Maximum size of our Kernel Heap.",null,null],[11,"expand","","Safely expands the heap if possible.",82,[[]]],[11,"init","","Create a new Heap of `RESERVED_HEAP_SIZE` bytes.",82,[[],[["heap",3],["spinlock",3]]]],[11,"new","","Creates a new heap based off of loader settings.",82,[[],["allocator",3]]],[0,"devices","sunrise_kernel","Device drivers",null,null],[5,"init_timer","sunrise_kernel::devices","Initialize a timer to be used by the OS.",null,[[]]],[0,"hpet","","HPET driver implementation.",null,null],[3,"HpetIdRegister","sunrise_kernel::devices::hpet","Represent the lower part of the General Capabilities and…",null,null],[12,"0","","",83,null],[3,"HpetGeneralConfigurationRegister","","Represent the General Configuration Register.",null,null],[12,"0","","",84,null],[3,"HpetTimerConfigurationRegister","","Represent a Timer Configuration Register.",null,null],[12,"0","","",85,null],[3,"HpetRegister","","Representation of HPET non variable registers.",null,null],[12,"identifier","","Information about the HPET model.",86,null],[12,"period","","Main counter tick period in femtoseconds (10^-15 seconds).…",86,null],[12,"_reserved0","","",86,null],[12,"general_configuration","","General Configuration Register.",86,null],[12,"_reserved1","","",86,null],[12,"_reserved2","","",86,null],[12,"general_interrupt_status","","General Interrupt Status Register.",86,null],[12,"_reserved3","","",86,null],[12,"main_counter_value","","main counter value.",86,null],[12,"_reserved4","","",86,null],[3,"HpetTimerRegister","","Representation of an HPET timer registers.",null,null],[12,"config","","The configuration and capabilities register of this timer.",87,null],[12,"interrupt_route_capability","","Routing capability (IRQ0 to IRQ31 on the I/O APIC).",87,null],[12,"comparator_value_low","","The comparator value register low part.",87,null],[12,"comparator_value_high","","The comparator value register high part.",87,null],[12,"fsb_value","","The FSB Interrupt Route register lower part (value during…",87,null],[12,"fsb_address","","The FSB Interrupt Route register higher part (address used…",87,null],[3,"Hpet","","Represent an HPET device.",null,null],[12,"inner","","The mmio address of this HPET device.",88,null],[12,"period","","Cached value of `Hpet::period`.",88,null],[12,"timer_count","","The count of timer of this HPET device.",88,null],[3,"HpetTimer","","Represent an HPET timer.",null,null],[12,"inner","","The mmio address of this HPET timer.",89,null],[12,"support_64bit","","Cached value of…",89,null],[12,"support_periodic_interrupt","","Cached value of…",89,null],[12,"support_fsb_interrupt","","Cached value of…",89,null],[12,"interrupt_route_capability","","Cached value of…",89,null],[5,"init","","Try to initialize the HPET in legacy mode.",null,[[["hpet",3]]]],[7,"HPET_INSTANCE","","The instance of the HPET device we are using.",null,null],[11,"revision_id","","Indicates which revision of the function is implemented;…",83,[[]]],[11,"timer_count_minus_one","","The amount of timers - 1.",83,[[]]],[11,"counter_size_capability","","If this bit is 1, HPET main counter is capable of…",83,[[]]],[11,"legacy_rt_capability","","If this bit is 1, HPET is capable of using \\\"legacy…",83,[[]]],[11,"vendor_id","","Represent the HPET vendor id (most likely PCI vendor id?)",83,[[]]],[11,"enable_config","","Control HPET activation (control main timer activation…",84,[[]]],[11,"set_enable_config","","Control HPET activation (control main timer activation…",84,[[]]],[11,"legacy_rt_config","","Control \\\"legacy replacement\\\" mapping activation state.",84,[[]]],[11,"set_legacy_rt_config","","Control \\\"legacy replacement\\\" mapping activation state.",84,[[]]],[11,"interrupt_type","","Control Timer Interrupt Type: 0 = Edge Trigger, 1 = Level…",85,[[]]],[11,"set_interrupt_type","","Control Timer Interrupt Type: 0 = Edge Trigger, 1 = Level…",85,[[]]],[11,"interrupt_enable","","Control Timer Interrupt.",85,[[]]],[11,"set_interrupt_enable","","Control Timer Interrupt.",85,[[]]],[11,"timer_type","","Control Timer Type: 0 = One Shot, 1 = Periodic",85,[[]]],[11,"set_timer_type","","Control Timer Type: 0 = One Shot, 1 = Periodic",85,[[]]],[11,"periodic_interrupt_capability","","true if this timer is capable of periodic timer.",85,[[]]],[11,"size_capability","","If this bit is 1, this timer is capable of operating in 64…",85,[[]]],[11,"accumulator_config","","Set to 1 to allow software to write the accumulator data.",85,[[]]],[11,"set_accumulator_config","","Set to 1 to allow software to write the accumulator data.",85,[[]]],[11,"is_32bit_mode","","Set to 1 to force a 64 bit timer to operate as 32 bit one",85,[[]]],[11,"set_32bit_mode","","Set to 1 to force a 64 bit timer to operate as 32 bit one",85,[[]]],[11,"interrupt_route","","Timer Interrupt Route: This indicate the routing in the…",85,[[]]],[11,"set_interrupt_route","","Timer Interrupt Route: This indicate the routing in the…",85,[[]]],[11,"fsb_interrupt","","Timer FSB Interrupt: force the interrupts to be delivered…",85,[[]]],[11,"set_fsb_interrupt","","Timer FSB Interrupt: force the interrupts to be delivered…",85,[[]]],[11,"fsb_interrupt_capability","","Timer FSB Interrupt Delivery capability.",85,[[]]],[18,"MAX_IRQ","","This is the maximum IRQ lines supported by the HPET.",89,null],[11,"new","","Create a new HPET timer instance from MMIO registers.",89,[[]]],[11,"support_64bit","","Return true if this timer is a 64 bits timer.",89,[[]]],[11,"support_periodic_interrupt","","Return true if this timer supports periodic interrupt.",89,[[]]],[11,"support_fsb_interrupt","","Return true if this timer supports fsb interrupt.",89,[[]]],[11,"support_interrupt_routing","","Return true if the timer support routing to the given IRQ.",89,[[]]],[11,"set_interrupt_route","","Set the routing for the interrupt to the I/O APIC.",89,[[]]],[11,"set_comparator_value","","Set the timer comparactor value",89,[[]]],[11,"set_accumulator_value","","Set the timer accumulator value.",89,[[]]],[11,"set_edge_trigger","","Set Edge Trigger.",89,[[]]],[11,"set_level_trigger","","Set Level Trigger.",89,[[]]],[11,"set_one_shot_mode","","Set the timer in One Shot mode.",89,[[]]],[11,"set_periodic_mode","","Set the timer in Periodic mode.",89,[[]]],[11,"enable_interrupt","","Enable interrupt.",89,[[]]],[11,"disable_interrupt","","Disable interrupt.",89,[[]]],[11,"has_interrupt_enabled","","Determine if the interrupt is enabled.",89,[[]]],[11,"new","","Create a new HPET device instance from MMIO registers.",88,[[]]],[11,"has_legacy_mapping","","Return true if the device supports \\\"legacy mapping\\\".",88,[[]]],[11,"get_period","","Return the period of the HPET device.",88,[[]]],[11,"get_frequency","","Return the frequency of the HPET device.",88,[[]]],[11,"enable_legacy_mapping","","Enable the \\\"legacy mapping\\\".",88,[[]]],[11,"disable_legacy_mapping","","Disable the \\\"legacy mapping\\\".",88,[[]]],[11,"is_legacy_mapping_enabled","","Check \\\"legacy mapping\\\" status.",88,[[]]],[11,"enable","","Enable HPET (main timer running, and timer interrupts…",88,[[]]],[11,"set_main_counter_value","","Set HPET main counter value.",88,[[]]],[11,"get_main_counter_value","","Get HPET main counter value.",88,[[]]],[11,"disable","","Disable HPET (main timer halted, and timer interrupts…",88,[[]]],[11,"is_enabled","","Check HPET status.",88,[[]]],[11,"get_timer","","Get a timer at the given index.",88,[[],[["hpettimer",3],["option",4]]]],[0,"pic","sunrise_kernel::devices","Driver for the 8259 Programmable Interrupt Controller.",null,null],[3,"ICW1","sunrise_kernel::devices::pic","The first control word sent to the PIC.",null,null],[12,"bits","","",90,null],[3,"InternalPic","","A single PIC8259 device.",null,null],[12,"port_cmd","","The PIC\'s COMMAND IO port.",91,null],[12,"port_data","","The PIC\'s DATA IO port.",91,null],[3,"Pic","","A master/slave PIC setup, as commonly found on IBM PCs.",null,null],[12,"master","","The master PIC.",92,null],[12,"slave","","The slave PIC, cascaded on line 2 of `.master`",92,null],[5,"get","","Acquires a reference to the PIC, initializing it if it…",null,[[],["pic",3]]],[5,"init","","Initializes the PIC if it has not yet been initialized.…",null,[[]]],[7,"PIC","","The PIC manager.",null,null],[17,"ICW4_8086","","ICW4: 8086/88 (MCS-80/85) mode.",null,null],[18,"ICW4","","If this bit is set, ICW4 has to be read. If ICW4 is not…",90,null],[18,"SINGLE","","Single. Means that this is the only 8259A in the system.…",90,null],[18,"INTERVAL4","","Call Address Interval. Used only in 8085, not 8086.…",90,null],[18,"LEVEL","","If LEVEL = 1, then the 8259A will operate in the level…",90,null],[18,"INIT","","Should always be set to 1.",90,null],[11,"empty","","Returns an empty set of flags",90,[[],["icw1",3]]],[11,"all","","Returns the set containing all flags.",90,[[],["icw1",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",90,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",90,[[],[["icw1",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",90,[[],["icw1",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",90,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",90,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",90,[[["icw1",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",90,[[["icw1",3]]]],[11,"insert","","Inserts the specified flags in-place.",90,[[["icw1",3]]]],[11,"remove","","Removes the specified flags in-place.",90,[[["icw1",3]]]],[11,"toggle","","Toggles the specified flags in-place.",90,[[["icw1",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",90,[[["icw1",3]]]],[11,"new","","Creates a new PIC, and initializes it.",92,[[],["pic",3]]],[11,"mask","","Mask the given IRQ number. Will redirect the call to the…",92,[[]]],[11,"unmask","","Unmask the given IRQ number. Will redirect the call to the…",92,[[]]],[11,"get_mask","","Reads the PIC interrupt mask. Used for debug purposes.",92,[[]]],[11,"acknowledge","","Acknowledges an IRQ, allowing the PIC to send a new IRQ on…",92,[[]]],[11,"new","","Setup the 8259 pic. Redirect the IRQ to the chosen…",91,[[],["internalpic",3]]],[11,"acknowledge","","Acknowledges an IRQ, allowing the PIC to send a new IRQ on…",91,[[]]],[11,"mask","","Mask the given IRQ",91,[[]]],[11,"unmask","","Unmask the given IRQ",91,[[]]],[11,"get_mask","","Read the IRQ mask. Used mostly for debug purposes.",91,[[]]],[0,"pit","sunrise_kernel::devices","Programmable Interval Timer",null,null],[3,"PIT_PORTS","sunrise_kernel::devices::pit","The mutex wrapping the ports",null,null],[12,"__private_field","","",93,null],[3,"Port61Flags","","The port 0x61 flags we use.",null,null],[12,"bits","","",94,null],[3,"PITPorts","","We put the PIT ports in a structure to have them under a…",null,null],[12,"port_chan_0","","",95,null],[12,"port_chan_2","","",95,null],[12,"port_cmd","","",95,null],[12,"port_61","","",95,null],[3,"PITChannel2","","Channel 2",null,null],[12,"ports","","A reference to the PITPorts structure.",96,null],[4,"ChannelSelector","","Used internally to select which channel to apply…",null,null],[13,"Channel0","","Operation should apply to Channel 0.",97,null],[13,"Channel2","","Operation should apply to Channel 2.",97,null],[5,"spin_wait_ms","","Spin waits for at least `ms` amount of milliseconds",null,[[]]],[5,"init_channel_0","","Initialize the channel 0 to send recurring irqs.",null,[[]]],[5,"disable","","Prevent the PIT from generating interrupts.",null,[[]]],[17,"OSCILLATOR_FREQ","","The oscillator frequency when not divided, in hertz.",null,null],[17,"CHAN_0_FREQUENCY","","The frequency of channel 0 irqs, in hertz. One every 10…",null,null],[17,"CHAN_0_DIVISOR","","The channel 0 reset value",null,null],[18,"SPKR_CONTROL","","",94,null],[18,"OUT2_STATUS","","",94,null],[18,"GATE_2","","",94,null],[18,"OUT1_STATUS","","",94,null],[18,"OTHER_2","","",94,null],[18,"OTHER_3","","",94,null],[18,"OTHER_6","","",94,null],[18,"OTHER_7","","",94,null],[11,"empty","","Returns an empty set of flags",94,[[],["port61flags",3]]],[11,"all","","Returns the set containing all flags.",94,[[],["port61flags",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",94,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",94,[[],[["option",4],["port61flags",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",94,[[],["port61flags",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",94,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",94,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",94,[[["port61flags",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",94,[[["port61flags",3]]]],[11,"insert","","Inserts the specified flags in-place.",94,[[["port61flags",3]]]],[11,"remove","","Removes the specified flags in-place.",94,[[["port61flags",3]]]],[11,"toggle","","Toggles the specified flags in-place.",94,[[["port61flags",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",94,[[["port61flags",3]]]],[11,"write_reload_value","","Writes a reload value in lobyte/hibyte access mode",95,[[["channelselector",4]]]],[11,"init","","Sets mode #0 for Channel 2.",96,[[["pitports",3]],["pitchannel2",3]]],[11,"start_countdown","","Sets the countdown reset value by writing to channel 2…",96,[[]]],[11,"is_countdown_finished","","Checks if the countdown is finished",96,[[]]],[11,"wait_countdown_is_finished","","Waits until countdown is finished",96,[[]]],[11,"spin_wait_ms","","Spin waits for at least `ms` amount of milliseconds",96,[[]]],[0,"rs232","sunrise_kernel::devices","RS-232 serial port driver",null,null],[3,"ComPort","sunrise_kernel::devices::rs232","The base IO port of a COM",null,null],[12,"0","","",98,null],[3,"SerialAttributes","","A foreground and a background combination",null,null],[12,"fg","","foreground color",99,null],[12,"bg","","background color",99,null],[3,"SerialInternal","","A COM output. Wraps the IO ports of this COM, and provides…",null,null],[12,"data_port","","The DATA IO port of this COM",100,null],[12,"status_port","","The STATUS IO port of this COM",100,null],[3,"SerialLogger","","A logger that sends its output to COM1.",null,null],[4,"SerialColor","","The possible colors for serial",null,null],[13,"Black","","",101,null],[13,"Red","","",101,null],[13,"Green","","",101,null],[13,"Yellow","","",101,null],[13,"Blue","","",101,null],[13,"Magenta","","",101,null],[13,"Cyan","","",101,null],[13,"LightGray","","",101,null],[13,"Default","","",101,null],[13,"DarkGray","","",101,null],[13,"LightRed","","",101,null],[13,"LightGreen","","",101,null],[13,"LightYellow","","",101,null],[13,"LightBlue","","",101,null],[13,"LightMagenta","","",101,null],[13,"LightCyan","","",101,null],[13,"White","","",101,null],[7,"G_SERIAL","","The serial logger.",null,null],[17,"COM1","","COM1: I/O port 0x3F8, IRQ 4",null,null],[17,"COM2","","COM2: I/O port 0x2F8, IRQ 3",null,null],[17,"COM3","","COM3: I/O port 0x3E8, IRQ 4",null,null],[17,"COM4","","COM4: I/O port 0x2E8, IRQ 3",null,null],[11,"fg","","Creates a color attribute with `fg` foreground and default…",99,[[["serialcolor",4]],["serialattributes",3]]],[11,"fg_bg","","Creates a color attribute with `fg` foreground and `bg`…",99,[[["serialcolor",4]],["serialattributes",3]]],[11,"default","","Creates a color attribute with default foreground and…",99,[[],["serialattributes",3]]],[11,"new","","Creates a COM port from it\'s base IO address.",100,[[["comport",3]],[["pio",3],["serialinternal",3]]]],[11,"send_string","","Outputs a string to this COM.",100,[[]]],[11,"force_unlock","","Re-take the lock protecting multiple access to the device.",102,[[]]],[0,"lapic","sunrise_kernel::devices","Local APIC driver.",null,null],[3,"LocalApicRegister","sunrise_kernel::devices::lapic","Local APIC Registers are 128-bit wide, with the 32 lower…",null,null],[12,"0","","",103,null],[12,"1","","",103,null],[3,"LocalApicVersion","","The version and associated metadata of a Local APIC are…",null,null],[12,"0","","",104,null],[3,"LocalVector","","Allows software to specify the manner in which the local…",null,null],[12,"0","","",105,null],[3,"SpuriousInterrupt","","See chapter 10.9: Spurious Interrupt",null,null],[12,"0","","",106,null],[3,"Error","","Contains the set of errors the LAPIC has encountered while…",null,null],[12,"bits","","",107,null],[3,"LocalApicInternal","","Local APIC Register structure.",null,null],[12,"reserved_000","","",108,null],[12,"reserved_010","","",108,null],[12,"local_apic_id","","Unique ID of this Local APIC. May also be used as a way to…",108,null],[12,"local_apic_version","","Can be used to identify the APIC version. In addition, the…",108,null],[12,"reserved_040","","",108,null],[12,"reserved_050","","",108,null],[12,"reserved_060","","",108,null],[12,"reserved_070","","",108,null],[12,"task_priority","","The task priority allows software to set a priority…",108,null],[12,"arbitration_priority","","Priority used for lowest-priority arbitration.",108,null],[12,"processor_priority","","The processor-priority class determines the priority…",108,null],[12,"end_of_interrupt","","For all interrupts except those delivered with the NMI,…",108,null],[12,"remote_read","","Only available on Nahalem CPUs. Undocumented...",108,null],[12,"logical_destination","","Upon receiving an interrupt that was sent using logical…",108,null],[12,"destination_format","","See chapter 10.6.2.2: Logical Destination Mode",108,null],[12,"spurious_interrupt_vector","","A special situation may occur when a processor raises its…",108,null],[12,"in_service0","","See [LocalApic::in_service()] documentation.",108,null],[12,"in_service1","","See [LocalApic::in_service()] documentation.",108,null],[12,"in_service2","","See [LocalApic::in_service()] documentation.",108,null],[12,"in_service3","","See [LocalApic::in_service()] documentation.",108,null],[12,"in_service4","","See [LocalApic::in_service()] documentation.",108,null],[12,"in_service5","","See [LocalApic::in_service()] documentation.",108,null],[12,"in_service6","","See [LocalApic::in_service()] documentation.",108,null],[12,"in_service7","","See [LocalApic::in_service()] documentation.",108,null],[12,"trigger_mode0","","See [LocalApic::trigger_mode()] documentation.",108,null],[12,"trigger_mode1","","See [LocalApic::trigger_mode()] documentation.",108,null],[12,"trigger_mode2","","See [LocalApic::trigger_mode()] documentation.",108,null],[12,"trigger_mode3","","See [LocalApic::trigger_mode()] documentation.",108,null],[12,"trigger_mode4","","See [LocalApic::trigger_mode()] documentation.",108,null],[12,"trigger_mode5","","See [LocalApic::trigger_mode()] documentation.",108,null],[12,"trigger_mode6","","See [LocalApic::trigger_mode()] documentation.",108,null],[12,"trigger_mode7","","See [LocalApic::trigger_mode()] documentation.",108,null],[12,"interrupt_request0","","See [LocalApic::interrupt_request_register()] documentation.",108,null],[12,"interrupt_request1","","See [LocalApic::interrupt_request_register()] documentation.",108,null],[12,"interrupt_request2","","See [LocalApic::interrupt_request_register()] documentation.",108,null],[12,"interrupt_request3","","See [LocalApic::interrupt_request_register()] documentation.",108,null],[12,"interrupt_request4","","See [LocalApic::interrupt_request_register()] documentation.",108,null],[12,"interrupt_request5","","See [LocalApic::interrupt_request_register()] documentation.",108,null],[12,"interrupt_request6","","See [LocalApic::interrupt_request_register()] documentation.",108,null],[12,"interrupt_request7","","See [LocalApic::interrupt_request_register()] documentation.",108,null],[12,"error_status","","The local APIC records errors detected during interrupt…",108,null],[12,"reserved_290","","",108,null],[12,"reserved_2a0","","",108,null],[12,"reserved_2b0","","",108,null],[12,"reserved_2c0","","",108,null],[12,"reserved_2d0","","",108,null],[12,"reserved_2e0","","",108,null],[12,"lvt_corrected_machine_interrupt","","Specifies interrupt delivery when an overflow condition of…",108,null],[12,"interrupt_command_register0","","See [LocalApic::send_interrupt_command()] documentation.",108,null],[12,"interrupt_command_register1","","See [LocalApic::send_interrupt_command()] documentation.",108,null],[12,"lvt_timer","","Specifies interrupt delivery when the APIC timer signals…",108,null],[12,"lvt_thermal_sensor","","Specifies interrupt delivery when the thermal sensor…",108,null],[12,"lvt_performance_monitoring_counter","","Specifies interrupt delivery when a performance counter…",108,null],[12,"lvt_lint0","","Specifies interrupt delivery when an interrupt is signaled…",108,null],[12,"lvt_lint1","","Specifies interrupt delivery when an interrupt is signaled…",108,null],[12,"lvt_error","","Specifies interrupt delivery when the APIC detects an…",108,null],[12,"initial_count","","Initial count used by the APIC Timer.",108,null],[12,"current_count","","Current count used by the APIC Timer.",108,null],[12,"reserved_3a0","","",108,null],[12,"reserved_3b0","","",108,null],[12,"reserved_3c0","","",108,null],[12,"reserved_3d0","","",108,null],[12,"divide_configuration","","Divide configuration used by the APIC timer.",108,null],[12,"reserved_3f0","","",108,null],[3,"LocalApic","","LocalApic driver.",null,null],[12,"internal","","Pointer to the LocalApic registers.",109,null],[4,"DeliveryMode","","Specifies how the APICs listed in the destination field…",null,null],[13,"Fixed","","Delivers the interrupt specified in the vector field.",110,null],[13,"SMI","","Delivers an SMI interrupt to the processor core through…",110,null],[13,"NMI","","Delivers an NMI interrupt to the processor. The vector…",110,null],[13,"INIT","","Delivers an INIT request to the processor core, which…",110,null],[13,"ExtINT","","Causes the processor to respond to the interrupt as if the…",110,null],[13,"Unknown","","Unknown delivery mode encountered.",110,null],[4,"TimerMode","","Selects the Timer Mode of the LVT Timer.",null,null],[13,"OneShot","","One-shot mode using a count-down value.",111,null],[13,"Periodic","","Periodic mode reloading a count-down value.",111,null],[13,"TscDeadline","","TSC-Deadline mode using absolute target value in…",111,null],[13,"Reserved","","Reserved value, might be used in later revision.",111,null],[11,"version","","The version numbers of the local APIC:",104,[[]]],[11,"max_lvt_entry","","Shows the number of LVT entries minus 1.",104,[[]]],[11,"can_suppress_eoi_broadcast","","Indicates whether software can inhibit the broadcast of…",104,[[]]],[11,"vector","","Interrupt vector number.",105,[[]]],[11,"set_vector","","Interrupt vector number.",105,[[]]],[11,"delivery_mode","","Specifies the type of interrupt to be sent to the…",105,[[],["deliverymode",4]]],[11,"set_delivery_mode","","Specifies the type of interrupt to be sent to the…",105,[[["deliverymode",4]]]],[11,"delivery_status","","Indicates the interrupt delivery status, as follows:",105,[[]]],[11,"polarity","","Specifies the polarity of the corresponding interrupt pin:…",105,[[]]],[11,"set_polarity","","Specifies the polarity of the corresponding interrupt pin:…",105,[[]]],[11,"remote_irr","","For fixed mode, level-triggered interrupts; this flag is…",105,[[]]],[11,"trigger_mode","","Selects the trigger mode for the local LINT0 and LINT1…",105,[[]]],[11,"set_trigger_mode","","Selects the trigger mode for the local LINT0 and LINT1…",105,[[]]],[11,"masked","","Interrupt mask: (`false`) enables reception of the…",105,[[]]],[11,"set_masked","","Interrupt mask: (`false`) enables reception of the…",105,[[]]],[11,"timer_mode","","Selects timer mode. See [TimerMode] for possible values.",105,[[],["timermode",4]]],[11,"set_timer_mode","","Selects timer mode. See [TimerMode] for possible values.",105,[[["timermode",4]]]],[11,"spurious_vector","","Determines the vector number to be delivered to the…",106,[[]]],[11,"set_spurious_vector","","Determines the vector number to be delivered to the…",106,[[]]],[11,"apic_software_enable","","Allows software to temporarily enable (1) or disable (0)…",106,[[]]],[11,"set_apic_software_enable","","Allows software to temporarily enable (1) or disable (0)…",106,[[]]],[11,"focus_processor_checking","","Determines if focus processor checking is enabled when…",106,[[]]],[11,"suppress_eoi_broadcast","","Determines whether an EOI for a level-triggered interrupt…",106,[[]]],[11,"set_suppress_eoi_broadcast","","Determines whether an EOI for a level-triggered interrupt…",106,[[]]],[18,"SEND_CHECKSUM_ERROR","","Set when the local APIC detects a checksum error for a…",107,null],[18,"RECEIVE_CHECKSUM_ERROR","","Set when the local APIC detects a checksum error for a…",107,null],[18,"SEND_ACCEPT_ERROR","","Set when the local APIC detects that a message it sent was…",107,null],[18,"RECEIVE_ACCEPT_ERROR","","Set when the local APIC detects that the message it…",107,null],[18,"REDIRECTABLE_IPI","","Set when the local APIC detects an attempt to send an IPI…",107,null],[18,"SEND_ILLEGAL_VECTOR","","Set when the local APIC detects an illegal vector (one in…",107,null],[18,"RECEIVE_ILLEGAL_VECTOR","","Set when the local APIC detects an illegal vector (one in…",107,null],[18,"ILLEGAL_REGISTER_ADDRESS","","Set when the local APIC is in xAPIC mode and software…",107,null],[11,"empty","","Returns an empty set of flags",107,[[],["error",3]]],[11,"all","","Returns the set containing all flags.",107,[[],["error",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",107,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",107,[[],[["error",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",107,[[],["error",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",107,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",107,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",107,[[["error",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",107,[[["error",3]]]],[11,"insert","","Inserts the specified flags in-place.",107,[[["error",3]]]],[11,"remove","","Removes the specified flags in-place.",107,[[["error",3]]]],[11,"toggle","","Toggles the specified flags in-place.",107,[[["error",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",107,[[["error",3]]]],[11,"new","","Create a new LocalApic at the specified address.",109,[[["physicaladdress",3]]]],[11,"enable","","10.4.3 Enabling or Disabling the Local APIC",109,[[]]],[11,"acknowledge","","Acknowledge the last interrupt, signaling an end of…",109,[[]]],[11,"local_apic_id","","Unique ID of this Local APIC. May also be used as a way to…",109,[[]]],[11,"in_service","","The ISR contains interrupt requests that have been…",109,[[]]],[11,"trigger_mode","","The trigger mode register (TMR) indicates the trigger mode…",109,[[]]],[11,"interrupt_request_register","","The IRR contains the active interrupt requests that have…",109,[[]]],[11,"send_interrupt_command","","Sends an IPI.",109,[[]]],[0,"ioapic","sunrise_kernel::devices","82093AA I/O Advanced Programmable Interrupt Controller…",null,null],[3,"IoApicInternal","sunrise_kernel::devices::ioapic","Internal IO-APIC registers.",null,null],[12,"addr_reg","","Address register.",112,null],[12,"padding","","12 bytes of padding.",112,null],[12,"data_reg","","Data register.",112,null],[3,"IoApic","","See module level documentation",null,null],[12,"internal","","Pointer to the IO-APIC device registers.",113,null],[12,"interrupt_base","","Start of the IRQ range handled by this IO-APIC device.…",113,null],[12,"redirection_entry_count","","Number of entries this IO-APIC device can handled. Cached.",113,null],[3,"RedirectionEntry","","Description of a Redirection Entry in the IO-APIC. Unlike…",null,null],[12,"0","","",114,null],[4,"DeliveryMode","","Specifies how the APICs listed in the destination field…",null,null],[13,"Fixed","","Deliver the signal on the INTR signal of all processor…",115,null],[13,"LowestPriority","","Deliver the signal on the INTR signal of the processor…",115,null],[13,"SMI","","System Management Interrupt. A delivery mode equal to SMI…",115,null],[13,"NMI","","Deliver the signal on the NMI signal of all processor…",115,null],[13,"INIT","","Deliver the signal to all processor cores listed in the…",115,null],[13,"ExtINT","","Deliver the signal to the INTR signal of all processor…",115,null],[13,"Unknown","","Unknown delivery mode encountered.",115,null],[11,"interrupt_vector","","The vector field is an 8 bit field containing the…",114,[[]]],[11,"set_interrupt_vector","","The vector field is an 8 bit field containing the…",114,[[]]],[11,"delivery_mode","","The Delivery Mode is a 3 bit field that specifies how the…",114,[[],["deliverymode",4]]],[11,"set_delivery_mode","","The Delivery Mode is a 3 bit field that specifies how the…",114,[[["deliverymode",4]]]],[11,"destination_mode","","This field determines the interpretation of the…",114,[[]]],[11,"set_destination_mode","","This field determines the interpretation of the…",114,[[]]],[11,"delivery_status","","The Delivery Status bit contains the current status of the…",114,[[]]],[11,"interrupt_input_pin_polarity","","This bit specifies the polarity of the interrupt signal.…",114,[[]]],[11,"set_interrupt_input_pin_polarity","","This bit specifies the polarity of the interrupt signal.…",114,[[]]],[11,"remote_irr","","This bit is used for level triggered interrupts. Its…",114,[[]]],[11,"trigger_mode","","The trigger mode field indicates the type of signal on the…",114,[[]]],[11,"set_trigger_mode","","The trigger mode field indicates the type of signal on the…",114,[[]]],[11,"interrupt_mask","","When this bit is 1, the interrupt signal is masked.…",114,[[]]],[11,"set_interrupt_mask","","When this bit is 1, the interrupt signal is masked.…",114,[[]]],[11,"destination_field","","If the Destination Mode of this entry is Physical Mode,…",114,[[]]],[11,"set_destination_field","","If the Destination Mode of this entry is Physical Mode,…",114,[[]]],[11,"new","","Creates a new IO-APIC device at the given Physical…",113,[[["physicaladdress",3]],["ioapic",3]]],[11,"read","","Reads an u32 at the specified DWORD offset.",113,[[]]],[11,"write","","Writes an u32 at the specified DWORD offset.",113,[[]]],[11,"ioapic_id","","This register contains the 4-bit APIC ID. The ID serves as…",113,[[]]],[11,"version","","Gets the version number of this IO-APIC device. This is…",113,[[]]],[11,"interrupt_base","","Start of the IRQ range handled by this IO-APIC device.…",113,[[]]],[11,"redirection_entry_count","","Gets the number of redirection entries in the I/O…",113,[[]]],[11,"arbitration_id","","Gets the bus arbitration priority for the IOAPIC. This…",113,[[]]],[11,"redirection_entry","","Gets the [RedirectionEntry] configuration of the specified…",113,[[],["redirectionentry",3]]],[11,"set_redirection_entry","","Configure the given pin with a [RedirectionEntry].",113,[[["redirectionentry",3]]]],[0,"sync","sunrise_kernel","Synchronization primitives used by the kernel",null,null],[3,"SpinRwLock","sunrise_kernel::sync","A reader-writer lock",null,null],[12,"lock","","",116,null],[12,"data","","",116,null],[3,"SpinRwLockReadGuard","","A guard from which the protected data can be read",null,null],[12,"lock","","",117,null],[12,"data","","",117,null],[3,"SpinRwLockWriteGuard","","A guard to which the protected data can be written",null,null],[12,"lock","","",118,null],[12,"data","","",118,null],[3,"Once","","A synchronization primitive which can be used to run a…",null,null],[12,"state","","",119,null],[12,"data","","",119,null],[3,"SpinLockGuard","","A guard to which the protected data can be accessed",null,null],[12,"lock","","",120,null],[12,"data","","",120,null],[0,"spin_lock_irq","","Lock disabling IRQs while held",null,null],[3,"SpinLockIRQ","sunrise_kernel::sync::spin_lock_irq","SpinLock that disables IRQ.",null,null],[12,"internal","","SpinLock we wrap.",121,null],[3,"SpinLockIRQGuard","","The SpinLockIrq lock guard.",null,null],[12,"0","","",122,null],[12,"1","","",122,null],[5,"permanently_disable_interrupts","","Permanently disables the interrupts. Forever.",null,[[]]],[11,"new","","Creates a new spinlockirq wrapping the supplied data.",121,[[],["spinlockirq",3]]],[11,"into_inner","","Consumes this SpinLockIRQ, returning the underlying data.",121,[[]]],[11,"lock","","Disables interrupts and locks the mutex.",121,[[],["spinlockirqguard",3]]],[11,"try_lock","","Disables interrupts and locks the mutex.",121,[[],[["spinlockirqguard",3],["option",4]]]],[11,"force_unlock","","Force unlocks the lock.",121,[[]]],[0,"spin_lock","sunrise_kernel::sync","Lock that panics when used in a IRQ context",null,null],[3,"SpinLockGuard","sunrise_kernel::sync::spin_lock","A guard to which the protected data can be accessed",null,null],[12,"lock","","",120,null],[12,"data","","",120,null],[3,"SpinLock","","This type provides mutual exclusion based on spinning. It…",null,null],[12,"0","","",123,null],[11,"new","","Creates a new spinlock wrapping the supplied data.",123,[[],["spinlock",3]]],[11,"into_inner","","Consumes this spinlock, returning the underlying data.",123,[[]]],[11,"lock","","Locks the spinlock and returns a guard.",123,[[],["spinlockguard",3]]],[11,"force_unlock","","Force unlock the spinlock. If the lock isn\'t held, this is…",123,[[]]],[11,"try_lock","","Tries to lock the spinlock. If it is already locked, it…",123,[[],[["spinlockguard",3],["option",4]]]],[0,"mutex","sunrise_kernel::sync","Preemptive Mutex",null,null],[3,"Mutex","sunrise_kernel::sync::mutex","A mutual exclusion primitive useful for protecting shared…",null,null],[12,"data","","The data that we\'re protecting.",124,null],[12,"inner","","The struct responsible for arbitrating accesses to `.data`.",124,null],[3,"MutexInner","","The type responsible of actually performing the locking of…",null,null],[12,"spin_lock","","A spin lock arbitrating accesses to the mutex\'s state.",125,null],[3,"MutexInnerInner","","The bookkeeping of a Mutex. Knows the current owner, and…",null,null],[12,"owner","","The owner of this Mutex. None means free.",126,null],[12,"waiters","","Queue of threads waiting on this mutex.",126,null],[3,"MutexGuard","","An RAII implementation of a \\\"scoped lock\\\" of a mutex. When…",null,null],[12,"__lock","","Reference to the Mutex we\'ll unlock when dropped.",127,null],[12,"__phantom","","Raw pointer just to make MutexGuard !Send.",127,null],[6,"TryLockResult","","A type alias for the result of a nonblocking locking method.",null,null],[11,"new","","Creates a new mutex in an unlocked state ready for use.",124,[[],["mutex",3]]],[11,"into_inner","","Consumes this mutex, returning the underlying data.",124,[[]]],[11,"lock","","Acquires a mutex, blocking the current kernel thread until…",124,[[],["mutexguard",3]]],[11,"try_lock","","Attempts to acquire this lock.",124,[[],[["trylockresult",6],["mutexguard",3]]]],[11,"get_mut","","Returns a mutable reference to the underlying data.",124,[[]]],[11,"new","","Create an MutexGuard.",127,[[["mutex",3]],["mutexguard",3]]],[11,"try_lock","","Try to obtain the mutex, without preempting.",125,[[]]],[11,"raw_lock","","Locks the mutex blocking the current thread until it is…",125,[[]]],[11,"raw_unlock","","Unlocks the mutex.",125,[[]]],[7,"INTERRUPT_DISARM","sunrise_kernel::sync","Boolean to [spin_lock_irq::permanently_disable_interrupts].",null,null],[8,"Lock","","Abstraction around various kind of locks.",null,null],[10,"lock","","Locks the lock until the returned guard is dropped. The…",128,[[]]],[0,"timer","sunrise_kernel","The core timing of Sunrise.",null,null],[3,"KernelTimerInfo","sunrise_kernel::timer","This represent the information to derive all internal…",null,null],[12,"oscillator_frequency","","The frequency of the oscillator used as primary source of…",129,null],[12,"irq_period_ns","","The IRQ period used on this timer in nanoseconds.",129,null],[12,"irq_number","","The IRQ number that the timer use.",129,null],[3,"IRQTimer","","A stream of event that trigger every `ns` amount of…",null,null],[12,"every_ns","","Approximation of number of ns spent between triggers.",130,null],[12,"irq_period_ns","","IRQ event period in nanoseconds.",130,null],[12,"parent_event","","The IRQ that we wait on.",130,null],[12,"reset_value","","The reset value of `.countdown_value`.",130,null],[12,"countdown_value","","Number of IRQ triggers to wait for. Derived from…",130,null],[5,"set_kernel_timer_info","","Set the information required for Sunrise timer to work.",null,[[]]],[5,"wait_ns","","Returns a stream of event that trigger every `ns` amount…",null,[[]]],[7,"KERNEL_TIMER_INFO","","Stores the information needed for Sunrise\'s internal timing.",null,null],[11,"new","","Create a new IRQ timer instance from the time to wait (in…",130,[[]]],[0,"process","sunrise_kernel","Process",null,null],[3,"ProcessCapabilities","sunrise_kernel::process","Capabilities of a process.",null,null],[12,"syscall_mask","","Bitmask of syscall access controls. Should be accessed…",131,null],[12,"irq_access_mask","","Bitmask of allowed interrupts. Should be accessed through…",131,null],[12,"ioports","","A vector of readable IO ports.",131,null],[3,"ProcessStateData","","Data related to the (user-visible) state the current…",null,null],[12,"signaled","","Whether the process is currently in a signaled state. Set…",132,null],[12,"state","","The current state of the process.",132,null],[12,"waiting_threads","","Threads waiting on this process to get signaled.",132,null],[12,"thread_maternity","","An array of the created but not yet started threads.",132,null],[3,"ProcessStruct","","The struct representing a process. There\'s one for every…",null,null],[12,"pid","","The unique id of this process.",133,null],[12,"name","","A name for this process.",133,null],[12,"pmemory","","The memory view of this process. Shared among the threads.",133,null],[12,"phandles","","The handles of this process. Shared among the threads.",133,null],[12,"threads","","The threads of this process. A ProcessStruct with no…",133,null],[12,"entrypoint","","The entrypoint of the main thread.",133,null],[12,"capabilities","","Permissions of this process.",133,null],[12,"state","","The state the process is currently in.",133,null],[12,"tls_manager","","Tracks used and free allocated Thread Local Storage…",133,null],[3,"ThreadStruct","","The struct representing a thread. A process may own…",null,null],[12,"state","","The state of this thread.",134,null],[12,"kstack","","The kernel stack it uses for handling syscalls/irqs.",134,null],[12,"hwcontext","","The saved hardware context, for getting it running again…",134,null],[12,"process","","The process that this thread belongs to.",134,null],[12,"tls_region","","Pointer to the Thread Local Storage region of this thread.",134,null],[12,"tls_elf","","Userspace\'s elf `Thread Pointer`.",134,null],[12,"userspace_hwcontext","","Userspace hardware context of this thread.",134,null],[12,"state_event","","Thread state event",134,null],[3,"ThreadStateEvent","","The underlying shared object of a [Weak].",null,null],[12,"waiting_threads","","List of threads waiting on this thread to exit. When this…",135,null],[3,"HandleTable","","Holds the table associating userspace handle numbers to a…",null,null],[12,"table","","Internal mapping from a handle number to a Kernel Object.",136,null],[12,"counter","","The next handle\'s ID.",136,null],[4,"Handle","","A handle to a userspace-accessible resource.",null,null],[13,"InterruptEvent","","A special ReadableEvent that is triggered automatically…",137,null],[13,"ReadableEvent","","An event on which we can wait, triggered by a WritableEvent.",137,null],[13,"WritableEvent","","Trigger for an associated ReadableEvent.",137,null],[13,"ServerPort","","The server side of an IPC port. See [crate::ipc::port] for…",137,null],[13,"ClientPort","","The client side of an IPC port. See [crate::ipc::port] for…",137,null],[13,"ServerSession","","The server side of an IPC session. See…",137,null],[13,"ClientSession","","The client side of an IPC session. See…",137,null],[13,"Thread","","A thread.",137,null],[13,"Process","","A process.",137,null],[13,"SharedMemory","","A shared memory region. The handle holds on to the…",137,null],[4,"ThreadState","","The state of a thread.",null,null],[13,"Paused","","Not in the scheduled queue, waiting for an event.",138,null],[13,"Running","","Currently on the CPU.",138,null],[13,"TerminationPending","","Dying, will be unscheduled and dropped at syscall boundary.",138,null],[13,"Scheduled","","Scheduled to be running.",138,null],[0,"thread_local_storage","","TLS manager",null,null],[3,"TLSPage","sunrise_kernel::process::thread_local_storage","Manages a page containing 8 TLS",null,null],[12,"page_address","","Address of the page, in UserLand.",139,null],[12,"usage","","Bitmap indicating if the TLS is in use (`1`) or free (`0`).",139,null],[3,"TLSManager","","TLS allocator",null,null],[12,"tls_pages","","Vec of tracked pages. When all slots are occupied, we…",140,null],[11,"new","","Allocates a new page holing 8 TLS.",139,[[["processmemory",3]],[["result",4],["kernelerror",4]]]],[11,"allocate_tls","","Finds an available slot in the TLSPage, bzero it, marks it…",139,[[],[["virtualaddress",3],["option",4]]]],[11,"free_tls","","Marks a TLS in this TLSPage as free so it can be used by…",139,[[["virtualaddress",3]]]],[11,"allocate_tls","","Allocates a new TLS.",140,[[["processmemory",3]],[["virtualaddress",3],["kernelerror",4],["result",4]]]],[11,"free_tls","","Mark this TLS as free, so it can be re-used by future…",140,[[["virtualaddress",3]]]],[0,"capabilities","sunrise_kernel::process","Process Capability handling",null,null],[3,"ProcessCapabilities","sunrise_kernel::process::capabilities","Capabilities of a process.",null,null],[12,"syscall_mask","","Bitmask of syscall access controls. Should be accessed…",131,null],[12,"irq_access_mask","","Bitmask of allowed interrupts. Should be accessed through…",131,null],[12,"ioports","","A vector of readable IO ports.",131,null],[3,"MaskPrinter","","Wrapper around a bitfield that only prints the indices of…",null,null],[12,"0","","",141,null],[17,"KERNEL_FLAGS","","Allowed CPUID and thread priorities.",null,null],[17,"SYSCALL_MASK","","Shifted mask of allowed syscalls.",null,null],[17,"MAP_IO_OR_NORMAL_RANGE","","Map an IO or physical memory page into process address…",null,null],[17,"MAP_NORMAL_PAGE","","Map a normal page.",null,null],[17,"INTERRUPT_PAIR","","Allow creating an interrupt for the given IRQ pair.",null,null],[17,"APPLICATION_TYPE","","Type of application (sysmodule, applet, application)",null,null],[17,"KERNEL_RELEASE_VERSION","","Minimum kernel release.",null,null],[17,"HANDLE_TABLE_SIZE","","Max amount of handle for the process.",null,null],[17,"DEBUG_FLAGS","","Flags allowing app to debug or be debugged.",null,null],[17,"IO_PORTS_ALLOWED","","IOPorts the process is allowed to talk to",null,null],[17,"MAX_SVC","","The highest defined svc.",null,null],[17,"KACS_NO_DUPLICATES","","Mask of kernel capabilities that cannot appear twice in a…",null,null],[11,"parse_kcaps","sunrise_kernel::process","Parse the kernel capabilities, in the NPDM format. More…",131,[[],[["processcapabilities",3],["kernelerror",4],["result",4]]]],[7,"PROCESS_LIST","","List of processes currently running on the system.",null,null],[7,"NEXT_PROCESS_ID","","Next available PID.",null,null],[11,"set_state","","Sets the state to the given new state, and signal the…",132,[[["processstate",3]]]],[11,"signal","","Set the process to the signaled state, and wake up any…",132,[[]]],[11,"signal","","Signals the event, waking up any thread waiting on its…",135,[[]]],[11,"as_waitable","","Gets the handle as a [Waitable], or return a…",137,[[],[["userspaceerror",3],["result",4],["waitable",8]]]],[11,"as_client_port","","Casts the handle as a [ClientPort], or returns a…",137,[[],[["result",4],["clientport",3],["userspaceerror",3]]]],[11,"as_server_session","","Casts the handle as a [ServerSession], or returns a…",137,[[],[["userspaceerror",3],["serversession",3],["result",4]]]],[11,"as_client_session","","Casts the handle as a [ClientSession], or returns a…",137,[[],[["result",4],["clientsession",3],["userspaceerror",3]]]],[11,"as_thread_handle","","Casts the handle as a Weak<[ThreadStruct]>, or returns a…",137,[[],[["result",4],["weak",3],["userspaceerror",3]]]],[11,"as_process","","Casts the handle as an Arc<[ProcessStruct]>, or returns a…",137,[[],[["userspaceerror",3],["arc",3],["result",4]]]],[11,"as_writable_event","","Casts the handle as an Arc<[WritableEvent]> if the handle…",137,[[],[["result",4],["writableevent",3],["userspaceerror",3]]]],[11,"as_readable_event","","Casts the handle as an Arc<[ReadableEvent]>, or returns a…",137,[[],[["result",4],["readableevent",3],["userspaceerror",3]]]],[11,"as_shared_memory","","Casts the handle as an…",137,[[],[["userspaceerror",3],["result",4],["arc",3]]]],[11,"add_handle","","Add a handle to the handle table, returning the userspace…",136,[[["handle",4],["arc",3]]]],[11,"get_handle","","Gets the Kernel Handle associated with the given userspace…",136,[[],[["userspaceerror",3],["result",4],["arc",3]]]],[11,"get_handle_no_alias","","Gets the Kernel Handle associated with the given userspace…",136,[[],[["userspaceerror",3],["result",4],["arc",3]]]],[11,"delete_handle","","Deletes the mapping from the given userspace handle…",136,[[],[["userspaceerror",3],["result",4],["arc",3]]]],[11,"from_primitive","","ThreadState is stored in the ThreadStruct as an…",138,[[],["threadstate",4]]],[11,"new","","Creates a new process.",133,[[["option",4],["procinfo",3]],[["result",4],["arc",3],["kernelerror",4]]]],[11,"start","","Creates the initial thread, allocates the stack, and…",133,[[["arc",3]],[["result",4],["userspaceerror",3]]]],[11,"state","","Gets the state of this process.",133,[[],["processstate",3]]],[11,"clear_signal","","Clears the signaled state of this process.",133,[[],[["result",4],["kernelerror",4]]]],[11,"create_first_process","","Creates the very first process at boot. Called internally…",133,[[],["processstruct",3]]],[11,"kill_current_process","","Kills the current process by killing all of its threads.",133,[[]]],[11,"kill_subthreads","","Kill all the subthreads of this process, and set the state…",133,[[["mutexguard",3],["processstatedata",3]]]],[11,"terminate","","Kills the given process, terminating the execution of all…",133,[[],[["result",4],["kernelerror",4]]]],[11,"new","","Creates a new thread.",134,[[["virtualaddress",3],["arc",3],["option",4]],[["result",4],["weak",3],["kernelerror",4]]]],[11,"new_locked","","See [ThreadStruct::new]. Takes the ProcessStruct.data…",134,[[["virtualaddress",3],["arc",3],["processstatedata",3],["option",4]],[["result",4],["weak",3],["kernelerror",4]]]],[11,"create_first_thread","","Creates the very first process and thread at boot.",134,[[],[["threadstruct",3],["arc",3]]]],[11,"start_locked","","See [ThreadStruct::start]. Takes the ProcessStruct.data…",134,[[["arc",3],["processstatedata",3]],[["result",4],["kernelerror",4]]]],[11,"start","","Takes a reference to a thread, removes it from the…",134,[[["weak",3]],[["result",4],["kernelerror",4]]]],[11,"exit","","Sets the thread to the `Exited` state.",134,[[["arc",3]]]],[0,"scheduler","sunrise_kernel","The Completly Unfair Scheduler",null,null],[5,"try_get_current_thread","sunrise_kernel::scheduler","Gets the current ThreadStruct, incrementing its refcount.…",null,[[],[["option",4],["arc",3]]]],[5,"get_current_thread","","Gets the current ThreadStruct, incrementing its refcount.",null,[[],[["threadstruct",3],["arc",3]]]],[5,"try_get_current_process","","Gets the ProcessStruct of the current thread, incrementing…",null,[[],[["option",4],["arc",3]]]],[5,"get_current_process","","Gets the ProcessStruct of the current thread, incrementing…",null,[[],[["processstruct",3],["arc",3]]]],[5,"set_current_thread","","Sets the current ThreadStruct.",null,[[["fnonce",8],["threadstruct",3],["arc",3]]]],[5,"add_to_schedule_queue","","Adds a thread at the end of the schedule queue, and…",null,[[["threadstruct",3],["arc",3]]]],[5,"is_in_schedule_queue","","Checks if a thread is already either in the schedule queue…",null,[[["arc",3],["spinlockirqguard",3]]]],[5,"unschedule","","Removes the current thread from the schedule queue, and…",null,[[],[["result",4],["userspaceerror",3]]]],[5,"create_first_process","","Creates the very first process at boot. The created…",null,[[]]],[5,"schedule","","Performs a process switch.",null,[[]]],[5,"find_next_thread_to_run","","Parses the queue to find the first unlocked process.…",null,[[],["option",4]]],[5,"internal_schedule","","Internal impl of the process switch, used by schedule and…",null,[[]]],[5,"scheduler_first_schedule","","The function called when a thread was scheduled for the…",null,[[["fnonce",8],["threadstruct",3],["arc",3]]]],[7,"CURRENT_THREAD","","An Arc to the currently running thread.",null,null],[7,"SCHEDULE_QUEUE","","The schedule queue",null,null],[0,"mem","sunrise_kernel","Basic functionality for dealing with memory.",null,null],[3,"PhysicalAddress","sunrise_kernel::mem","Represents a Physical address",null,null],[12,"0","","",142,null],[3,"VirtualAddress","","Represents a Virtual address",null,null],[12,"0","","",143,null],[3,"UserSpacePtr","","A pointer to read-only userspace memory. Prevents…",null,null],[12,"0","","",144,null],[3,"UserSpacePtrMut","","A pointer to read-write userspace memory. Prevents…",null,null],[12,"0","","",145,null],[3,"FatPtr","","Internal rust representation of a DST pointer.",null,null],[12,"data","","A pointer to the underlying slice.",146,null],[12,"len","","The length of the slice, in number of elements.",146,null],[5,"round_to_page","","Rounds an address to its page address",null,[[]]],[5,"round_to_page_upper","","Rounds an address to the next page address except if its…",null,[[]]],[5,"count_pages","","Counts the number of pages `size` takes",null,[[]]],[11,"addr","","Gets the address as a `usize`.",143,[[]]],[11,"addr","","Gets the address as a `usize`.",142,[[]]],[11,"checked_add","","Tries to add an offset to a PhysicalAddress, returning…",142,[[],[["option",4],["physicaladdress",3]]]],[11,"check_aligned_to","","Checks that this address meets the given alignment.",142,[[],[["result",4],["kernelerror",4]]]],[11,"floor","","Rounds down to PAGE_SIZE.",142,[[],["physicaladdress",3]]],[11,"ceil","","Rounds up PAGE_SIZE.",142,[[],["physicaladdress",3]]],[11,"checked_add","","Tries to add an offset to a VirtualAddress, returning None…",143,[[],[["virtualaddress",3],["option",4]]]],[11,"check_aligned_to","","Checks that this address meets the given alignment.",143,[[],[["result",4],["kernelerror",4]]]],[11,"floor","","Rounds down to PAGE_SIZE.",143,[[],["virtualaddress",3]]],[11,"ceil","","Rounds up PAGE_SIZE.",143,[[],["virtualaddress",3]]],[11,"from_raw_parts","","Forms a UserSpacePtr slice from a pointer and a length.…",144,[[],["userspaceptr",3]]],[11,"from_raw_parts_mut","","Forms a UserSpacePtrMut slice from a pointer and a length.…",145,[[],["userspaceptrmut",3]]],[0,"ipc","sunrise_kernel","IPC primitives",null,null],[3,"NAMED_PORTS","sunrise_kernel::ipc","",null,null],[12,"__private_field","","",147,null],[5,"create_named_port","","Creates a named port.",null,[[],[["result",4],["userspaceerror",3],["serverport",3]]]],[5,"connect_to_named_port","","Connects to a named port.",null,[[],[["result",4],["clientsession",3],["userspaceerror",3]]]],[0,"session","","IPC Sessions",null,null],[3,"SessionRequests","sunrise_kernel::ipc::session","Wrapper around the currently active session and the…",null,null],[12,"active_request","","The request currently being serviced. Sessions are…",148,null],[12,"incoming_requests","","Pending Requests.",148,null],[3,"Session","","Shared part of a Session.",null,null],[12,"internal","","Pending requests and currently active request are there.",149,null],[12,"accepters","","List of threads waiting for a request.",149,null],[12,"servercount","","Count of live ServerSessions. Once it drops to 0, all…",149,null],[3,"ClientSession","","The client side of a Session.",null,null],[12,"0","","",150,null],[3,"ServerSession","","The server side of a Session.",null,null],[12,"0","","",151,null],[3,"MsgPackedHdr","","Represenens the header of an HIPC command.",null,null],[12,"0","","",152,null],[3,"HandleDescriptorHeader","","Part of an HIPC command. Sent only when…",null,null],[12,"0","","",153,null],[3,"Request","","An incoming IPC request.",null,null],[12,"sender_buf","","Address of the mirror-mapped (in-kernel) IPC buffer.…",154,null],[12,"sender_bufsize","","Size of the IPC buffer.",154,null],[12,"sender","","Thread that sent this request. It should be woken up when…",154,null],[12,"answered","","A really really broken excuse for a condvar. The thread…",154,null],[12,"buffers","","A/B/W buffers that were mapped during the request. We…",154,null],[3,"Buffer","","Information about a Buffer during a Request.",null,null],[12,"writable","","Is the buffer writable.",155,null],[12,"source_addr","","The source virtual address of the buffer.",155,null],[12,"dest_addr","","The destination virtual address of the buffer.",155,null],[12,"size","","The size of the buffer.",155,null],[4,"CBufBehavior","","Defines how to handle X Buffer descriptors based on the C…",null,null],[13,"Disabled","","No C Buffers are available. Presence of X Buffers should…",156,null],[13,"Inlined","","X Buffers should be copied after the Raw Data.",156,null],[13,"Single","","X Buffers should be copied sequentially to the C Buffer…",156,null],[13,"Numbered","","X Buffers should be copied to the appropriate C Buffer…",156,null],[5,"new","","Create a new Session pair. Those sessions are linked to…",null,[[]]],[5,"buf_map","","Send an IPC Buffer from the sender into the receiver.",null,[[["processmemory",3],["mappingaccessrights",3],["vec",3]],[["result",4],["userspaceerror",3]]]],[5,"buf_unmap","","Unmap an IPC Buffer from the receiver.",null,[[["buffer",3],["processmemory",3]],[["result",4],["userspaceerror",3]]]],[5,"find_c_descriptors","","Efficiently finds C Descriptor in a message.",null,[[],[["cbufbehavior",4],["kernelerror",4],["result",4]]]],[5,"pass_message","","Send a message from the sender to the receiver. This is…",null,[[["processmemory",3],["cbufbehavior",4],["mutexguard",3],["threadstruct",3],["vec",3],["arc",3]],[["result",4],["userspaceerror",3]]]],[11,"ty","","",152,[[]]],[11,"num_x_descriptors","","",152,[[]]],[11,"set_num_x_descriptors","","",152,[[]]],[11,"num_a_descriptors","","",152,[[]]],[11,"set_num_a_descriptors","","",152,[[]]],[11,"num_b_descriptors","","",152,[[]]],[11,"set_num_b_descriptors","","",152,[[]]],[11,"num_w_descriptors","","",152,[[]]],[11,"set_num_w_descriptors","","",152,[[]]],[11,"raw_section_size","","",152,[[]]],[11,"set_raw_section_size","","",152,[[]]],[11,"c_descriptor_flags","","",152,[[]]],[11,"set_c_descriptor_flags","","",152,[[]]],[11,"enable_handle_descriptor","","",152,[[]]],[11,"set_enable_handle_descriptor","","",152,[[]]],[11,"send_pid","","",153,[[]]],[11,"set_send_pid","","",153,[[]]],[11,"num_copy_handles","","",153,[[]]],[11,"set_num_copy_handles","","",153,[[]]],[11,"num_move_handles","","",153,[[]]],[11,"set_num_move_handles","","",153,[[]]],[11,"client","","Returns a ClientPort from this Port.",149,[[["arc",3]],["clientsession",3]]],[11,"server","","Returns a ServerSession from this Port.",149,[[["arc",3]],["serversession",3]]],[11,"send_request","","Send an IPC request through the client pipe. Takes a…",150,[[["userspaceptrmut",3]],[["result",4],["userspaceerror",3]]]],[11,"receive","","Receive an IPC request through the server pipe. Takes a…",151,[[["userspaceptrmut",3]],[["result",4],["userspaceerror",3]]]],[11,"reply","","Replies to the currently active IPC request on the server…",151,[[["userspaceptr",3]],[["result",4],["userspaceerror",3]]]],[0,"port","sunrise_kernel::ipc","IPC Port",null,null],[3,"Port","sunrise_kernel::ipc::port","An endpoint which can be connected to.",null,null],[12,"incoming_connections","","List of incoming connection requests.",157,null],[12,"accepters","","List of threads waiting for a connection request.",157,null],[12,"servercount","","Number of active ServerPort. When it drops to 0, future…",157,null],[3,"ClientPort","","The client side of a Port.",null,null],[12,"0","","",158,null],[3,"ServerPort","","The server side of a Port.",null,null],[12,"0","","",159,null],[3,"IncomingConnection","","Represents a connection request from the creator thread.",null,null],[12,"session","","Session that this connection request is for.",160,null],[12,"creator","","Thread that wants to connect to this Port.",160,null],[5,"new","","Create a new Port pair. Those ports are linked to…",null,[[]]],[11,"client","","Returns a ClientPort from this Port.",157,[[["arc",3]],["clientport",3]]],[11,"server","","Returns a ServerPort from this Port.",157,[[["arc",3]],["serverport",3]]],[11,"accept","","Accept a new connection on the Port.",159,[[],[["userspaceerror",3],["serversession",3],["result",4]]]],[11,"connect","","Connects to this port.",158,[[],[["result",4],["clientsession",3],["userspaceerror",3]]]],[0,"elf_loader","sunrise_kernel","Loads Kernel Built-ins.",null,null],[3,"MappedGrubModule","sunrise_kernel::elf_loader","Represents a grub module once mapped in kernel memory",null,null],[12,"mapping_addr","","The address of the mapping, in KernelLand.",161,null],[12,"start","","The start of the module in the mapping, if it was not page…",161,null],[12,"len","","The length of the module.",161,null],[12,"elf","","The module parsed as an ElfFile.",161,null],[5,"map_grub_module","","Maps a grub module, which already lives in reserved…",null,[[["moduletag",3]],[["mappedgrubmodule",3],["kernelerror",4],["result",4]]]],[5,"get_kacs","","Gets the desired kernel access controls for a process…",null,[[["mappedgrubmodule",3]],["option",4]]],[5,"get_kip_header","","Gets the KIP Header of the provided module, found in the…",null,[[["mappedgrubmodule",3]],[["option",4],["kipheader",3]]]],[5,"load_builtin","","Loads the given kernel built-in into the given page table.…",null,[[["mappedgrubmodule",3],["processmemory",3]]]],[5,"load_segment","","Loads an elf segment by coping file_size bytes to the…",null,[[["elffile",3],["processmemory",3],["programheader",4]]]],[0,"utils","sunrise_kernel","Generic useful functions",null,null],[0,"io","sunrise_kernel::utils","The IO interface",null,null],[8,"Io","sunrise_kernel::utils::io","The Io trait allows for accessing device IO in a generic…",null,null],[16,"Value","","The width of the IO access. Should be a primitive type…",162,null],[10,"read","","Reads from this Io.",162,[[]]],[10,"write","","Writes `value` to this Io.",162,[[]]],[11,"readf","","Read from this Io, and mask the value with `flags`.",162,[[]]],[11,"writef","","Mask `value` with `flags`, and write it to this device…",162,[[]]],[3,"ReadOnly","","A read-only wrapper around an IO device.",null,null],[12,"inner","","",163,null],[3,"WriteOnly","","An Io that we can only write to.",null,null],[12,"inner","","",164,null],[3,"Pio","","Port IO accessor.",null,null],[12,"port","","The io port address.",75,null],[12,"value","","The width of the port.",75,null],[3,"Mmio","","A value that can only be accessed volatilely.",null,null],[12,"value","","The value. Can only be accessed through .read()",165,null],[0,"loop_future","sunrise_kernel::utils","Definition of the `LoopFn` combinator, implementing…",null,null],[4,"Loop","sunrise_kernel::utils::loop_future","The status of a `loop_fn` loop.",null,null],[13,"Break","","Indicates that the loop has completed with output `T`.",166,null],[13,"Continue","","Indicates that the loop function should be called again…",166,null],[3,"LoopFn","","A future implementing a tail-recursive loop.",null,null],[12,"future","","Future representing the current loop iteration.",167,null],[12,"func","","Function called on every new iteration to generate that…",167,null],[5,"loop_fn","","Creates a new future implementing a tail-recursive loop.",null,[[],["loopfn",3]]],[4,"Poll","","Indicates whether a value is available or if the current…",null,null],[13,"Ready","","Represents that a value is immediately ready.",168,null],[13,"Pending","","Represents that a value is not ready yet.",168,null],[5,"align_up","sunrise_kernel::utils","Align the address to the next alignment.",null,[[]]],[5,"align_down","","Align the address to the previous alignment.",null,[[]]],[5,"align_up_checked","","align_up, but checks if addr overflows",null,[[],["option",4]]],[5,"div_ceil","","Counts the numbers of `b` in `a`, rounding the result up.",null,[[]]],[5,"print_hexdump","","Displays memory as hexdump",null,[[]]],[5,"print_hexdump_as_if_at_addr","","Makes a hexdump of a slice, but display different…",null,[[]]],[8,"BitArrayExt","","Extension of the [BitField] trait, that adds the…",null,null],[11,"set_bits_area","","Sets a range of bits to `value` in the BitField.",169,[[["range",3]]]],[5,"bit_array_first_zero","","Returns the index of the first 0 in a bit array.",null,[[],["option",4]]],[5,"bit_array_first_one","","Returns the index of the first 1 in a bit array.",null,[[],["option",4]]],[5,"bit_array_first_count_one","","Returns the index of the first instance of count…",null,[[],["option",4]]],[5,"log2_floor","","Returns the floored base 2 logarithm of the number.",null,[[]]],[5,"log2_ceil","","Returns the ceiled base 2 logarithm of the number.",null,[[]]],[5,"cast_mut","","Cast a slice while keeping the lifetimes.",null,[[]]],[14,"enum_with_val","","Creates a fake C-like enum, where all bit values are…",null,null],[14,"initialize_to_zero","","A macro to initialize a struct directly in global.",null,null],[3,"CursorWrite","","A minimal Cursor for writing, for use in libcore.",null,null],[12,"data","","Data backing this cursor.",170,null],[12,"pos","","Position of the cursor in the data.",170,null],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",null,null],[12,"data","","Data backing this cursor.",171,null],[12,"pos","","Position of the cursor in the data.",171,null],[8,"Splittable","","A trait for things that can be splitted in two parts",null,null],[10,"split_at","","Split the given object in two at a given offset.",172,[[],[["result",4],["option",4],["kernelerror",4]]]],[11,"right_split","","Splits the given object in two at the given offset.",172,[[],[["result",4],["option",4],["kernelerror",4]]]],[0,"checks","sunrise_kernel","Checked maths functions returning useful errors.",null,null],[5,"check_size_aligned","sunrise_kernel::checks","Checks that a size meets the given alignment.",null,[[],[["result",4],["kernelerror",4]]]],[5,"check_nonzero_length","","checks that a length is not 0.",null,[[],[["result",4],["kernelerror",4]]]],[5,"check_lower_than_usize","","Checks the given u64 fits an usize on this architecture.",null,[[["userspaceerror",3]],[["result",4],["userspaceerror",3]]]],[0,"cpu_locals","sunrise_kernel","CPU local storage",null,null],[3,"ThreadControlBlock","sunrise_kernel::cpu_locals","Elf TLS TCB",null,null],[12,"tp_self_ptr","","Pointer containing its own address.",173,null],[3,"CpuLocalRegion","","Represents an allocated cpu local region.",null,null],[12,"ptr","","Pointer to the allocated memory",174,null],[12,"layout","","Layout of the allocated memory. Used when deallocating.",174,null],[12,"tcb_offset","","Offset of the TCB in this allocation.",174,null],[5,"get_cpu_locals_ptr_for_core","","Address that should be put in `KTls` segment\'s base. The…",null,[[]]],[5,"init_cpu_locals","","Initializes cpu locals during early boot stage.",null,[[]]],[5,"tls_align_up","","The `round` function, as defined in section 3.0:",null,[[]]],[7,"ARE_CPU_LOCALS_INITIALIZED_YET","","Use this if your code might run in an early boot stage to…",null,null],[7,"CPU_LOCAL_REGIONS","","Array of cpu local regions, copied from the initialization…",null,null],[11,"tcb","","Returns a pointer to the [ThreadControlBlock] in the…",174,[[],["threadcontrolblock",3]]],[11,"allocate","","Allocates a CpuLocalRegion.",174,[[]]],[0,"panic","sunrise_kernel","Kernel panic",null,null],[4,"PanicOrigin","sunrise_kernel::panic","Reason for a kernel panic. Must be passed to [kernel_panic].",null,null],[13,"KernelAssert","","The kernel failed an assertion.",175,null],[12,"panic_message","sunrise_kernel::panic::PanicOrigin","Formatted string passed to `panic!()`.",176,null],[13,"KernelFault","sunrise_kernel::panic","CPU Exception occurred while we were in kernel, e.g. page…",175,null],[12,"exception_message","sunrise_kernel::panic::PanicOrigin","Formatted string of the exception name, and optional cpu…",177,null],[12,"kernel_hardware_context","","Kernel registers state before exception.",177,null],[13,"DoubleFault","sunrise_kernel::panic","Kernel Faulted, and then the fault handler faulted too.",175,null],[13,"UserspaceFault","","Userspace exception.",175,null],[12,"exception_message","sunrise_kernel::panic::PanicOrigin","Formatted string of the exception name, and optional cpu…",178,null],[12,"userspace_hardware_context","","Userspace registers state before exception.",178,null],[5,"kernel_panic","sunrise_kernel::panic","The kernel panic function.",null,[[["panicorigin",4]]]],[5,"display_bsod","","Display the infamous \\\"Blue Screen Of Death\\\"",null,[[]]],[7,"BSOD_BMP","","The \\\"Blue Screen Of Death\\\"",null,null],[7,"ALLOCATOR","sunrise_kernel","The global heap allocator.",null,null],[14,"trap_gate_asm","","The exception/syscall handler asm wrapper.",null,null],[14,"generate_trap_gate_handler","","Generates a trap/interrupt gate isr.",null,null],[14,"irq_handler","","Generates irq handlers.",null,null],[11,"from","sunrise_kernel::paging","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","sunrise_kernel::paging::process_memory","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","sunrise_kernel::paging::kernel_memory","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","sunrise_kernel::paging::lands","",179,[[]]],[11,"try_from","","",179,[[],["result",4]]],[11,"into","","",179,[[]]],[11,"try_into","","",179,[[],["result",4]]],[11,"borrow","","",179,[[]]],[11,"borrow_mut","","",179,[[]]],[11,"type_id","","",179,[[],["typeid",3]]],[11,"from","","",180,[[]]],[11,"try_from","","",180,[[],["result",4]]],[11,"into","","",180,[[]]],[11,"try_into","","",180,[[],["result",4]]],[11,"borrow","","",180,[[]]],[11,"borrow_mut","","",180,[[]]],[11,"type_id","","",180,[[],["typeid",3]]],[11,"from","","",181,[[]]],[11,"try_from","","",181,[[],["result",4]]],[11,"into","","",181,[[]]],[11,"try_into","","",181,[[],["result",4]]],[11,"borrow","","",181,[[]]],[11,"borrow_mut","","",181,[[]]],[11,"type_id","","",181,[[],["typeid",3]]],[11,"from","sunrise_kernel::paging::mapping","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","sunrise_kernel::paging::cross_process","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","sunrise_kernel::paging::hierarchical_table","",182,[[]]],[11,"try_from","","",182,[[],["result",4]]],[11,"into","","",182,[[]]],[11,"try_into","","",182,[[],["result",4]]],[11,"borrow","","",182,[[]]],[11,"borrow_mut","","",182,[[]]],[11,"type_id","","",182,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","sunrise_kernel::paging::arch::i386::entry","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"into","","",17,[[]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"to_owned","","",17,[[]]],[11,"clone_into","","",17,[[]]],[11,"from","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"into","","",18,[[]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"to_owned","","",18,[[]]],[11,"clone_into","","",18,[[]]],[11,"from","sunrise_kernel::paging::arch::i386::table","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"into","","",19,[[]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"into","","",20,[[]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"into","","",21,[[]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","","",183,[[]]],[11,"try_from","","",183,[[],["result",4]]],[11,"into","","",183,[[]]],[11,"try_into","","",183,[[],["result",4]]],[11,"borrow","","",183,[[]]],[11,"borrow_mut","","",183,[[]]],[11,"type_id","","",183,[[],["typeid",3]]],[11,"from","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"into","","",22,[[]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"into","","",23,[[]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","","",184,[[]]],[11,"try_from","","",184,[[],["result",4]]],[11,"into","","",184,[[]]],[11,"try_into","","",184,[[],["result",4]]],[11,"borrow","","",184,[[]]],[11,"borrow_mut","","",184,[[]]],[11,"type_id","","",184,[[],["typeid",3]]],[11,"from","sunrise_kernel::paging::bookkeeping","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"into","","",24,[[]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from","sunrise_kernel::event","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"into","","",25,[[]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"into","","",26,[[]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"to_owned","","",26,[[]]],[11,"clone_into","","",26,[[]]],[11,"from","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"into","","",27,[[]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"to_owned","","",27,[[]]],[11,"clone_into","","",27,[[]]],[11,"from","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"into","","",28,[[]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"from","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"into","","",29,[[]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow","","",29,[[]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"from","sunrise_kernel::error","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"into","","",31,[[]]],[11,"try_into","","",31,[[],["result",4]]],[11,"borrow","","",31,[[]]],[11,"borrow_mut","","",31,[[]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"to_owned","","",31,[[]]],[11,"clone_into","","",31,[[]]],[11,"to_string","","",31,[[],["string",3]]],[11,"from","","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"into","","",32,[[]]],[11,"try_into","","",32,[[],["result",4]]],[11,"borrow","","",32,[[]]],[11,"borrow_mut","","",32,[[]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"to_string","","",32,[[],["string",3]]],[11,"as_fail","","",32,[[],["fail",8]]],[11,"from","sunrise_kernel::log_impl","",47,[[]]],[11,"try_from","","",47,[[],["result",4]]],[11,"into","","",47,[[]]],[11,"try_into","","",47,[[],["result",4]]],[11,"borrow","","",47,[[]]],[11,"borrow_mut","","",47,[[]]],[11,"type_id","","",47,[[],["typeid",3]]],[11,"from","sunrise_kernel::log_impl::filter","",48,[[]]],[11,"try_from","","",48,[[],["result",4]]],[11,"into","","",48,[[]]],[11,"try_into","","",48,[[],["result",4]]],[11,"borrow","","",48,[[]]],[11,"borrow_mut","","",48,[[]]],[11,"type_id","","",48,[[],["typeid",3]]],[11,"from","","",49,[[]]],[11,"try_from","","",49,[[],["result",4]]],[11,"into","","",49,[[]]],[11,"try_into","","",49,[[],["result",4]]],[11,"borrow","","",49,[[]]],[11,"borrow_mut","","",49,[[]]],[11,"type_id","","",49,[[],["typeid",3]]],[11,"from","","",50,[[]]],[11,"try_from","","",50,[[],["result",4]]],[11,"into","","",50,[[]]],[11,"try_into","","",50,[[],["result",4]]],[11,"borrow","","",50,[[]]],[11,"borrow_mut","","",50,[[]]],[11,"type_id","","",50,[[],["typeid",3]]],[11,"from","sunrise_kernel::log_impl::filter::inner","",51,[[]]],[11,"try_from","","",51,[[],["result",4]]],[11,"into","","",51,[[]]],[11,"try_into","","",51,[[],["result",4]]],[11,"borrow","","",51,[[]]],[11,"borrow_mut","","",51,[[]]],[11,"type_id","","",51,[[],["typeid",3]]],[11,"to_string","","",51,[[],["string",3]]],[11,"from","sunrise_kernel::i386","",52,[[]]],[11,"try_from","","",52,[[],["result",4]]],[11,"into","","",52,[[]]],[11,"try_into","","",52,[[],["result",4]]],[11,"borrow","","",52,[[]]],[11,"borrow_mut","","",52,[[]]],[11,"type_id","","",52,[[],["typeid",3]]],[11,"to_owned","","",52,[[]]],[11,"clone_into","","",52,[[]]],[11,"from","","",53,[[]]],[11,"try_from","","",53,[[],["result",4]]],[11,"into","","",53,[[]]],[11,"try_into","","",53,[[],["result",4]]],[11,"borrow","","",53,[[]]],[11,"borrow_mut","","",53,[[]]],[11,"type_id","","",53,[[],["typeid",3]]],[11,"to_owned","","",53,[[]]],[11,"clone_into","","",53,[[]]],[11,"from","sunrise_kernel::i386::acpi","",185,[[]]],[11,"try_from","","",185,[[],["result",4]]],[11,"into","","",185,[[]]],[11,"try_into","","",185,[[],["result",4]]],[11,"borrow","","",185,[[]]],[11,"borrow_mut","","",185,[[]]],[11,"type_id","","",185,[[],["typeid",3]]],[11,"from","sunrise_kernel::i386::registers::eflags","",54,[[]]],[11,"try_from","","",54,[[],["result",4]]],[11,"into","","",54,[[]]],[11,"try_into","","",54,[[],["result",4]]],[11,"borrow","","",54,[[]]],[11,"borrow_mut","","",54,[[]]],[11,"type_id","","",54,[[],["typeid",3]]],[11,"to_owned","","",54,[[]]],[11,"clone_into","","",54,[[]]],[11,"from","sunrise_kernel::i386::stack","",55,[[]]],[11,"try_from","","",55,[[],["result",4]]],[11,"into","","",55,[[]]],[11,"try_into","","",55,[[],["result",4]]],[11,"borrow","","",55,[[]]],[11,"borrow_mut","","",55,[[]]],[11,"type_id","","",55,[[],["typeid",3]]],[11,"from","","",56,[[]]],[11,"try_from","","",56,[[],["result",4]]],[11,"into","","",56,[[]]],[11,"try_into","","",56,[[],["result",4]]],[11,"borrow","","",56,[[]]],[11,"borrow_mut","","",56,[[]]],[11,"type_id","","",56,[[],["typeid",3]]],[11,"from","sunrise_kernel::i386::structures::gdt","",57,[[]]],[11,"try_from","","",57,[[],["result",4]]],[11,"into","","",57,[[]]],[11,"try_into","","",57,[[],["result",4]]],[11,"borrow","","",57,[[]]],[11,"borrow_mut","","",57,[[]]],[11,"type_id","","",57,[[],["typeid",3]]],[11,"to_owned","","",57,[[]]],[11,"clone_into","","",57,[[]]],[11,"from","sunrise_kernel::i386::structures::idt","",58,[[]]],[11,"try_from","","",58,[[],["result",4]]],[11,"into","","",58,[[]]],[11,"try_into","","",58,[[],["result",4]]],[11,"borrow","","",58,[[]]],[11,"borrow_mut","","",58,[[]]],[11,"type_id","","",58,[[],["typeid",3]]],[11,"from","","",59,[[]]],[11,"try_from","","",59,[[],["result",4]]],[11,"into","","",59,[[]]],[11,"try_into","","",59,[[],["result",4]]],[11,"borrow","","",59,[[]]],[11,"borrow_mut","","",59,[[]]],[11,"type_id","","",59,[[],["typeid",3]]],[11,"to_owned","","",59,[[]]],[11,"clone_into","","",59,[[]]],[11,"from","","",60,[[]]],[11,"try_from","","",60,[[],["result",4]]],[11,"into","","",60,[[]]],[11,"try_into","","",60,[[],["result",4]]],[11,"borrow","","",60,[[]]],[11,"borrow_mut","","",60,[[]]],[11,"type_id","","",60,[[],["typeid",3]]],[11,"to_owned","","",60,[[]]],[11,"clone_into","","",60,[[]]],[11,"bit","","",60,[[]]],[11,"set_bit","","",60,[[]]],[11,"from","","",61,[[]]],[11,"try_from","","",61,[[],["result",4]]],[11,"into","","",61,[[]]],[11,"try_into","","",61,[[],["result",4]]],[11,"borrow","","",61,[[]]],[11,"borrow_mut","","",61,[[]]],[11,"type_id","","",61,[[],["typeid",3]]],[11,"from","","",62,[[]]],[11,"try_from","","",62,[[],["result",4]]],[11,"into","","",62,[[]]],[11,"try_into","","",62,[[],["result",4]]],[11,"borrow","","",62,[[]]],[11,"borrow_mut","","",62,[[]]],[11,"type_id","","",62,[[],["typeid",3]]],[11,"to_owned","","",62,[[]]],[11,"clone_into","","",62,[[]]],[11,"from","","",63,[[]]],[11,"try_from","","",63,[[],["result",4]]],[11,"into","","",63,[[]]],[11,"try_into","","",63,[[],["result",4]]],[11,"borrow","","",63,[[]]],[11,"borrow_mut","","",63,[[]]],[11,"type_id","","",63,[[],["typeid",3]]],[11,"to_owned","","",63,[[]]],[11,"clone_into","","",63,[[]]],[11,"from","sunrise_kernel::i386::process_switch","",64,[[]]],[11,"try_from","","",64,[[],["result",4]]],[11,"into","","",64,[[]]],[11,"try_into","","",64,[[],["result",4]]],[11,"borrow","","",64,[[]]],[11,"borrow_mut","","",64,[[]]],[11,"type_id","","",64,[[],["typeid",3]]],[11,"from","sunrise_kernel::i386::gdt","",65,[[]]],[11,"try_from","","",65,[[],["result",4]]],[11,"into","","",65,[[]]],[11,"try_into","","",65,[[],["result",4]]],[11,"borrow","","",65,[[]]],[11,"borrow_mut","","",65,[[]]],[11,"type_id","","",65,[[],["typeid",3]]],[11,"from","","",66,[[]]],[11,"try_from","","",66,[[],["result",4]]],[11,"into","","",66,[[]]],[11,"try_into","","",66,[[],["result",4]]],[11,"borrow","","",66,[[]]],[11,"borrow_mut","","",66,[[]]],[11,"type_id","","",66,[[],["typeid",3]]],[11,"from","","",67,[[]]],[11,"try_from","","",67,[[],["result",4]]],[11,"into","","",67,[[]]],[11,"try_into","","",67,[[],["result",4]]],[11,"borrow","","",67,[[]]],[11,"borrow_mut","","",67,[[]]],[11,"type_id","","",67,[[],["typeid",3]]],[11,"from","","",68,[[]]],[11,"try_from","","",68,[[],["result",4]]],[11,"into","","",68,[[]]],[11,"try_into","","",68,[[],["result",4]]],[11,"borrow","","",68,[[]]],[11,"borrow_mut","","",68,[[]]],[11,"type_id","","",68,[[],["typeid",3]]],[11,"to_owned","","",68,[[]]],[11,"clone_into","","",68,[[]]],[11,"from","","",69,[[]]],[11,"try_from","","",69,[[],["result",4]]],[11,"into","","",69,[[]]],[11,"try_into","","",69,[[],["result",4]]],[11,"borrow","","",69,[[]]],[11,"borrow_mut","","",69,[[]]],[11,"type_id","","",69,[[],["typeid",3]]],[11,"to_owned","","",69,[[]]],[11,"clone_into","","",69,[[]]],[11,"from","","",70,[[]]],[11,"try_from","","",70,[[],["result",4]]],[11,"into","","",70,[[]]],[11,"try_into","","",70,[[],["result",4]]],[11,"borrow","","",70,[[]]],[11,"borrow_mut","","",70,[[]]],[11,"type_id","","",70,[[],["typeid",3]]],[11,"to_owned","","",70,[[]]],[11,"clone_into","","",70,[[]]],[11,"from","","",71,[[]]],[11,"try_from","","",71,[[],["result",4]]],[11,"into","","",71,[[]]],[11,"try_into","","",71,[[],["result",4]]],[11,"borrow","","",71,[[]]],[11,"borrow_mut","","",71,[[]]],[11,"type_id","","",71,[[],["typeid",3]]],[11,"to_owned","","",71,[[]]],[11,"clone_into","","",71,[[]]],[11,"from","sunrise_kernel::i386::interrupt","",72,[[]]],[11,"try_from","","",72,[[],["result",4]]],[11,"into","","",72,[[]]],[11,"try_into","","",72,[[],["result",4]]],[11,"borrow","","",72,[[]]],[11,"borrow_mut","","",72,[[]]],[11,"type_id","","",72,[[],["typeid",3]]],[11,"from","sunrise_kernel::i386::interrupt_service_routines","",73,[[]]],[11,"try_from","","",73,[[],["result",4]]],[11,"into","","",73,[[]]],[11,"try_into","","",73,[[],["result",4]]],[11,"borrow","","",73,[[]]],[11,"borrow_mut","","",73,[[]]],[11,"type_id","","",73,[[],["typeid",3]]],[11,"to_owned","","",73,[[]]],[11,"clone_into","","",73,[[]]],[11,"to_string","","",73,[[],["string",3]]],[11,"from","","",74,[[]]],[11,"try_from","","",74,[[],["result",4]]],[11,"into","","",74,[[]]],[11,"try_into","","",74,[[],["result",4]]],[11,"borrow","","",74,[[]]],[11,"borrow_mut","","",74,[[]]],[11,"type_id","","",74,[[],["typeid",3]]],[11,"from","sunrise_kernel::utils::io","",75,[[]]],[11,"try_from","","",75,[[],["result",4]]],[11,"into","","",75,[[]]],[11,"try_into","","",75,[[],["result",4]]],[11,"borrow","","",75,[[]]],[11,"borrow_mut","","",75,[[]]],[11,"type_id","","",75,[[],["typeid",3]]],[11,"to_owned","","",75,[[]]],[11,"clone_into","","",75,[[]]],[11,"from","sunrise_kernel::i386::instructions::tables","",76,[[]]],[11,"try_from","","",76,[[],["result",4]]],[11,"into","","",76,[[]]],[11,"try_into","","",76,[[],["result",4]]],[11,"borrow","","",76,[[]]],[11,"borrow_mut","","",76,[[]]],[11,"type_id","","",76,[[],["typeid",3]]],[11,"to_owned","","",76,[[]]],[11,"clone_into","","",76,[[]]],[11,"from","sunrise_kernel::frame_allocator","",186,[[]]],[11,"try_from","","",186,[[],["result",4]]],[11,"into","","",186,[[]]],[11,"try_into","","",186,[[],["result",4]]],[11,"borrow","","",186,[[]]],[11,"borrow_mut","","",186,[[]]],[11,"type_id","","",186,[[],["typeid",3]]],[11,"from","sunrise_kernel::frame_allocator::physical_mem_region","",77,[[]]],[11,"try_from","","",77,[[],["result",4]]],[11,"into","","",77,[[]]],[11,"try_into","","",77,[[],["result",4]]],[11,"borrow","","",77,[[]]],[11,"borrow_mut","","",77,[[]]],[11,"type_id","","",77,[[],["typeid",3]]],[11,"from","","",78,[[]]],[11,"into_iter","","",78,[[]]],[11,"try_from","","",78,[[],["result",4]]],[11,"into","","",78,[[]]],[11,"try_into","","",78,[[],["result",4]]],[11,"borrow","","",78,[[]]],[11,"borrow_mut","","",78,[[]]],[11,"type_id","","",78,[[],["typeid",3]]],[11,"to_owned","","",78,[[]]],[11,"clone_into","","",78,[[]]],[11,"from","sunrise_kernel::frame_allocator::i386","",79,[[]]],[11,"try_from","","",79,[[],["result",4]]],[11,"into","","",79,[[]]],[11,"try_into","","",79,[[],["result",4]]],[11,"borrow","","",79,[[]]],[11,"borrow_mut","","",79,[[]]],[11,"type_id","","",79,[[],["typeid",3]]],[11,"from","sunrise_kernel::heap_allocator","",82,[[]]],[11,"try_from","","",82,[[],["result",4]]],[11,"into","","",82,[[]]],[11,"try_into","","",82,[[],["result",4]]],[11,"borrow","","",82,[[]]],[11,"borrow_mut","","",82,[[]]],[11,"type_id","","",82,[[],["typeid",3]]],[11,"from","sunrise_kernel::devices::hpet","",83,[[]]],[11,"try_from","","",83,[[],["result",4]]],[11,"into","","",83,[[]]],[11,"try_into","","",83,[[],["result",4]]],[11,"borrow","","",83,[[]]],[11,"borrow_mut","","",83,[[]]],[11,"type_id","","",83,[[],["typeid",3]]],[11,"to_owned","","",83,[[]]],[11,"clone_into","","",83,[[]]],[11,"bit","","",83,[[]]],[11,"set_bit","","",83,[[]]],[11,"from","","",84,[[]]],[11,"try_from","","",84,[[],["result",4]]],[11,"into","","",84,[[]]],[11,"try_into","","",84,[[],["result",4]]],[11,"borrow","","",84,[[]]],[11,"borrow_mut","","",84,[[]]],[11,"type_id","","",84,[[],["typeid",3]]],[11,"to_owned","","",84,[[]]],[11,"clone_into","","",84,[[]]],[11,"bit","","",84,[[]]],[11,"set_bit","","",84,[[]]],[11,"from","","",85,[[]]],[11,"try_from","","",85,[[],["result",4]]],[11,"into","","",85,[[]]],[11,"try_into","","",85,[[],["result",4]]],[11,"borrow","","",85,[[]]],[11,"borrow_mut","","",85,[[]]],[11,"type_id","","",85,[[],["typeid",3]]],[11,"to_owned","","",85,[[]]],[11,"clone_into","","",85,[[]]],[11,"bit","","",85,[[]]],[11,"set_bit","","",85,[[]]],[11,"from","","",86,[[]]],[11,"try_from","","",86,[[],["result",4]]],[11,"into","","",86,[[]]],[11,"try_into","","",86,[[],["result",4]]],[11,"borrow","","",86,[[]]],[11,"borrow_mut","","",86,[[]]],[11,"type_id","","",86,[[],["typeid",3]]],[11,"from","","",87,[[]]],[11,"try_from","","",87,[[],["result",4]]],[11,"into","","",87,[[]]],[11,"try_into","","",87,[[],["result",4]]],[11,"borrow","","",87,[[]]],[11,"borrow_mut","","",87,[[]]],[11,"type_id","","",87,[[],["typeid",3]]],[11,"from","","",88,[[]]],[11,"try_from","","",88,[[],["result",4]]],[11,"into","","",88,[[]]],[11,"try_into","","",88,[[],["result",4]]],[11,"borrow","","",88,[[]]],[11,"borrow_mut","","",88,[[]]],[11,"type_id","","",88,[[],["typeid",3]]],[11,"from","","",89,[[]]],[11,"try_from","","",89,[[],["result",4]]],[11,"into","","",89,[[]]],[11,"try_into","","",89,[[],["result",4]]],[11,"borrow","","",89,[[]]],[11,"borrow_mut","","",89,[[]]],[11,"type_id","","",89,[[],["typeid",3]]],[11,"from","sunrise_kernel::devices::pic","",90,[[]]],[11,"try_from","","",90,[[],["result",4]]],[11,"into","","",90,[[]]],[11,"try_into","","",90,[[],["result",4]]],[11,"borrow","","",90,[[]]],[11,"borrow_mut","","",90,[[]]],[11,"type_id","","",90,[[],["typeid",3]]],[11,"to_owned","","",90,[[]]],[11,"clone_into","","",90,[[]]],[11,"from","","",91,[[]]],[11,"try_from","","",91,[[],["result",4]]],[11,"into","","",91,[[]]],[11,"try_into","","",91,[[],["result",4]]],[11,"borrow","","",91,[[]]],[11,"borrow_mut","","",91,[[]]],[11,"type_id","","",91,[[],["typeid",3]]],[11,"from","","",92,[[]]],[11,"try_from","","",92,[[],["result",4]]],[11,"into","","",92,[[]]],[11,"try_into","","",92,[[],["result",4]]],[11,"borrow","","",92,[[]]],[11,"borrow_mut","","",92,[[]]],[11,"type_id","","",92,[[],["typeid",3]]],[11,"from","sunrise_kernel::devices::pit","",93,[[]]],[11,"try_from","","",93,[[],["result",4]]],[11,"into","","",93,[[]]],[11,"try_into","","",93,[[],["result",4]]],[11,"borrow","","",93,[[]]],[11,"borrow_mut","","",93,[[]]],[11,"type_id","","",93,[[],["typeid",3]]],[11,"from","","",94,[[]]],[11,"try_from","","",94,[[],["result",4]]],[11,"into","","",94,[[]]],[11,"try_into","","",94,[[],["result",4]]],[11,"borrow","","",94,[[]]],[11,"borrow_mut","","",94,[[]]],[11,"type_id","","",94,[[],["typeid",3]]],[11,"to_owned","","",94,[[]]],[11,"clone_into","","",94,[[]]],[11,"from","","",95,[[]]],[11,"try_from","","",95,[[],["result",4]]],[11,"into","","",95,[[]]],[11,"try_into","","",95,[[],["result",4]]],[11,"borrow","","",95,[[]]],[11,"borrow_mut","","",95,[[]]],[11,"type_id","","",95,[[],["typeid",3]]],[11,"from","","",96,[[]]],[11,"try_from","","",96,[[],["result",4]]],[11,"into","","",96,[[]]],[11,"try_into","","",96,[[],["result",4]]],[11,"borrow","","",96,[[]]],[11,"borrow_mut","","",96,[[]]],[11,"type_id","","",96,[[],["typeid",3]]],[11,"from","","",97,[[]]],[11,"try_from","","",97,[[],["result",4]]],[11,"into","","",97,[[]]],[11,"try_into","","",97,[[],["result",4]]],[11,"borrow","","",97,[[]]],[11,"borrow_mut","","",97,[[]]],[11,"type_id","","",97,[[],["typeid",3]]],[11,"to_owned","","",97,[[]]],[11,"clone_into","","",97,[[]]],[11,"from","sunrise_kernel::devices::rs232","",98,[[]]],[11,"try_from","","",98,[[],["result",4]]],[11,"into","","",98,[[]]],[11,"try_into","","",98,[[],["result",4]]],[11,"borrow","","",98,[[]]],[11,"borrow_mut","","",98,[[]]],[11,"type_id","","",98,[[],["typeid",3]]],[11,"to_owned","","",98,[[]]],[11,"clone_into","","",98,[[]]],[11,"from","","",99,[[]]],[11,"try_from","","",99,[[],["result",4]]],[11,"into","","",99,[[]]],[11,"try_into","","",99,[[],["result",4]]],[11,"borrow","","",99,[[]]],[11,"borrow_mut","","",99,[[]]],[11,"type_id","","",99,[[],["typeid",3]]],[11,"to_owned","","",99,[[]]],[11,"clone_into","","",99,[[]]],[11,"to_string","","",99,[[],["string",3]]],[11,"from","","",100,[[]]],[11,"try_from","","",100,[[],["result",4]]],[11,"into","","",100,[[]]],[11,"try_into","","",100,[[],["result",4]]],[11,"borrow","","",100,[[]]],[11,"borrow_mut","","",100,[[]]],[11,"type_id","","",100,[[],["typeid",3]]],[11,"from","","",102,[[]]],[11,"try_from","","",102,[[],["result",4]]],[11,"into","","",102,[[]]],[11,"try_into","","",102,[[],["result",4]]],[11,"borrow","","",102,[[]]],[11,"borrow_mut","","",102,[[]]],[11,"type_id","","",102,[[],["typeid",3]]],[11,"from","","",101,[[]]],[11,"try_from","","",101,[[],["result",4]]],[11,"into","","",101,[[]]],[11,"try_into","","",101,[[],["result",4]]],[11,"borrow","","",101,[[]]],[11,"borrow_mut","","",101,[[]]],[11,"type_id","","",101,[[],["typeid",3]]],[11,"to_owned","","",101,[[]]],[11,"clone_into","","",101,[[]]],[11,"from","sunrise_kernel::devices::lapic","",103,[[]]],[11,"try_from","","",103,[[],["result",4]]],[11,"into","","",103,[[]]],[11,"try_into","","",103,[[],["result",4]]],[11,"borrow","","",103,[[]]],[11,"borrow_mut","","",103,[[]]],[11,"type_id","","",103,[[],["typeid",3]]],[11,"from","","",104,[[]]],[11,"try_from","","",104,[[],["result",4]]],[11,"into","","",104,[[]]],[11,"try_into","","",104,[[],["result",4]]],[11,"borrow","","",104,[[]]],[11,"borrow_mut","","",104,[[]]],[11,"type_id","","",104,[[],["typeid",3]]],[11,"to_owned","","",104,[[]]],[11,"clone_into","","",104,[[]]],[11,"bit","","",104,[[]]],[11,"set_bit","","",104,[[]]],[11,"from","","",105,[[]]],[11,"try_from","","",105,[[],["result",4]]],[11,"into","","",105,[[]]],[11,"try_into","","",105,[[],["result",4]]],[11,"borrow","","",105,[[]]],[11,"borrow_mut","","",105,[[]]],[11,"type_id","","",105,[[],["typeid",3]]],[11,"to_owned","","",105,[[]]],[11,"clone_into","","",105,[[]]],[11,"bit","","",105,[[]]],[11,"set_bit","","",105,[[]]],[11,"from","","",106,[[]]],[11,"try_from","","",106,[[],["result",4]]],[11,"into","","",106,[[]]],[11,"try_into","","",106,[[],["result",4]]],[11,"borrow","","",106,[[]]],[11,"borrow_mut","","",106,[[]]],[11,"type_id","","",106,[[],["typeid",3]]],[11,"to_owned","","",106,[[]]],[11,"clone_into","","",106,[[]]],[11,"bit","","",106,[[]]],[11,"set_bit","","",106,[[]]],[11,"from","","",107,[[]]],[11,"try_from","","",107,[[],["result",4]]],[11,"into","","",107,[[]]],[11,"try_into","","",107,[[],["result",4]]],[11,"borrow","","",107,[[]]],[11,"borrow_mut","","",107,[[]]],[11,"type_id","","",107,[[],["typeid",3]]],[11,"to_owned","","",107,[[]]],[11,"clone_into","","",107,[[]]],[11,"from","","",108,[[]]],[11,"try_from","","",108,[[],["result",4]]],[11,"into","","",108,[[]]],[11,"try_into","","",108,[[],["result",4]]],[11,"borrow","","",108,[[]]],[11,"borrow_mut","","",108,[[]]],[11,"type_id","","",108,[[],["typeid",3]]],[11,"from","","",109,[[]]],[11,"try_from","","",109,[[],["result",4]]],[11,"into","","",109,[[]]],[11,"try_into","","",109,[[],["result",4]]],[11,"borrow","","",109,[[]]],[11,"borrow_mut","","",109,[[]]],[11,"type_id","","",109,[[],["typeid",3]]],[11,"from","","",110,[[]]],[11,"try_from","","",110,[[],["result",4]]],[11,"into","","",110,[[]]],[11,"try_into","","",110,[[],["result",4]]],[11,"borrow","","",110,[[]]],[11,"borrow_mut","","",110,[[]]],[11,"type_id","","",110,[[],["typeid",3]]],[11,"to_owned","","",110,[[]]],[11,"clone_into","","",110,[[]]],[11,"from","","",111,[[]]],[11,"try_from","","",111,[[],["result",4]]],[11,"into","","",111,[[]]],[11,"try_into","","",111,[[],["result",4]]],[11,"borrow","","",111,[[]]],[11,"borrow_mut","","",111,[[]]],[11,"type_id","","",111,[[],["typeid",3]]],[11,"to_owned","","",111,[[]]],[11,"clone_into","","",111,[[]]],[11,"from","sunrise_kernel::devices::ioapic","",112,[[]]],[11,"try_from","","",112,[[],["result",4]]],[11,"into","","",112,[[]]],[11,"try_into","","",112,[[],["result",4]]],[11,"borrow","","",112,[[]]],[11,"borrow_mut","","",112,[[]]],[11,"type_id","","",112,[[],["typeid",3]]],[11,"from","","",113,[[]]],[11,"try_from","","",113,[[],["result",4]]],[11,"into","","",113,[[]]],[11,"try_into","","",113,[[],["result",4]]],[11,"borrow","","",113,[[]]],[11,"borrow_mut","","",113,[[]]],[11,"type_id","","",113,[[],["typeid",3]]],[11,"from","","",114,[[]]],[11,"try_from","","",114,[[],["result",4]]],[11,"into","","",114,[[]]],[11,"try_into","","",114,[[],["result",4]]],[11,"borrow","","",114,[[]]],[11,"borrow_mut","","",114,[[]]],[11,"type_id","","",114,[[],["typeid",3]]],[11,"bit","","",114,[[]]],[11,"set_bit","","",114,[[]]],[11,"from","","",115,[[]]],[11,"try_from","","",115,[[],["result",4]]],[11,"into","","",115,[[]]],[11,"try_into","","",115,[[],["result",4]]],[11,"borrow","","",115,[[]]],[11,"borrow_mut","","",115,[[]]],[11,"type_id","","",115,[[],["typeid",3]]],[11,"to_owned","","",115,[[]]],[11,"clone_into","","",115,[[]]],[11,"from","sunrise_kernel::sync","",116,[[]]],[11,"try_from","","",116,[[],["result",4]]],[11,"into","","",116,[[]]],[11,"try_into","","",116,[[],["result",4]]],[11,"borrow","","",116,[[]]],[11,"borrow_mut","","",116,[[]]],[11,"type_id","","",116,[[],["typeid",3]]],[11,"from","","",117,[[]]],[11,"try_from","","",117,[[],["result",4]]],[11,"into","","",117,[[]]],[11,"try_into","","",117,[[],["result",4]]],[11,"borrow","","",117,[[]]],[11,"borrow_mut","","",117,[[]]],[11,"type_id","","",117,[[],["typeid",3]]],[11,"from","","",118,[[]]],[11,"try_from","","",118,[[],["result",4]]],[11,"into","","",118,[[]]],[11,"try_into","","",118,[[],["result",4]]],[11,"borrow","","",118,[[]]],[11,"borrow_mut","","",118,[[]]],[11,"type_id","","",118,[[],["typeid",3]]],[11,"from","","",119,[[]]],[11,"try_from","","",119,[[],["result",4]]],[11,"into","","",119,[[]]],[11,"try_into","","",119,[[],["result",4]]],[11,"borrow","","",119,[[]]],[11,"borrow_mut","","",119,[[]]],[11,"type_id","","",119,[[],["typeid",3]]],[11,"from","sunrise_kernel::sync::spin_lock","",120,[[]]],[11,"try_from","","",120,[[],["result",4]]],[11,"into","","",120,[[]]],[11,"try_into","","",120,[[],["result",4]]],[11,"borrow","","",120,[[]]],[11,"borrow_mut","","",120,[[]]],[11,"type_id","","",120,[[],["typeid",3]]],[11,"from","sunrise_kernel::sync::spin_lock_irq","",121,[[]]],[11,"try_from","","",121,[[],["result",4]]],[11,"into","","",121,[[]]],[11,"try_into","","",121,[[],["result",4]]],[11,"borrow","","",121,[[]]],[11,"borrow_mut","","",121,[[]]],[11,"type_id","","",121,[[],["typeid",3]]],[11,"from","","",122,[[]]],[11,"try_from","","",122,[[],["result",4]]],[11,"into","","",122,[[]]],[11,"try_into","","",122,[[],["result",4]]],[11,"borrow","","",122,[[]]],[11,"borrow_mut","","",122,[[]]],[11,"type_id","","",122,[[],["typeid",3]]],[11,"from","sunrise_kernel::sync::spin_lock","",123,[[]]],[11,"try_from","","",123,[[],["result",4]]],[11,"into","","",123,[[]]],[11,"try_into","","",123,[[],["result",4]]],[11,"borrow","","",123,[[]]],[11,"borrow_mut","","",123,[[]]],[11,"type_id","","",123,[[],["typeid",3]]],[11,"from","sunrise_kernel::sync::mutex","",124,[[]]],[11,"from","","",124,[[]]],[11,"try_from","","",124,[[],["result",4]]],[11,"into","","",124,[[]]],[11,"try_into","","",124,[[],["result",4]]],[11,"borrow","","",124,[[]]],[11,"borrow_mut","","",124,[[]]],[11,"type_id","","",124,[[],["typeid",3]]],[11,"from","","",125,[[]]],[11,"try_from","","",125,[[],["result",4]]],[11,"into","","",125,[[]]],[11,"try_into","","",125,[[],["result",4]]],[11,"borrow","","",125,[[]]],[11,"borrow_mut","","",125,[[]]],[11,"type_id","","",125,[[],["typeid",3]]],[11,"from","","",126,[[]]],[11,"try_from","","",126,[[],["result",4]]],[11,"into","","",126,[[]]],[11,"try_into","","",126,[[],["result",4]]],[11,"borrow","","",126,[[]]],[11,"borrow_mut","","",126,[[]]],[11,"type_id","","",126,[[],["typeid",3]]],[11,"from","","",127,[[]]],[11,"try_from","","",127,[[],["result",4]]],[11,"into","","",127,[[]]],[11,"try_into","","",127,[[],["result",4]]],[11,"borrow","","",127,[[]]],[11,"borrow_mut","","",127,[[]]],[11,"type_id","","",127,[[],["typeid",3]]],[11,"to_string","","",127,[[],["string",3]]],[11,"from","sunrise_kernel::timer","",129,[[]]],[11,"try_from","","",129,[[],["result",4]]],[11,"into","","",129,[[]]],[11,"try_into","","",129,[[],["result",4]]],[11,"borrow","","",129,[[]]],[11,"borrow_mut","","",129,[[]]],[11,"type_id","","",129,[[],["typeid",3]]],[11,"from","","",130,[[]]],[11,"try_from","","",130,[[],["result",4]]],[11,"into","","",130,[[]]],[11,"try_into","","",130,[[],["result",4]]],[11,"borrow","","",130,[[]]],[11,"borrow_mut","","",130,[[]]],[11,"type_id","","",130,[[],["typeid",3]]],[11,"from","sunrise_kernel::process","",131,[[]]],[11,"try_from","","",131,[[],["result",4]]],[11,"into","","",131,[[]]],[11,"try_into","","",131,[[],["result",4]]],[11,"borrow","","",131,[[]]],[11,"borrow_mut","","",131,[[]]],[11,"type_id","","",131,[[],["typeid",3]]],[11,"from","","",132,[[]]],[11,"try_from","","",132,[[],["result",4]]],[11,"into","","",132,[[]]],[11,"try_into","","",132,[[],["result",4]]],[11,"borrow","","",132,[[]]],[11,"borrow_mut","","",132,[[]]],[11,"type_id","","",132,[[],["typeid",3]]],[11,"from","","",133,[[]]],[11,"try_from","","",133,[[],["result",4]]],[11,"into","","",133,[[]]],[11,"try_into","","",133,[[],["result",4]]],[11,"borrow","","",133,[[]]],[11,"borrow_mut","","",133,[[]]],[11,"type_id","","",133,[[],["typeid",3]]],[11,"from","","",134,[[]]],[11,"try_from","","",134,[[],["result",4]]],[11,"into","","",134,[[]]],[11,"try_into","","",134,[[],["result",4]]],[11,"borrow","","",134,[[]]],[11,"borrow_mut","","",134,[[]]],[11,"type_id","","",134,[[],["typeid",3]]],[11,"from","","",135,[[]]],[11,"try_from","","",135,[[],["result",4]]],[11,"into","","",135,[[]]],[11,"try_into","","",135,[[],["result",4]]],[11,"borrow","","",135,[[]]],[11,"borrow_mut","","",135,[[]]],[11,"type_id","","",135,[[],["typeid",3]]],[11,"from","","",136,[[]]],[11,"try_from","","",136,[[],["result",4]]],[11,"into","","",136,[[]]],[11,"try_into","","",136,[[],["result",4]]],[11,"borrow","","",136,[[]]],[11,"borrow_mut","","",136,[[]]],[11,"type_id","","",136,[[],["typeid",3]]],[11,"from","","",137,[[]]],[11,"try_from","","",137,[[],["result",4]]],[11,"into","","",137,[[]]],[11,"try_into","","",137,[[],["result",4]]],[11,"borrow","","",137,[[]]],[11,"borrow_mut","","",137,[[]]],[11,"type_id","","",137,[[],["typeid",3]]],[11,"from","","",138,[[]]],[11,"try_from","","",138,[[],["result",4]]],[11,"into","","",138,[[]]],[11,"try_into","","",138,[[],["result",4]]],[11,"borrow","","",138,[[]]],[11,"borrow_mut","","",138,[[]]],[11,"type_id","","",138,[[],["typeid",3]]],[11,"to_owned","","",138,[[]]],[11,"clone_into","","",138,[[]]],[11,"from","sunrise_kernel::process::thread_local_storage","",139,[[]]],[11,"try_from","","",139,[[],["result",4]]],[11,"into","","",139,[[]]],[11,"try_into","","",139,[[],["result",4]]],[11,"borrow","","",139,[[]]],[11,"borrow_mut","","",139,[[]]],[11,"type_id","","",139,[[],["typeid",3]]],[11,"from","","",140,[[]]],[11,"try_from","","",140,[[],["result",4]]],[11,"into","","",140,[[]]],[11,"try_into","","",140,[[],["result",4]]],[11,"borrow","","",140,[[]]],[11,"borrow_mut","","",140,[[]]],[11,"type_id","","",140,[[],["typeid",3]]],[11,"from","sunrise_kernel::process::capabilities","",141,[[]]],[11,"try_from","","",141,[[],["result",4]]],[11,"into","","",141,[[]]],[11,"try_into","","",141,[[],["result",4]]],[11,"borrow","","",141,[[]]],[11,"borrow_mut","","",141,[[]]],[11,"type_id","","",141,[[],["typeid",3]]],[11,"from","sunrise_kernel::mem","",142,[[]]],[11,"try_from","","",142,[[],["result",4]]],[11,"into","","",142,[[]]],[11,"try_into","","",142,[[],["result",4]]],[11,"borrow","","",142,[[]]],[11,"borrow_mut","","",142,[[]]],[11,"type_id","","",142,[[],["typeid",3]]],[11,"to_owned","","",142,[[]]],[11,"clone_into","","",142,[[]]],[11,"to_string","","",142,[[],["string",3]]],[11,"from","","",143,[[]]],[11,"try_from","","",143,[[],["result",4]]],[11,"into","","",143,[[]]],[11,"try_into","","",143,[[],["result",4]]],[11,"borrow","","",143,[[]]],[11,"borrow_mut","","",143,[[]]],[11,"type_id","","",143,[[],["typeid",3]]],[11,"to_owned","","",143,[[]]],[11,"clone_into","","",143,[[]]],[11,"to_string","","",143,[[],["string",3]]],[11,"from","","",144,[[]]],[11,"try_from","","",144,[[],["result",4]]],[11,"into","","",144,[[]]],[11,"try_into","","",144,[[],["result",4]]],[11,"borrow","","",144,[[]]],[11,"borrow_mut","","",144,[[]]],[11,"type_id","","",144,[[],["typeid",3]]],[11,"to_owned","","",144,[[]]],[11,"clone_into","","",144,[[]]],[11,"from","","",145,[[]]],[11,"try_from","","",145,[[],["result",4]]],[11,"into","","",145,[[]]],[11,"try_into","","",145,[[],["result",4]]],[11,"borrow","","",145,[[]]],[11,"borrow_mut","","",145,[[]]],[11,"type_id","","",145,[[],["typeid",3]]],[11,"to_owned","","",145,[[]]],[11,"clone_into","","",145,[[]]],[11,"from","","",146,[[]]],[11,"try_from","","",146,[[],["result",4]]],[11,"into","","",146,[[]]],[11,"try_into","","",146,[[],["result",4]]],[11,"borrow","","",146,[[]]],[11,"borrow_mut","","",146,[[]]],[11,"type_id","","",146,[[],["typeid",3]]],[11,"from","sunrise_kernel::ipc","",147,[[]]],[11,"try_from","","",147,[[],["result",4]]],[11,"into","","",147,[[]]],[11,"try_into","","",147,[[],["result",4]]],[11,"borrow","","",147,[[]]],[11,"borrow_mut","","",147,[[]]],[11,"type_id","","",147,[[],["typeid",3]]],[11,"from","sunrise_kernel::ipc::session","",148,[[]]],[11,"try_from","","",148,[[],["result",4]]],[11,"into","","",148,[[]]],[11,"try_into","","",148,[[],["result",4]]],[11,"borrow","","",148,[[]]],[11,"borrow_mut","","",148,[[]]],[11,"type_id","","",148,[[],["typeid",3]]],[11,"from","","",149,[[]]],[11,"try_from","","",149,[[],["result",4]]],[11,"into","","",149,[[]]],[11,"try_into","","",149,[[],["result",4]]],[11,"borrow","","",149,[[]]],[11,"borrow_mut","","",149,[[]]],[11,"type_id","","",149,[[],["typeid",3]]],[11,"from","","",150,[[]]],[11,"try_from","","",150,[[],["result",4]]],[11,"into","","",150,[[]]],[11,"try_into","","",150,[[],["result",4]]],[11,"borrow","","",150,[[]]],[11,"borrow_mut","","",150,[[]]],[11,"type_id","","",150,[[],["typeid",3]]],[11,"to_owned","","",150,[[]]],[11,"clone_into","","",150,[[]]],[11,"from","","",151,[[]]],[11,"try_from","","",151,[[],["result",4]]],[11,"into","","",151,[[]]],[11,"try_into","","",151,[[],["result",4]]],[11,"borrow","","",151,[[]]],[11,"borrow_mut","","",151,[[]]],[11,"type_id","","",151,[[],["typeid",3]]],[11,"to_owned","","",151,[[]]],[11,"clone_into","","",151,[[]]],[11,"from","","",152,[[]]],[11,"try_from","","",152,[[],["result",4]]],[11,"into","","",152,[[]]],[11,"try_into","","",152,[[],["result",4]]],[11,"borrow","","",152,[[]]],[11,"borrow_mut","","",152,[[]]],[11,"type_id","","",152,[[],["typeid",3]]],[11,"bit","","",152,[[]]],[11,"set_bit","","",152,[[]]],[11,"from","","",153,[[]]],[11,"try_from","","",153,[[],["result",4]]],[11,"into","","",153,[[]]],[11,"try_into","","",153,[[],["result",4]]],[11,"borrow","","",153,[[]]],[11,"borrow_mut","","",153,[[]]],[11,"type_id","","",153,[[],["typeid",3]]],[11,"bit","","",153,[[]]],[11,"set_bit","","",153,[[]]],[11,"from","","",154,[[]]],[11,"try_from","","",154,[[],["result",4]]],[11,"into","","",154,[[]]],[11,"try_into","","",154,[[],["result",4]]],[11,"borrow","","",154,[[]]],[11,"borrow_mut","","",154,[[]]],[11,"type_id","","",154,[[],["typeid",3]]],[11,"from","","",155,[[]]],[11,"try_from","","",155,[[],["result",4]]],[11,"into","","",155,[[]]],[11,"try_into","","",155,[[],["result",4]]],[11,"borrow","","",155,[[]]],[11,"borrow_mut","","",155,[[]]],[11,"type_id","","",155,[[],["typeid",3]]],[11,"from","","",156,[[]]],[11,"try_from","","",156,[[],["result",4]]],[11,"into","","",156,[[]]],[11,"try_into","","",156,[[],["result",4]]],[11,"borrow","","",156,[[]]],[11,"borrow_mut","","",156,[[]]],[11,"type_id","","",156,[[],["typeid",3]]],[11,"from","sunrise_kernel::ipc::port","",157,[[]]],[11,"try_from","","",157,[[],["result",4]]],[11,"into","","",157,[[]]],[11,"try_into","","",157,[[],["result",4]]],[11,"borrow","","",157,[[]]],[11,"borrow_mut","","",157,[[]]],[11,"type_id","","",157,[[],["typeid",3]]],[11,"from","","",158,[[]]],[11,"try_from","","",158,[[],["result",4]]],[11,"into","","",158,[[]]],[11,"try_into","","",158,[[],["result",4]]],[11,"borrow","","",158,[[]]],[11,"borrow_mut","","",158,[[]]],[11,"type_id","","",158,[[],["typeid",3]]],[11,"to_owned","","",158,[[]]],[11,"clone_into","","",158,[[]]],[11,"from","","",159,[[]]],[11,"try_from","","",159,[[],["result",4]]],[11,"into","","",159,[[]]],[11,"try_into","","",159,[[],["result",4]]],[11,"borrow","","",159,[[]]],[11,"borrow_mut","","",159,[[]]],[11,"type_id","","",159,[[],["typeid",3]]],[11,"to_owned","","",159,[[]]],[11,"clone_into","","",159,[[]]],[11,"from","","",160,[[]]],[11,"try_from","","",160,[[],["result",4]]],[11,"into","","",160,[[]]],[11,"try_into","","",160,[[],["result",4]]],[11,"borrow","","",160,[[]]],[11,"borrow_mut","","",160,[[]]],[11,"type_id","","",160,[[],["typeid",3]]],[11,"from","sunrise_kernel::elf_loader","",161,[[]]],[11,"try_from","","",161,[[],["result",4]]],[11,"into","","",161,[[]]],[11,"try_into","","",161,[[],["result",4]]],[11,"borrow","","",161,[[]]],[11,"borrow_mut","","",161,[[]]],[11,"type_id","","",161,[[],["typeid",3]]],[11,"from","sunrise_kernel::utils::io","",163,[[]]],[11,"try_from","","",163,[[],["result",4]]],[11,"into","","",163,[[]]],[11,"try_into","","",163,[[],["result",4]]],[11,"borrow","","",163,[[]]],[11,"borrow_mut","","",163,[[]]],[11,"type_id","","",163,[[],["typeid",3]]],[11,"from","","",164,[[]]],[11,"try_from","","",164,[[],["result",4]]],[11,"into","","",164,[[]]],[11,"try_into","","",164,[[],["result",4]]],[11,"borrow","","",164,[[]]],[11,"borrow_mut","","",164,[[]]],[11,"type_id","","",164,[[],["typeid",3]]],[11,"from","","",165,[[]]],[11,"try_from","","",165,[[],["result",4]]],[11,"into","","",165,[[]]],[11,"try_into","","",165,[[],["result",4]]],[11,"borrow","","",165,[[]]],[11,"borrow_mut","","",165,[[]]],[11,"type_id","","",165,[[],["typeid",3]]],[11,"from","sunrise_kernel::utils::loop_future","",166,[[]]],[11,"try_from","","",166,[[],["result",4]]],[11,"into","","",166,[[]]],[11,"try_into","","",166,[[],["result",4]]],[11,"borrow","","",166,[[]]],[11,"borrow_mut","","",166,[[]]],[11,"type_id","","",166,[[],["typeid",3]]],[11,"from","","",167,[[]]],[11,"try_from","","",167,[[],["result",4]]],[11,"into","","",167,[[]]],[11,"try_into","","",167,[[],["result",4]]],[11,"borrow","","",167,[[]]],[11,"borrow_mut","","",167,[[]]],[11,"type_id","","",167,[[],["typeid",3]]],[11,"into_future","","",167,[[]]],[11,"from","","",168,[[]]],[11,"from","","",168,[[]]],[11,"try_from","","",168,[[],["result",4]]],[11,"into","","",168,[[]]],[11,"try_into","","",168,[[],["result",4]]],[11,"borrow","","",168,[[]]],[11,"borrow_mut","","",168,[[]]],[11,"type_id","","",168,[[],["typeid",3]]],[11,"to_owned","","",168,[[]]],[11,"clone_into","","",168,[[]]],[11,"from","sunrise_kernel::utils","",170,[[]]],[11,"try_from","","",170,[[],["result",4]]],[11,"into","","",170,[[]]],[11,"try_into","","",170,[[],["result",4]]],[11,"borrow","","",170,[[]]],[11,"borrow_mut","","",170,[[]]],[11,"type_id","","",170,[[],["typeid",3]]],[11,"from","","",171,[[]]],[11,"try_from","","",171,[[],["result",4]]],[11,"into","","",171,[[]]],[11,"try_into","","",171,[[],["result",4]]],[11,"borrow","","",171,[[]]],[11,"borrow_mut","","",171,[[]]],[11,"type_id","","",171,[[],["typeid",3]]],[11,"from","sunrise_kernel::cpu_locals","",173,[[]]],[11,"try_from","","",173,[[],["result",4]]],[11,"into","","",173,[[]]],[11,"try_into","","",173,[[],["result",4]]],[11,"borrow","","",173,[[]]],[11,"borrow_mut","","",173,[[]]],[11,"type_id","","",173,[[],["typeid",3]]],[11,"from","","",174,[[]]],[11,"try_from","","",174,[[],["result",4]]],[11,"into","","",174,[[]]],[11,"try_into","","",174,[[],["result",4]]],[11,"borrow","","",174,[[]]],[11,"borrow_mut","","",174,[[]]],[11,"type_id","","",174,[[],["typeid",3]]],[11,"from","sunrise_kernel::panic","",175,[[]]],[11,"try_from","","",175,[[],["result",4]]],[11,"into","","",175,[[]]],[11,"try_into","","",175,[[],["result",4]]],[11,"borrow","","",175,[[]]],[11,"borrow_mut","","",175,[[]]],[11,"type_id","","",175,[[],["typeid",3]]],[11,"into_result","sunrise_kernel::utils::loop_future","",168,[[],["result",4]]],[11,"from_error","","",168,[[],[["poll",4],["option",4]]]],[11,"from_ok","","",168,[[],[["poll",4],["option",4]]]],[11,"into_result","","",168,[[],["result",4]]],[11,"from_error","","",168,[[],[["poll",4],["result",4]]]],[11,"from_ok","","",168,[[],[["poll",4],["result",4]]]],[11,"hash","","",168,[[]]],[11,"partial_cmp","","",168,[[["poll",4]],[["ordering",4],["option",4]]]],[11,"lt","","",168,[[["poll",4]]]],[11,"le","","",168,[[["poll",4]]]],[11,"gt","","",168,[[["poll",4]]]],[11,"ge","","",168,[[["poll",4]]]],[11,"clone","","",168,[[],["poll",4]]],[11,"eq","","",168,[[["poll",4]]]],[11,"ne","","",168,[[["poll",4]]]],[11,"fmt","","",168,[[["formatter",3]],[["result",4],["error",3]]]],[11,"cmp","","",168,[[["poll",4]],["ordering",4]]],[11,"from","","",168,[[],["poll",4]]],[11,"fmt","sunrise_kernel::sync","",116,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::sync::spin_lock","",120,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::sync","",119,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",118,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",117,[[["formatter",3]],[["result",4],["error",3]]]],[11,"deref","","",117,[[]]],[11,"deref","sunrise_kernel::sync::spin_lock","",120,[[]]],[11,"deref","sunrise_kernel::sync","",118,[[]]],[11,"deref_mut","sunrise_kernel::sync::spin_lock","",120,[[]]],[11,"deref_mut","sunrise_kernel::sync","",118,[[]]],[11,"default","","",116,[[],["rwlock",3]]],[11,"drop","sunrise_kernel::sync::spin_lock","The dropping of the MutexGuard will release the lock it…",120,[[]]],[11,"drop","sunrise_kernel::sync","",118,[[]]],[11,"drop","","",117,[[]]],[11,"eq","sunrise_kernel::error","",31,[[["kernelerror",3]]]],[11,"ne","","",31,[[["kernelerror",3]]]],[11,"fmt","","",31,[[["formatter",3]],[["result",4],["error",3]]]],[11,"clone","","",31,[[],["kernelerror",3]]],[11,"fmt","","",31,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::utils::io","Debug volatilely reads `value`.",165,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",163,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::utils::loop_future","",166,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::utils","",170,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",171,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::utils::io","Debug does not access the write only value.",164,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",75,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::utils::loop_future","",167,[[["formatter",3]],[["result",4],["error",3]]]],[11,"poll","","",167,[[["pin",3],["context",3],["loopfn",3]],["poll",4]]],[11,"read","sunrise_kernel::utils::io","Performs a volatile read of the value.",165,[[]]],[11,"write","","Performs a volatile write of the value.",165,[[]]],[11,"read","","Read",75,[[]]],[11,"write","","Write",75,[[]]],[11,"read","","Read",75,[[]]],[11,"write","","Write",75,[[]]],[11,"read","","Read",75,[[]]],[11,"write","","Write",75,[[]]],[11,"clone","","",75,[[],["pio",3]]],[11,"is_unused","sunrise_kernel::paging::arch::i386::entry","Is the entry unused ?",18,[[]]],[11,"set_unused","","Clear the entry",18,[[],[["pagestate",4],["physicaladdress",3]]]],[11,"is_guard","","Is the entry a page guard ?",18,[[]]],[11,"flags","","Get the current entry flags",18,[[],["i386entryflags",3]]],[11,"pointed_frame","","Get the associated physical address, if available",18,[[],[["pagestate",4],["physicaladdress",3]]]],[11,"set","","Sets the entry",18,[[["physicaladdress",3],["i386entryflags",3]]]],[11,"set_guard","","Make this entry a page guard",18,[[]]],[11,"entries","sunrise_kernel::paging::arch::i386::table","",20,[[]]],[11,"table_level","","",20,[[]]],[11,"get_child_table","","Panics, a page table has no children.",20,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[11,"create_child_table","","Panics, a page table has no children.",20,[[],["smarthierarchicaltable",3]]],[11,"entries","","",21,[[]]],[11,"table_level","","",21,[[]]],[11,"get_child_table","","Gets a child [ActivePageTable] through recursive mapping.",21,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[11,"create_child_table","","Creates a child [ActivePageTable], maps it at the given…",21,[[],[["smarthierarchicaltable",3],["activepagetable",3]]]],[11,"entries","","",22,[[]]],[11,"table_level","","",22,[[]]],[11,"get_child_table","","Panics, a page table has no children.",22,[[],[["smarthierarchicaltable",3],["pagestate",4]]]],[11,"create_child_table","","Panics, a page table has no children.",22,[[],["smarthierarchicaltable",3]]],[11,"entries","","",23,[[]]],[11,"table_level","","",23,[[]]],[11,"get_child_table","","Gets the child [InactivePageTable] at the given index.…",23,[[],[["pagestate",4],["smarthierarchicaltable",3]]]],[11,"create_child_table","","Creates a child [InactivePageTable] at the given index,…",23,[[],[["smarthierarchicaltable",3],["inactivepagetable",3]]]],[11,"flush_whole_cache","sunrise_kernel::paging::hierarchical_table","",182,[[]]],[11,"flush_whole_cache","sunrise_kernel::paging::arch::i386::table","",184,[[]]],[11,"get_top_level_table","sunrise_kernel::paging::process_memory","",5,[[],["smarthierarchicaltable",3]]],[11,"map_to_from_iterator","","",5,[[["virtualaddress",3],["mappingaccessrights",3]]]],[11,"guard","","",5,[[["virtualaddress",3]]]],[11,"unmap","","",5,[[["virtualaddress",3]]]],[11,"for_every_entry","","",5,[[["virtualaddress",3]]]],[11,"find_available_virtual_space_aligned","","",5,[[["virtualaddress",3]],[["virtualaddress",3],["option",4]]]],[11,"get_top_level_table","sunrise_kernel::paging::arch::i386::table","Gets the [ActivePageDirectory] through recursive mapping.",183,[[],[["smarthierarchicaltable",3],["activepagedirectory",3]]]],[11,"get_top_level_table","sunrise_kernel::paging","Gets the [InactivePageDirectory] by temporarily mapping it.",0,[[],[["smarthierarchicaltable",3],["inactivepagedirectory",3]]]],[11,"new","","",0,[[]]],[11,"switch_to","","",0,[[]]],[11,"copy_active_kernel_space","","",0,[[]]],[11,"is_currently_active","","",0,[[]]],[11,"from_currently_active","","",0,[[]]],[11,"is_signaled","sunrise_kernel::event","",26,[[]]],[11,"register","","",26,[[]]],[11,"is_signaled","","",28,[[]]],[11,"register","","",28,[[]]],[11,"register","sunrise_kernel::timer","",130,[[]]],[11,"is_signaled","","",130,[[]]],[11,"is_signaled","sunrise_kernel::ipc::session","",151,[[]]],[11,"register","","",151,[[]]],[11,"is_signaled","sunrise_kernel::ipc::port","",159,[[]]],[11,"register","","",159,[[]]],[11,"allocate_region","sunrise_kernel::frame_allocator","Allocates a single [PhysicalMemRegion]. Frames are…",186,[[],[["physicalmemregion",3],["result",4],["kernelerror",4]]]],[11,"allocate_frames_fragmented","","Allocates physical frames, possibly fragmented across…",186,[[],[["vec",3],["kernelerror",4],["result",4]]]],[11,"free_region","","Frees an allocated physical region.",186,[[["physicalmemregion",3]]]],[11,"check_is_allocated","","Checks that a physical region is marked allocated.",186,[[["physicaladdress",3]]]],[11,"check_is_reserved","","Checks that a physical region is marked reserved. This…",186,[[["physicaladdress",3]]]],[11,"lock","sunrise_kernel::sync::spin_lock","",123,[[],["spinlockguard",3]]],[11,"lock","sunrise_kernel::sync::spin_lock_irq","",121,[[],["spinlockirqguard",3]]],[11,"lock","sunrise_kernel::sync","",116,[[],["spinrwlockreadguard",3]]],[11,"lock","","",116,[[],["spinrwlockwriteguard",3]]],[11,"split_at","sunrise_kernel::frame_allocator::physical_mem_region","Splits the given PhysicalMemRegion in two parts, at the…",77,[[],[["result",4],["option",4],["kernelerror",4]]]],[11,"deref","sunrise_kernel::paging::hierarchical_table","",11,[[]]],[11,"deref","sunrise_kernel::i386::gdt","Deref always returns a reference to the table not in use,…",65,[[],["descriptortable",3]]],[11,"deref","sunrise_kernel::i386::interrupt_service_routines","",74,[[],["spinlock",3]]],[11,"deref","sunrise_kernel::heap_allocator","",82,[[],["spinlock",3]]],[11,"deref","sunrise_kernel::devices::pit","",93,[[],["spinlock",3]]],[11,"deref","sunrise_kernel::sync::spin_lock_irq","",122,[[]]],[11,"deref","sunrise_kernel::sync::mutex","",127,[[]]],[11,"deref","sunrise_kernel::mem","",144,[[]]],[11,"deref","","",145,[[]]],[11,"deref","sunrise_kernel::ipc","",147,[[],["spinrwlock",3]]],[11,"deref_mut","sunrise_kernel::paging::hierarchical_table","",11,[[]]],[11,"deref_mut","sunrise_kernel::i386::gdt","DerefMut always returns a reference to the table not in…",65,[[],["descriptortable",3]]],[11,"deref_mut","sunrise_kernel::sync::spin_lock_irq","",122,[[]]],[11,"deref_mut","sunrise_kernel::sync::mutex","",127,[[]]],[11,"deref_mut","sunrise_kernel::mem","",145,[[]]],[11,"from","sunrise_kernel::paging::arch::i386::entry","",17,[[["mappingaccessrights",3]],["i386entryflags",3]]],[11,"from","sunrise_kernel::paging","",1,[[["memorypermissions",3]]]],[11,"from","sunrise_kernel::error","",31,[[["kernelerror",4]],["userspaceerror",3]]],[11,"from","sunrise_kernel::i386::structures::idt","",63,[[],["gatetype",4]]],[11,"from","sunrise_kernel::i386","",53,[[],["privilegelevel",4]]],[11,"from","sunrise_kernel::devices::lapic","",110,[[],["deliverymode",4]]],[11,"from","","",111,[[],["timermode",4]]],[11,"from","sunrise_kernel::devices::ioapic","",115,[[],["deliverymode",4]]],[11,"from","sunrise_kernel::sync::mutex","Creates a new mutex in an unlocked state ready for use.…",124,[[]]],[11,"fmt","sunrise_kernel::paging::process_memory","",3,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::kernel_memory","",6,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::mapping","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::cross_process","",10,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging","",2,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::hierarchical_table","",182,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::arch::i386::entry","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",18,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","sunrise_kernel::paging::arch::i386::table","",19,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",183,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",23,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging","",0,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::lands","",179,[[["formatter",3]],["result",6]]],[11,"fmt","","",180,[[["formatter",3]],["result",6]]],[11,"fmt","","",181,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::bookkeeping","",24,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::process_memory","",4,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging","",1,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::event","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",26,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",29,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::error","",32,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::log_impl::filter::inner","",51,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::log_impl::filter","",50,[[["formatter",3]],["result",6]]],[11,"fmt","","",48,[[["formatter",3]],["result",6]]],[11,"fmt","","",49,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::registers::eflags","",54,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::stack","",55,[[["formatter",3]],["result",6]]],[11,"fmt","","",56,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::structures::gdt","",57,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::structures::idt","",58,[[["formatter",3]],["result",6]]],[11,"fmt","","",59,[[["formatter",3]],["result",6]]],[11,"fmt","","",63,[[["formatter",3]],["result",6]]],[11,"fmt","","",60,[[["formatter",3]],["result",6]]],[11,"fmt","","",61,[[["formatter",3]],["result",6]]],[11,"fmt","","",62,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::process_switch","",64,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::gdt","",70,[[["formatter",3]],["result",6]]],[11,"fmt","","",65,[[["formatter",3]],["result",6]]],[11,"fmt","","",66,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",68,[[["formatter",3]],["result",6]]],[11,"fmt","","",71,[[["formatter",3]],["result",6]]],[11,"fmt","","",69,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::i386::interrupt_service_routines","",73,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::instructions::tables","",76,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386","",53,[[["formatter",3]],["result",6]]],[11,"fmt","","",52,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::frame_allocator::physical_mem_region","",78,[[["formatter",3]],["result",6]]],[11,"fmt","","",77,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","sunrise_kernel::frame_allocator","",186,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::hpet","",83,[[["formatter",3]],["result",6]]],[11,"fmt","","",84,[[["formatter",3]],["result",6]]],[11,"fmt","","",85,[[["formatter",3]],["result",6]]],[11,"fmt","","Debug does not access reserved registers.",86,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",87,[[["formatter",3]],["result",6]]],[11,"fmt","","",88,[[["formatter",3]],["result",6]]],[11,"fmt","","",89,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pic","",90,[[["formatter",3]],["result",6]]],[11,"fmt","","",91,[[["formatter",3]],["result",6]]],[11,"fmt","","",92,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pit","",97,[[["formatter",3]],["result",6]]],[11,"fmt","","",94,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::rs232","",98,[[["formatter",3]],["result",6]]],[11,"fmt","","",101,[[["formatter",3]],["result",6]]],[11,"fmt","","",99,[[["formatter",3]],["result",6]]],[11,"fmt","","",102,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::lapic","",110,[[["formatter",3]],["result",6]]],[11,"fmt","","",111,[[["formatter",3]],["result",6]]],[11,"fmt","","",103,[[["formatter",3]],["result",6]]],[11,"fmt","","",104,[[["formatter",3]],["result",6]]],[11,"fmt","","",105,[[["formatter",3]],["result",6]]],[11,"fmt","","",106,[[["formatter",3]],["result",6]]],[11,"fmt","","",107,[[["formatter",3]],["result",6]]],[11,"fmt","","",109,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::ioapic","",112,[[["formatter",3]],["result",6]]],[11,"fmt","","",115,[[["formatter",3]],["result",6]]],[11,"fmt","","",114,[[["formatter",3]],["result",6]]],[11,"fmt","","",113,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::sync::spin_lock_irq","",121,[[["formatter",3]],["result",6]]],[11,"fmt","","",122,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::sync::spin_lock","",123,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::sync::mutex","",124,[[["formatter",3]],["result",6]]],[11,"fmt","","",127,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::timer","",130,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::process::thread_local_storage","",139,[[["formatter",3]],["result",6]]],[11,"fmt","","",140,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::process::capabilities","",141,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::process","",131,[[["formatter",3]],["result",6]]],[11,"fmt","","",132,[[["formatter",3]],["result",6]]],[11,"fmt","","",133,[[["formatter",3]],["result",6]]],[11,"fmt","","",134,[[["formatter",3]],["result",6]]],[11,"fmt","","",137,[[["formatter",3]],["result",6]]],[11,"fmt","","",135,[[["formatter",3]],["result",6]]],[11,"fmt","","",136,[[["formatter",3]],["result",6]]],[11,"fmt","","",138,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::mem","",142,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",143,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",144,[[["formatter",3]],["result",6]]],[11,"fmt","","",145,[[["formatter",3]],["result",6]]],[11,"fmt","","",146,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::ipc::session","",148,[[["formatter",3]],["result",6]]],[11,"fmt","","",149,[[["formatter",3]],["result",6]]],[11,"fmt","","",150,[[["formatter",3]],["result",6]]],[11,"fmt","","",151,[[["formatter",3]],["result",6]]],[11,"fmt","","",152,[[["formatter",3]],["result",6]]],[11,"fmt","","",153,[[["formatter",3]],["result",6]]],[11,"fmt","","",154,[[["formatter",3]],["result",6]]],[11,"fmt","","",155,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::ipc::port","",157,[[["formatter",3]],["result",6]]],[11,"fmt","","",158,[[["formatter",3]],["result",6]]],[11,"fmt","","",159,[[["formatter",3]],["result",6]]],[11,"fmt","","",160,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::elf_loader","",161,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::cpu_locals","",173,[[["formatter",3]],["result",6]]],[11,"fmt","","",174,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::error","",32,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::log_impl::filter::inner","",51,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::interrupt_service_routines","",73,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_kernel::devices::rs232","",99,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","sunrise_kernel::sync::mutex","",127,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::mem","",142,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",143,[[["formatter",3]],[["error",3],["result",4]]]],[11,"sub","sunrise_kernel::paging::arch::i386::entry","Returns the set difference of the two sets of flags.",17,[[["i386entryflags",3]],["i386entryflags",3]]],[11,"sub","sunrise_kernel::paging","Returns the set difference of the two sets of flags.",1,[[["mappingaccessrights",3]],["mappingaccessrights",3]]],[11,"sub","sunrise_kernel::i386::registers::eflags","Returns the set difference of the two sets of flags.",54,[[["eflags",3]],["eflags",3]]],[11,"sub","sunrise_kernel::i386::structures::idt","Returns the set difference of the two sets of flags.",62,[[["pagefaulterrorcode",3]],["pagefaulterrorcode",3]]],[11,"sub","sunrise_kernel::devices::pic","Returns the set difference of the two sets of flags.",90,[[["icw1",3]],["icw1",3]]],[11,"sub","sunrise_kernel::devices::pit","Returns the set difference of the two sets of flags.",94,[[["port61flags",3]],["port61flags",3]]],[11,"sub","sunrise_kernel::devices::lapic","Returns the set difference of the two sets of flags.",107,[[["error",3]],["error",3]]],[11,"sub","sunrise_kernel::mem","Subtracting a length from an address gives another address",143,[[],["virtualaddress",3]]],[11,"sub","","Subtracting a length from an address gives another address",142,[[],["physicaladdress",3]]],[11,"sub","","Subtracting two address gives their distance",143,[[["virtualaddress",3]]]],[11,"sub","","Subtracting two address gives their distance",142,[[["physicaladdress",3]]]],[11,"eq","sunrise_kernel::paging::arch::i386::entry","",17,[[["i386entryflags",3]]]],[11,"ne","","",17,[[["i386entryflags",3]]]],[11,"eq","sunrise_kernel::paging","",1,[[["mappingaccessrights",3]]]],[11,"ne","","",1,[[["mappingaccessrights",3]]]],[11,"eq","sunrise_kernel::i386::registers::eflags","",54,[[["eflags",3]]]],[11,"ne","","",54,[[["eflags",3]]]],[11,"eq","sunrise_kernel::i386::structures::idt","",63,[[["gatetype",4]]]],[11,"eq","","",62,[[["pagefaulterrorcode",3]]]],[11,"ne","","",62,[[["pagefaulterrorcode",3]]]],[11,"eq","sunrise_kernel::i386","",53,[[["privilegelevel",4]]]],[11,"eq","sunrise_kernel::devices::pic","",90,[[["icw1",3]]]],[11,"ne","","",90,[[["icw1",3]]]],[11,"eq","sunrise_kernel::devices::pit","",94,[[["port61flags",3]]]],[11,"ne","","",94,[[["port61flags",3]]]],[11,"eq","sunrise_kernel::devices::lapic","",107,[[["error",3]]]],[11,"ne","","",107,[[["error",3]]]],[11,"eq","sunrise_kernel::process","",138,[[["threadstate",4]]]],[11,"eq","sunrise_kernel::mem","",142,[[["physicaladdress",3]]]],[11,"ne","","",142,[[["physicaladdress",3]]]],[11,"eq","","",143,[[["virtualaddress",3]]]],[11,"ne","","",143,[[["virtualaddress",3]]]],[11,"cmp","sunrise_kernel::paging::arch::i386::entry","",17,[[["i386entryflags",3]],["ordering",4]]],[11,"cmp","sunrise_kernel::paging","",1,[[["mappingaccessrights",3]],["ordering",4]]],[11,"cmp","sunrise_kernel::i386::registers::eflags","",54,[[["eflags",3]],["ordering",4]]],[11,"cmp","sunrise_kernel::i386::structures::idt","",62,[[["pagefaulterrorcode",3]],["ordering",4]]],[11,"cmp","sunrise_kernel::devices::pic","",90,[[["icw1",3]],["ordering",4]]],[11,"cmp","sunrise_kernel::devices::pit","",94,[[["port61flags",3]],["ordering",4]]],[11,"cmp","sunrise_kernel::devices::lapic","",107,[[["error",3]],["ordering",4]]],[11,"cmp","sunrise_kernel::mem","",142,[[["physicaladdress",3]],["ordering",4]]],[11,"cmp","","",143,[[["virtualaddress",3]],["ordering",4]]],[11,"partial_cmp","sunrise_kernel::paging::arch::i386::entry","",17,[[["i386entryflags",3]],[["option",4],["ordering",4]]]],[11,"lt","","",17,[[["i386entryflags",3]]]],[11,"le","","",17,[[["i386entryflags",3]]]],[11,"gt","","",17,[[["i386entryflags",3]]]],[11,"ge","","",17,[[["i386entryflags",3]]]],[11,"partial_cmp","sunrise_kernel::paging","",1,[[["mappingaccessrights",3]],[["option",4],["ordering",4]]]],[11,"lt","","",1,[[["mappingaccessrights",3]]]],[11,"le","","",1,[[["mappingaccessrights",3]]]],[11,"gt","","",1,[[["mappingaccessrights",3]]]],[11,"ge","","",1,[[["mappingaccessrights",3]]]],[11,"partial_cmp","sunrise_kernel::i386::registers::eflags","",54,[[["eflags",3]],[["option",4],["ordering",4]]]],[11,"lt","","",54,[[["eflags",3]]]],[11,"le","","",54,[[["eflags",3]]]],[11,"gt","","",54,[[["eflags",3]]]],[11,"ge","","",54,[[["eflags",3]]]],[11,"partial_cmp","sunrise_kernel::i386::structures::idt","",62,[[["pagefaulterrorcode",3]],[["option",4],["ordering",4]]]],[11,"lt","","",62,[[["pagefaulterrorcode",3]]]],[11,"le","","",62,[[["pagefaulterrorcode",3]]]],[11,"gt","","",62,[[["pagefaulterrorcode",3]]]],[11,"ge","","",62,[[["pagefaulterrorcode",3]]]],[11,"partial_cmp","sunrise_kernel::devices::pic","",90,[[["icw1",3]],[["option",4],["ordering",4]]]],[11,"lt","","",90,[[["icw1",3]]]],[11,"le","","",90,[[["icw1",3]]]],[11,"gt","","",90,[[["icw1",3]]]],[11,"ge","","",90,[[["icw1",3]]]],[11,"partial_cmp","sunrise_kernel::devices::pit","",94,[[["port61flags",3]],[["option",4],["ordering",4]]]],[11,"lt","","",94,[[["port61flags",3]]]],[11,"le","","",94,[[["port61flags",3]]]],[11,"gt","","",94,[[["port61flags",3]]]],[11,"ge","","",94,[[["port61flags",3]]]],[11,"partial_cmp","sunrise_kernel::devices::lapic","",107,[[["error",3]],[["option",4],["ordering",4]]]],[11,"lt","","",107,[[["error",3]]]],[11,"le","","",107,[[["error",3]]]],[11,"gt","","",107,[[["error",3]]]],[11,"ge","","",107,[[["error",3]]]],[11,"partial_cmp","sunrise_kernel::mem","",142,[[["physicaladdress",3]],[["option",4],["ordering",4]]]],[11,"lt","","",142,[[["physicaladdress",3]]]],[11,"le","","",142,[[["physicaladdress",3]]]],[11,"gt","","",142,[[["physicaladdress",3]]]],[11,"ge","","",142,[[["physicaladdress",3]]]],[11,"partial_cmp","","",143,[[["virtualaddress",3]],[["option",4],["ordering",4]]]],[11,"lt","","",143,[[["virtualaddress",3]]]],[11,"le","","",143,[[["virtualaddress",3]]]],[11,"gt","","",143,[[["virtualaddress",3]]]],[11,"ge","","",143,[[["virtualaddress",3]]]],[11,"add","","Adding a length to an address gives another address",143,[[],["virtualaddress",3]]],[11,"add","","Adding a length to an address gives another address",142,[[],["physicaladdress",3]]],[11,"add_assign","","Adding a length to an address gives another address",143,[[]]],[11,"add_assign","","Adding a length to an address gives another address",142,[[]]],[11,"sub_assign","sunrise_kernel::paging::arch::i386::entry","Disables all flags enabled in the set.",17,[[["i386entryflags",3]]]],[11,"sub_assign","sunrise_kernel::paging","Disables all flags enabled in the set.",1,[[["mappingaccessrights",3]]]],[11,"sub_assign","sunrise_kernel::i386::registers::eflags","Disables all flags enabled in the set.",54,[[["eflags",3]]]],[11,"sub_assign","sunrise_kernel::i386::structures::idt","Disables all flags enabled in the set.",62,[[["pagefaulterrorcode",3]]]],[11,"sub_assign","sunrise_kernel::devices::pic","Disables all flags enabled in the set.",90,[[["icw1",3]]]],[11,"sub_assign","sunrise_kernel::devices::pit","Disables all flags enabled in the set.",94,[[["port61flags",3]]]],[11,"sub_assign","sunrise_kernel::devices::lapic","Disables all flags enabled in the set.",107,[[["error",3]]]],[11,"sub_assign","sunrise_kernel::mem","Subtracting a length from an address gives another address",143,[[]]],[11,"sub_assign","","Subtracting a length from an address gives another address",142,[[]]],[11,"not","sunrise_kernel::paging::arch::i386::entry","Returns the complement of this set of flags.",17,[[],["i386entryflags",3]]],[11,"not","sunrise_kernel::paging","Returns the complement of this set of flags.",1,[[],["mappingaccessrights",3]]],[11,"not","sunrise_kernel::i386::registers::eflags","Returns the complement of this set of flags.",54,[[],["eflags",3]]],[11,"not","sunrise_kernel::i386::structures::idt","Returns the complement of this set of flags.",62,[[],["pagefaulterrorcode",3]]],[11,"not","sunrise_kernel::devices::pic","Returns the complement of this set of flags.",90,[[],["icw1",3]]],[11,"not","sunrise_kernel::devices::pit","Returns the complement of this set of flags.",94,[[],["port61flags",3]]],[11,"not","sunrise_kernel::devices::lapic","Returns the complement of this set of flags.",107,[[],["error",3]]],[11,"bitand","sunrise_kernel::paging::arch::i386::entry","Returns the intersection between the two sets of flags.",17,[[["i386entryflags",3]],["i386entryflags",3]]],[11,"bitand","sunrise_kernel::paging","Returns the intersection between the two sets of flags.",1,[[["mappingaccessrights",3]],["mappingaccessrights",3]]],[11,"bitand","sunrise_kernel::i386::registers::eflags","Returns the intersection between the two sets of flags.",54,[[["eflags",3]],["eflags",3]]],[11,"bitand","sunrise_kernel::i386::structures::idt","Returns the intersection between the two sets of flags.",62,[[["pagefaulterrorcode",3]],["pagefaulterrorcode",3]]],[11,"bitand","sunrise_kernel::devices::pic","Returns the intersection between the two sets of flags.",90,[[["icw1",3]],["icw1",3]]],[11,"bitand","sunrise_kernel::devices::pit","Returns the intersection between the two sets of flags.",94,[[["port61flags",3]],["port61flags",3]]],[11,"bitand","sunrise_kernel::devices::lapic","Returns the intersection between the two sets of flags.",107,[[["error",3]],["error",3]]],[11,"bitor","sunrise_kernel::paging::arch::i386::entry","Returns the union of the two sets of flags.",17,[[["i386entryflags",3]],["i386entryflags",3]]],[11,"bitor","sunrise_kernel::paging","Returns the union of the two sets of flags.",1,[[["mappingaccessrights",3]],["mappingaccessrights",3]]],[11,"bitor","sunrise_kernel::i386::registers::eflags","Returns the union of the two sets of flags.",54,[[["eflags",3]],["eflags",3]]],[11,"bitor","sunrise_kernel::i386::structures::idt","Returns the union of the two sets of flags.",62,[[["pagefaulterrorcode",3]],["pagefaulterrorcode",3]]],[11,"bitor","sunrise_kernel::devices::pic","Returns the union of the two sets of flags.",90,[[["icw1",3]],["icw1",3]]],[11,"bitor","sunrise_kernel::devices::pit","Returns the union of the two sets of flags.",94,[[["port61flags",3]],["port61flags",3]]],[11,"bitor","sunrise_kernel::devices::lapic","Returns the union of the two sets of flags.",107,[[["error",3]],["error",3]]],[11,"bitxor","sunrise_kernel::paging::arch::i386::entry","Returns the left flags, but with all the right flags…",17,[[["i386entryflags",3]],["i386entryflags",3]]],[11,"bitxor","sunrise_kernel::paging","Returns the left flags, but with all the right flags…",1,[[["mappingaccessrights",3]],["mappingaccessrights",3]]],[11,"bitxor","sunrise_kernel::i386::registers::eflags","Returns the left flags, but with all the right flags…",54,[[["eflags",3]],["eflags",3]]],[11,"bitxor","sunrise_kernel::i386::structures::idt","Returns the left flags, but with all the right flags…",62,[[["pagefaulterrorcode",3]],["pagefaulterrorcode",3]]],[11,"bitxor","sunrise_kernel::devices::pic","Returns the left flags, but with all the right flags…",90,[[["icw1",3]],["icw1",3]]],[11,"bitxor","sunrise_kernel::devices::pit","Returns the left flags, but with all the right flags…",94,[[["port61flags",3]],["port61flags",3]]],[11,"bitxor","sunrise_kernel::devices::lapic","Returns the left flags, but with all the right flags…",107,[[["error",3]],["error",3]]],[11,"bitand_assign","sunrise_kernel::paging::arch::i386::entry","Disables all flags disabled in the set.",17,[[["i386entryflags",3]]]],[11,"bitand_assign","sunrise_kernel::paging","Disables all flags disabled in the set.",1,[[["mappingaccessrights",3]]]],[11,"bitand_assign","sunrise_kernel::i386::registers::eflags","Disables all flags disabled in the set.",54,[[["eflags",3]]]],[11,"bitand_assign","sunrise_kernel::i386::structures::idt","Disables all flags disabled in the set.",62,[[["pagefaulterrorcode",3]]]],[11,"bitand_assign","sunrise_kernel::devices::pic","Disables all flags disabled in the set.",90,[[["icw1",3]]]],[11,"bitand_assign","sunrise_kernel::devices::pit","Disables all flags disabled in the set.",94,[[["port61flags",3]]]],[11,"bitand_assign","sunrise_kernel::devices::lapic","Disables all flags disabled in the set.",107,[[["error",3]]]],[11,"bitor_assign","sunrise_kernel::paging::arch::i386::entry","Adds the set of flags.",17,[[["i386entryflags",3]]]],[11,"bitor_assign","sunrise_kernel::paging","Adds the set of flags.",1,[[["mappingaccessrights",3]]]],[11,"bitor_assign","sunrise_kernel::i386::registers::eflags","Adds the set of flags.",54,[[["eflags",3]]]],[11,"bitor_assign","sunrise_kernel::i386::structures::idt","Adds the set of flags.",62,[[["pagefaulterrorcode",3]]]],[11,"bitor_assign","sunrise_kernel::devices::pic","Adds the set of flags.",90,[[["icw1",3]]]],[11,"bitor_assign","sunrise_kernel::devices::pit","Adds the set of flags.",94,[[["port61flags",3]]]],[11,"bitor_assign","sunrise_kernel::devices::lapic","Adds the set of flags.",107,[[["error",3]]]],[11,"bitxor_assign","sunrise_kernel::paging::arch::i386::entry","Toggles the set of flags.",17,[[["i386entryflags",3]]]],[11,"bitxor_assign","sunrise_kernel::paging","Toggles the set of flags.",1,[[["mappingaccessrights",3]]]],[11,"bitxor_assign","sunrise_kernel::i386::registers::eflags","Toggles the set of flags.",54,[[["eflags",3]]]],[11,"bitxor_assign","sunrise_kernel::i386::structures::idt","Toggles the set of flags.",62,[[["pagefaulterrorcode",3]]]],[11,"bitxor_assign","sunrise_kernel::devices::pic","Toggles the set of flags.",90,[[["icw1",3]]]],[11,"bitxor_assign","sunrise_kernel::devices::pit","Toggles the set of flags.",94,[[["port61flags",3]]]],[11,"bitxor_assign","sunrise_kernel::devices::lapic","Toggles the set of flags.",107,[[["error",3]]]],[11,"drop","sunrise_kernel::paging::cross_process","",10,[[]]],[11,"drop","sunrise_kernel::paging::hierarchical_table","",11,[[]]],[11,"drop","sunrise_kernel::paging::arch::i386::table","When the temporary inactive directory is drop, we unmap it.",23,[[]]],[11,"drop","","When the temporary inactive table is drop, we unmap it.",22,[[]]],[11,"drop","sunrise_kernel::paging","When a process dies, its InactiveHierarchy is dropped. The…",0,[[]]],[11,"drop","sunrise_kernel::i386::stack","We deallocate the stack when it is dropped",55,[[]]],[11,"drop","sunrise_kernel::frame_allocator::physical_mem_region","Dropping a `PhysicalMemRegion` may free its frames.",77,[[]]],[11,"drop","sunrise_kernel::sync::spin_lock_irq","",122,[[]]],[11,"drop","sunrise_kernel::sync::mutex","",127,[[]]],[11,"drop","sunrise_kernel::process","",133,[[]]],[11,"drop","","Late thread death notifications:",134,[[]]],[11,"drop","sunrise_kernel::ipc::session","",151,[[]]],[11,"drop","sunrise_kernel::ipc::port","",159,[[]]],[11,"drop","sunrise_kernel::elf_loader","Unmap the module, but do not deallocate physical memory",161,[[]]],[11,"drop","sunrise_kernel::cpu_locals","Dropping a CpuLocalRegion deallocates it.",174,[[]]],[11,"index","sunrise_kernel::i386::structures::idt","",58,[[]]],[11,"index_mut","","",58,[[]]],[11,"hash","sunrise_kernel::paging::arch::i386::entry","",17,[[]]],[11,"hash","sunrise_kernel::paging","",1,[[]]],[11,"hash","sunrise_kernel::i386::registers::eflags","",54,[[]]],[11,"hash","sunrise_kernel::i386::structures::idt","",62,[[]]],[11,"hash","sunrise_kernel::devices::pic","",90,[[]]],[11,"hash","sunrise_kernel::devices::pit","",94,[[]]],[11,"hash","sunrise_kernel::devices::lapic","",107,[[]]],[11,"hash","sunrise_kernel::mem","",142,[[]]],[11,"hash","","",143,[[]]],[11,"steps_between","","",142,[[],["option",4]]],[11,"forward_checked","","",142,[[],["option",4]]],[11,"backward_checked","","",142,[[],["option",4]]],[11,"steps_between","","",143,[[],["option",4]]],[11,"forward_checked","","",143,[[],["option",4]]],[11,"backward_checked","","",143,[[],["option",4]]],[11,"next","sunrise_kernel::frame_allocator::physical_mem_region","",78,[[],[["option",4],["physicaladdress",3]]]],[11,"extend","sunrise_kernel::paging::arch::i386::entry","",17,[[["intoiterator",8]]]],[11,"extend","sunrise_kernel::paging","",1,[[["intoiterator",8]]]],[11,"extend","sunrise_kernel::i386::registers::eflags","",54,[[["intoiterator",8]]]],[11,"extend","sunrise_kernel::i386::structures::idt","",62,[[["intoiterator",8]]]],[11,"extend","sunrise_kernel::devices::pic","",90,[[["intoiterator",8]]]],[11,"extend","sunrise_kernel::devices::pit","",94,[[["intoiterator",8]]]],[11,"extend","sunrise_kernel::devices::lapic","",107,[[["intoiterator",8]]]],[11,"from_iter","sunrise_kernel::paging::arch::i386::entry","",17,[[["intoiterator",8]],["i386entryflags",3]]],[11,"from_iter","sunrise_kernel::paging","",1,[[["intoiterator",8]],["mappingaccessrights",3]]],[11,"from_iter","sunrise_kernel::i386::registers::eflags","",54,[[["intoiterator",8]],["eflags",3]]],[11,"from_iter","sunrise_kernel::i386::structures::idt","",62,[[["intoiterator",8]],["pagefaulterrorcode",3]]],[11,"from_iter","sunrise_kernel::devices::pic","",90,[[["intoiterator",8]],["icw1",3]]],[11,"from_iter","sunrise_kernel::devices::pit","",94,[[["intoiterator",8]],["port61flags",3]]],[11,"from_iter","sunrise_kernel::devices::lapic","",107,[[["intoiterator",8]],["error",3]]],[11,"write_str","sunrise_kernel::devices::rs232","Writes a string to COM1.",102,[[],[["result",4],["error",3]]]],[11,"into","sunrise_kernel::mem","",145,[[],["userspaceptr",3]]],[11,"fmt","sunrise_kernel::paging::arch::i386::entry","",17,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging","",1,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::registers::eflags","",54,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::structures::idt","",62,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pic","",90,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pit","",94,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::lapic","",107,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::arch::i386::entry","",17,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging","",1,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::registers::eflags","",54,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::structures::idt","",62,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pic","",90,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pit","",94,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::lapic","",107,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging::arch::i386::entry","",17,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging","",1,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::registers::eflags","",54,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::structures::idt","",62,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pic","",90,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pit","",94,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::lapic","",107,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::mem","",142,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",143,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","sunrise_kernel::paging::arch::i386::entry","",17,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::paging","",1,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::registers::eflags","",54,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::i386::structures::idt","",62,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pic","",90,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::pit","",94,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_kernel::devices::lapic","",107,[[["formatter",3]],["result",6]]],[11,"clone","sunrise_kernel::paging::arch::i386::entry","",17,[[],["i386entryflags",3]]],[11,"clone","","",18,[[],["i386entry",3]]],[11,"clone","sunrise_kernel::paging","",1,[[],["mappingaccessrights",3]]],[11,"clone","sunrise_kernel::event","",26,[[],["readableevent",3]]],[11,"clone","","",27,[[],["writableevent",3]]],[11,"clone","sunrise_kernel::i386::registers::eflags","",54,[[],["eflags",3]]],[11,"clone","sunrise_kernel::i386::structures::gdt","",57,[[],["segmentselector",3]]],[11,"clone","sunrise_kernel::i386::structures::idt","",59,[[],["idtentry",3]]],[11,"clone","","",63,[[],["gatetype",4]]],[11,"clone","","",60,[[],["entryoptions",3]]],[11,"clone","","",62,[[],["pagefaulterrorcode",3]]],[11,"clone","sunrise_kernel::i386::gdt","",70,[[],["gdtindex",4]]],[11,"clone","","",68,[[],["descriptortable",3]]],[11,"clone","","",71,[[],["systemdescriptortypes",4]]],[11,"clone","","",69,[[],["descriptortableentry",3]]],[11,"clone","sunrise_kernel::i386::interrupt_service_routines","",73,[[],["userspacehardwarecontext",3]]],[11,"clone","sunrise_kernel::i386::instructions::tables","",76,[[],["descriptortablepointer",3]]],[11,"clone","sunrise_kernel::i386","",53,[[],["privilegelevel",4]]],[11,"clone","","",52,[[],["tssstruct",3]]],[11,"clone","sunrise_kernel::frame_allocator::physical_mem_region","",78,[[],["physicalmemregioniter",3]]],[11,"clone","sunrise_kernel::devices::hpet","",83,[[],["hpetidregister",3]]],[11,"clone","","",84,[[],["hpetgeneralconfigurationregister",3]]],[11,"clone","","",85,[[],["hpettimerconfigurationregister",3]]],[11,"clone","sunrise_kernel::devices::pic","",90,[[],["icw1",3]]],[11,"clone","sunrise_kernel::devices::pit","",97,[[],["channelselector",4]]],[11,"clone","","",94,[[],["port61flags",3]]],[11,"clone","sunrise_kernel::devices::rs232","",98,[[],["comport",3]]],[11,"clone","","",101,[[],["serialcolor",4]]],[11,"clone","","",99,[[],["serialattributes",3]]],[11,"clone","sunrise_kernel::devices::lapic","",110,[[],["deliverymode",4]]],[11,"clone","","",111,[[],["timermode",4]]],[11,"clone","","",104,[[],["localapicversion",3]]],[11,"clone","","",105,[[],["localvector",3]]],[11,"clone","","",106,[[],["spuriousinterrupt",3]]],[11,"clone","","",107,[[],["error",3]]],[11,"clone","sunrise_kernel::devices::ioapic","",115,[[],["deliverymode",4]]],[11,"clone","sunrise_kernel::process","",138,[[],["threadstate",4]]],[11,"clone","sunrise_kernel::mem","",142,[[],["physicaladdress",3]]],[11,"clone","","",143,[[],["virtualaddress",3]]],[11,"clone","","",144,[[],["userspaceptr",3]]],[11,"clone","","",145,[[],["userspaceptrmut",3]]],[11,"clone","sunrise_kernel::ipc::session","",150,[[],["clientsession",3]]],[11,"clone","","",151,[[]]],[11,"clone","sunrise_kernel::ipc::port","",158,[[],["clientport",3]]],[11,"clone","","",159,[[]]],[11,"default","sunrise_kernel::paging::process_memory","Creates a ProcessMemory, allocating the…",3,[[]]],[11,"default","sunrise_kernel::log_impl::filter","",49,[[]]],[11,"default","sunrise_kernel::i386::process_switch","Creates an empty ThreadHardwareContext.",64,[[]]],[11,"default","sunrise_kernel::i386::gdt","",65,[[],["gdtmanager",3]]],[11,"default","","",68,[[],["descriptortable",3]]],[11,"default","","",69,[[]]],[11,"default","sunrise_kernel::i386::interrupt_service_routines","",73,[[],["userspacehardwarecontext",3]]],[11,"default","sunrise_kernel::sync::spin_lock","",123,[[],["spinlock",3]]],[11,"default","sunrise_kernel::sync::mutex","Creates a `Mutex<T>`, with the `Default` value for T.",124,[[],["mutex",3]]],[11,"default","sunrise_kernel::process::thread_local_storage","",140,[[],["tlsmanager",3]]],[11,"default","sunrise_kernel::process","",131,[[]]],[11,"default","","Creates an empty handle table. Note that an empty handle…",136,[[]]],[11,"alloc","sunrise_kernel::heap_allocator","",82,[[["layout",3]]]],[11,"dealloc","","",82,[[["layout",3]]]],[11,"initialize","sunrise_kernel::i386::interrupt_service_routines","",74,[[]]],[11,"initialize","sunrise_kernel::devices::pit","",93,[[]]],[11,"initialize","sunrise_kernel::ipc","",147,[[]]],[11,"enabled","sunrise_kernel::log_impl","",47,[[["metadata",3]]]],[11,"log","","",47,[[["record",3]]]],[11,"flush","","",47,[[]]],[11,"name","sunrise_kernel::error","",32,[[],["option",4]]],[11,"cause","","",32,[[],[["fail",8],["option",4]]]],[11,"backtrace","","",32,[[],[["backtrace",3],["option",4]]]],[11,"bit_range","sunrise_kernel::i386::structures::idt","",60,[[]]],[11,"set_bit_range","","",60,[[]]],[11,"bit_range","sunrise_kernel::devices::hpet","",83,[[]]],[11,"set_bit_range","","",83,[[]]],[11,"bit_range","","",84,[[]]],[11,"set_bit_range","","",84,[[]]],[11,"bit_range","","",85,[[]]],[11,"set_bit_range","","",85,[[]]],[11,"bit_range","sunrise_kernel::devices::lapic","",104,[[]]],[11,"set_bit_range","","",104,[[]]],[11,"bit_range","","",105,[[]]],[11,"set_bit_range","","",105,[[]]],[11,"bit_range","","",106,[[]]],[11,"set_bit_range","","",106,[[]]],[11,"bit_range","sunrise_kernel::devices::ioapic","",114,[[]]],[11,"set_bit_range","","",114,[[]]],[11,"bit_range","sunrise_kernel::ipc::session","",152,[[]]],[11,"set_bit_range","","",152,[[]]],[11,"bit_range","","",153,[[]]],[11,"set_bit_range","","",153,[[]]],[11,"read","sunrise_kernel::devices::lapic","",103,[[]]],[11,"write","","",103,[[]]],[11,"map_physical_region","sunrise_kernel::i386::acpi","",185,[[],["physicalmapping",3]]],[11,"unmap_physical_region","","",185,[[["physicalmapping",3]]]],[11,"make_ret","sunrise_kernel::error","Transforms a KernelError into the encoding acceptable for…",31,[[]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",31,[[],["kernelerror",3]]],[11,"from_description","","Turns a kernel error description into a KernelError.",31,[[],["kernelerror",3]]],[11,"description","","Gets the underlying KernelError description.",31,[[]]],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",31,null],[18,"NotImplemented","","This function is not implemented.",31,null],[18,"InvalidSize","","The size argument is invalid.",31,null],[18,"InvalidAddress","","The passed address is invalid.",31,null],[18,"MemoryFull","","The virtual address space was exhausted.",31,null],[18,"HandleTableFull","","The process\' handle table is full.",31,null],[18,"InvalidMemState","","The memory state is invalid for this action.",31,null],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",31,null],[18,"InvalidMemRange","","Memory range is not at an expected location.",31,null],[18,"InvalidThreadPriority","","Invalid thread priority. Thread priority should be within…",31,null],[18,"InvalidProcessorId","","Invalid processor id. Processor ID should exist on the…",31,null],[18,"InvalidHandle","","Passed handle is invalid.",31,null],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",31,null],[18,"InvalidCombination","","The combination of argument is invalid.",31,null],[18,"Timeout","","A timeout was reached.",31,null],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",31,null],[18,"ExceedingMaximum","","A size or address was given exceeding the maximum allowed…",31,null],[18,"InvalidEnum","","No enum variants match this integer value.",31,null],[18,"NoSuchEntry","","The given entry does not exist.",31,null],[18,"PortRemoteDead","","The remote part of the session was closed.",31,null],[18,"InvalidState","","Attempted to do an operation that\'s invalid in the…",31,null],[18,"ReservedValue","","Attempted to use an unknown value, reserved for future use.",31,null],[11,"new","sunrise_kernel::utils::io","Create a PIO from a given port",75,[[],["pio",3]]],[11,"new","sunrise_kernel::sync","Creates a new spinlock wrapping the supplied data.",116,[[],["rwlock",3]]],[11,"into_inner","","Consumes this `RwLock`, returning the underlying data.",116,[[]]],[11,"read","","Locks this rwlock with shared read access, blocking the…",116,[[],["rwlockreadguard",3]]],[11,"try_read","","Attempt to acquire this lock with shared read access.",116,[[],[["option",4],["rwlockreadguard",3]]]],[11,"force_read_decrement","","Force decrement the reader count.",116,[[]]],[11,"force_write_unlock","","Force unlock exclusive write access.",116,[[]]],[11,"write","","Lock this rwlock with exclusive write access, blocking the…",116,[[],["rwlockwriteguard",3]]],[11,"try_write","","Attempt to lock this rwlock with exclusive write access.",116,[[],[["option",4],["rwlockwriteguard",3]]]],[11,"upgradeable_read","","Obtain a readable lock guard that can later be upgraded to…",116,[[],["rwlockupgradeableguard",3]]],[11,"try_upgradeable_read","","Tries to obtain an upgradeable lock guard.",116,[[],[["option",4],["rwlockupgradeableguard",3]]]],[11,"downgrade","","Downgrades the writable lock guard to a readable, shared…",118,[[],["rwlockreadguard",3]]],[18,"INIT","","Initialization constant of `Once`.",119,null],[11,"new","","Creates a new `Once` value.",119,[[],["once",3]]],[11,"call_once","","Performs an initialization routine once and only once. The…",119,[[]]],[11,"try","","Returns a pointer iff the `Once` was previously initialized",119,[[],["option",4]]],[11,"wait","","Like try, but will spin if the `Once` is in the process of…",119,[[],["option",4]]],[11,"new","sunrise_kernel::utils::io","Create a read-only wrapper around the IO device address.",163,[[],["readonly",3]]],[11,"read","","Reads from this Io.",163,[[]]],[11,"readf","","Read from this Io, and mask the value with `flags`.",163,[[]]],[11,"new","","Creates a WriteOnly Io.",164,[[],["writeonly",3]]],[11,"write","","Writes `value` to this Io.",164,[[]]],[11,"new","","Create a new Mmio without initializing.",165,[[],["mmio",3]]],[11,"map","sunrise_kernel::utils::loop_future","Changes the ready value of this `Poll` with the closure…",168,[[],["poll",4]]],[11,"is_ready","","Returns `true` if this is `Poll::Ready`",168,[[]]],[11,"is_pending","","Returns `true` if this is `Poll::Pending`",168,[[]]],[11,"map_ok","","Changes the success value of this `Poll` with the closure…",168,[[],[["poll",4],["result",4]]]],[11,"map_err","","Changes the error value of this `Poll` with the closure…",168,[[],[["result",4],["poll",4]]]],[11,"map_ok","","Changes the success value of this `Poll` with the closure…",168,[[],[["poll",4],["option",4]]]],[11,"map_err","","Changes the error value of this `Poll` with the closure…",168,[[],[["option",4],["poll",4]]]],[11,"new","sunrise_kernel::utils","Creates a new cursor wrapping the provided underlying…",170,[[],["cursorwrite",3]]],[11,"pos","","Returns the current position of this cursor.",170,[[]]],[11,"skip_write","","Skip the given amount of bytes, returning a mutable slice…",170,[[]]],[11,"write_u8","","Writes an u8 in the given byte ordering.",170,[[]]],[11,"write_u16","","Writes a u16 in the given byte ordering.",170,[[]]],[11,"write_u32","","Writes a u32 in the given byte ordering.",170,[[]]],[11,"write_u64","","Writes a u64 in the given byte ordering.",170,[[]]],[11,"write","","Writes the given byte slice entirely.",170,[[]]],[11,"write_raw","","Writes the given structure.",170,[[]]],[11,"new","","Creates a new cursor wrapping the provided underlying…",171,[[],["cursorread",3]]],[11,"pos","","Returns the current position of this cursor.",171,[[]]],[11,"read_u8","","Reads an u8 in the given byteorder.",171,[[]]],[11,"read_u16","","Reads an u16 in the given byteorder.",171,[[]]],[11,"read_u32","","Reads an u32 in the given byteorder.",171,[[]]],[11,"read_u64","","Reads an u64 in the given byteorder.",171,[[]]],[11,"assert","","Reads `v.len()` bytes from the stream, and asserts that it…",171,[[]]],[11,"skip_read","","Skips `bytelen` bytes, returning a slice to them for…",171,[[]]],[11,"read_raw","","Reads the given structure from the bytestream.",171,[[]]]],"p":[[3,"InactiveHierarchy"],[3,"MappingAccessRights"],[4,"PageState"],[3,"ProcessMemory"],[4,"QueryMemory"],[4,"DynamicHierarchy"],[3,"KernelMemory"],[8,"VirtualSpaceLand"],[3,"Mapping"],[4,"MappingFrames"],[3,"CrossProcessMapping"],[3,"SmartHierarchicalTable"],[8,"HierarchicalEntry"],[8,"HierarchicalTable"],[8,"PagingCacheFlusher"],[8,"TableHierarchy"],[8,"InactiveHierarchyTrait"],[3,"I386EntryFlags"],[3,"I386Entry"],[3,"Table"],[3,"ActivePageTable"],[3,"ActivePageDirectory"],[3,"InactivePageTable"],[3,"InactivePageDirectory"],[3,"UserspaceBookkeeping"],[3,"Event"],[3,"ReadableEvent"],[3,"WritableEvent"],[3,"IRQEvent"],[3,"IRQState"],[8,"Waitable"],[3,"UserspaceError"],[4,"KernelError"],[13,"NotImplemented"],[13,"PhysicalMemoryExhaustion"],[13,"VirtualMemoryExhaustion"],[13,"InvalidAddress"],[13,"InvalidSize"],[13,"ProcessKilled"],[13,"InvalidState"],[13,"InvalidCombination"],[13,"ExceedingMaximum"],[13,"InvalidKernelCaps"],[13,"IpcError"],[13,"WrongMappingFramesForTy"],[13,"InvalidMemState"],[13,"ReservedValue"],[3,"Logger"],[3,"Filter"],[3,"Builder"],[3,"Directive"],[3,"Filter"],[3,"TssStruct"],[4,"PrivilegeLevel"],[3,"EFlags"],[3,"KernelStack"],[3,"StackDumpSource"],[3,"SegmentSelector"],[3,"Idt"],[3,"IdtEntry"],[3,"EntryOptions"],[3,"ExceptionStackFrame"],[3,"PageFaultErrorCode"],[4,"GateType"],[3,"ThreadHardwareContext"],[3,"GdtManager"],[3,"MainTask"],[3,"DoubleFaultTaskStack"],[3,"DescriptorTable"],[3,"DescriptorTableEntry"],[4,"GdtIndex"],[4,"SystemDescriptorTypes"],[3,"InterruptHandler"],[3,"UserspaceHardwareContext"],[3,"IDT"],[3,"Pio"],[3,"DescriptorTablePointer"],[3,"PhysicalMemRegion"],[3,"PhysicalMemRegionIter"],[3,"FrameAllocatori386"],[8,"FrameAllocatorTraitPrivate"],[8,"FrameAllocatorTrait"],[3,"Allocator"],[3,"HpetIdRegister"],[3,"HpetGeneralConfigurationRegister"],[3,"HpetTimerConfigurationRegister"],[3,"HpetRegister"],[3,"HpetTimerRegister"],[3,"Hpet"],[3,"HpetTimer"],[3,"ICW1"],[3,"InternalPic"],[3,"Pic"],[3,"PIT_PORTS"],[3,"Port61Flags"],[3,"PITPorts"],[3,"PITChannel2"],[4,"ChannelSelector"],[3,"ComPort"],[3,"SerialAttributes"],[3,"SerialInternal"],[4,"SerialColor"],[3,"SerialLogger"],[3,"LocalApicRegister"],[3,"LocalApicVersion"],[3,"LocalVector"],[3,"SpuriousInterrupt"],[3,"Error"],[3,"LocalApicInternal"],[3,"LocalApic"],[4,"DeliveryMode"],[4,"TimerMode"],[3,"IoApicInternal"],[3,"IoApic"],[3,"RedirectionEntry"],[4,"DeliveryMode"],[3,"SpinRwLock"],[3,"SpinRwLockReadGuard"],[3,"SpinRwLockWriteGuard"],[3,"Once"],[3,"SpinLockGuard"],[3,"SpinLockIRQ"],[3,"SpinLockIRQGuard"],[3,"SpinLock"],[3,"Mutex"],[3,"MutexInner"],[3,"MutexInnerInner"],[3,"MutexGuard"],[8,"Lock"],[3,"KernelTimerInfo"],[3,"IRQTimer"],[3,"ProcessCapabilities"],[3,"ProcessStateData"],[3,"ProcessStruct"],[3,"ThreadStruct"],[3,"ThreadStateEvent"],[3,"HandleTable"],[4,"Handle"],[4,"ThreadState"],[3,"TLSPage"],[3,"TLSManager"],[3,"MaskPrinter"],[3,"PhysicalAddress"],[3,"VirtualAddress"],[3,"UserSpacePtr"],[3,"UserSpacePtrMut"],[3,"FatPtr"],[3,"NAMED_PORTS"],[3,"SessionRequests"],[3,"Session"],[3,"ClientSession"],[3,"ServerSession"],[3,"MsgPackedHdr"],[3,"HandleDescriptorHeader"],[3,"Request"],[3,"Buffer"],[4,"CBufBehavior"],[3,"Port"],[3,"ClientPort"],[3,"ServerPort"],[3,"IncomingConnection"],[3,"MappedGrubModule"],[8,"Io"],[3,"ReadOnly"],[3,"WriteOnly"],[3,"Mmio"],[4,"Loop"],[3,"LoopFn"],[4,"Poll"],[8,"BitArrayExt"],[3,"CursorWrite"],[3,"CursorRead"],[8,"Splittable"],[3,"ThreadControlBlock"],[3,"CpuLocalRegion"],[4,"PanicOrigin"],[13,"KernelAssert"],[13,"KernelFault"],[13,"UserspaceFault"],[3,"KernelLand"],[3,"UserLand"],[3,"RecursiveTablesLand"],[3,"NoFlush"],[3,"ActiveHierarchy"],[3,"TlbFlush"],[3,"MemoryHandler"],[3,"FrameAllocator"]]},\
"sunrise_keyboard":{"doc":"Keyboard Service","i":[[3,"Keyboard","sunrise_keyboard","Keyboard handling structure.",null,null],[12,"writable_event","","The event used to signal changes in the shared memory.",0,null],[12,"readable_event","","The event returned to the client when requested via IPC.",0,null],[12,"keys_queue","","The queue containing the keyboard state received by the…",0,null],[3,"StaticService","","Entry point interface.",null,null],[5,"update_keyboard","","Task responsible for signaling KEYBOARD_INSTANCE\'s event…",null,[[["workqueue",3]]]],[5,"main","","",null,[[]]],[0,"ps2","","PS/2 Keyboard Driver",null,null],[3,"PS2","sunrise_keyboard::ps2","PS2 keyboard state.",null,null],[12,"status_port","","Status Register address",1,null],[12,"data_port","","Data Register address",1,null],[12,"event","","IRQEvent for the PS/2 keyboard. Triggered each time the…",1,null],[12,"is_capslocked","","Flips when the user has toggled the caps lock key. When…",1,null],[12,"is_left_shift","","Set to true if the user is currently holding the left…",1,null],[12,"is_right_shift","","Set to true if the user is currently holding the right…",1,null],[12,"is_left_ctrl","","Set to true if the user is currently holding the left ctrl…",1,null],[12,"is_right_ctrl","","Set to true if the user is currently holding the right…",1,null],[12,"is_left_alt","","Set to true if the user is currently holding the left alt…",1,null],[12,"is_right_alt","","Set to true if the user is currently holding the right alt…",1,null],[12,"partial_input","","Holds input until sequence has been completed.",1,null],[3,"LetterKey","","A non-control key (lowercase_ascii, uppercase_ascii)",null,null],[12,"lower_case","","",2,null],[12,"upper_case","","",2,null],[3,"ControlKey","","A control key (ctrl, shift, alt, arrows, end, ...)",null,null],[12,"0","","",3,null],[3,"KeyEvent","","A KeyEvent is the combination of a key and its state",null,null],[12,"key","","",4,null],[12,"state","","",4,null],[3,"PRIMARY_PS2","","Primary PS2 controller instance on a classical IBM/PC…",null,null],[12,"__private_field","","",5,null],[4,"Key","","A key is either a letter key, a control key, or not…",null,null],[13,"Letter","","",6,null],[13,"Control","","",6,null],[13,"Scancode","","",6,null],[13,"Unknown","","",6,null],[4,"State","","State of a key on the keyboard.",null,null],[13,"Pressed","","",7,null],[13,"Released","","",7,null],[5,"read_key","","Waits for a single key press, and return its unicode…",null,[[]]],[5,"try_read_key","","If a key press is pending, return its unicode…",null,[[],["option",4]]],[5,"get_event","","Get a ReadableEvent for the PS2 IRQ. Waiting on this event…",null,[[],["readableevent",3]]],[5,"has_read_key_event","","Return true if the PS2 keyboard has an key event to read.",null,[[]]],[5,"try_read_keyboard_state","","Return a representation of a single key press if any…",null,[[],[["hidkeyboardstate",3],["option",4]]]],[11,"ctrl","","Create a control key with the given human-readable name.",6,[[],["key",4]]],[11,"letter","","Create a letter key with the given lowercase and uppercase…",6,[[],["key",4]]],[11,"scancode","","Create a scancode key with the given scancode.",6,[[["hidkeyboardscancode",3]],["key",4]]],[11,"read_key_event","","Reads one or more bytes from an input buffer until it…",4,[[],[["keyevent",3],["option",4]]]],[11,"handle_control_key","","Handle a control key scancode",1,[[["hidkeyboardscancode",3],["state",4]]]],[11,"key_to_letter","","Gets the letter from the key, accounting for shift and…",1,[[["letterkey",3]]]],[11,"encode_modifiers","","Get a bitfield representing the modifiers of this keyboard",1,[[["state",4]]]],[11,"has_read_key_event","","Return true if the PS2 keyboard has an key event to read.",1,[[]]],[11,"try_read_key_event","","Tries to read a KeyEvent, grabs more bytes from the port…",1,[[],[["keyevent",3],["option",4]]]],[11,"try_read_keyboard_state","","Return a representation of a single key press if any…",1,[[],[["hidkeyboardstate",3],["option",4]]]],[11,"read_key","","Waits for a single key press, and return its unicode…",1,[[]]],[11,"try_read_key","","If a key press is pending, return its unicode…",1,[[],["option",4]]],[11,"event_irq","","Get a ReadableEvent for the PS2 IRQ. Waiting on this event…",1,[[],["readableevent",3]]],[7,"HEADER","sunrise_keyboard","",null,null],[7,"CAPABILITIES","","",null,null],[7,"KEYBOARD_INSTANCE","","Global instance of Keyboard.",null,null],[11,"new","","Create a new instance of Keyboard.",0,[[],[["result",4],["error",4]]]],[11,"get_readable_event","","Get the readable update event of the Keyboard.",0,[[],["handleref",3]]],[11,"take_writable_event","","Get the writeable update event of the Keyboard.",0,[[],[["option",4],["writableevent",3]]]],[11,"handle_ps2_irq","","Handle a PS2 IRQ and push a new key state to the internal…",0,[[],["option",4]]],[11,"read_keyboard_states","","Get the last key states on the internal queue.",0,[[],[["result",4],["error",4]]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"size","","",8,[[]]],[11,"is_cool","","",8,[[]]],[11,"from_raw_parts","","",8,[[]]],[11,"from_raw_parts_mut","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"from","sunrise_keyboard::ps2","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"size","","",3,[[]]],[11,"is_cool","","",3,[[]]],[11,"from_raw_parts","","",3,[[]]],[11,"from_raw_parts_mut","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"size","","",4,[[]]],[11,"is_cool","","",4,[[]]],[11,"from_raw_parts","","",4,[[]]],[11,"from_raw_parts_mut","","",4,[[]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"size","","",5,[[]]],[11,"is_cool","","",5,[[]]],[11,"from_raw_parts","","",5,[[]]],[11,"from_raw_parts_mut","","",5,[[]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"size","","",6,[[]]],[11,"is_cool","","",6,[[]]],[11,"from_raw_parts","","",6,[[]]],[11,"from_raw_parts_mut","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"from","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"size","","",7,[[]]],[11,"is_cool","","",7,[[]]],[11,"from_raw_parts","","",7,[[]]],[11,"from_raw_parts_mut","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"deref","","",5,[[],["ps2",3]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_keyboard","",8,[[["formatter",3]],["result",6]]],[11,"eq","sunrise_keyboard::ps2","",7,[[["state",4]]]],[11,"clone","","",2,[[],["letterkey",3]]],[11,"clone","","",3,[[],["controlkey",3]]],[11,"clone","","",6,[[],["key",4]]],[11,"clone","","",7,[[],["state",4]]],[11,"clone","sunrise_keyboard","",8,[[],["staticservice",3]]],[11,"default","","",8,[[],["staticservice",3]]],[11,"get_keyboard_event","","",8,[[["workqueue",3]],[["error",4],["result",4],["handleref",3]]]],[11,"read_keyboard_states","","",8,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"initialize","sunrise_keyboard::ps2","",5,[[]]]],"p":[[3,"Keyboard"],[3,"PS2"],[3,"LetterKey"],[3,"ControlKey"],[3,"KeyEvent"],[3,"PRIMARY_PS2"],[4,"Key"],[4,"State"],[3,"StaticService"]]},\
"sunrise_libkern":{"doc":"Types shared by user and kernel","i":[[3,"MemoryState","sunrise_libkern","Represents the current state of a memory region: why is it…",null,null],[12,"bits","","",0,null],[3,"MemoryAttributes","","Low-level attributes of a memory mapping.",null,null],[12,"bits","","",1,null],[3,"MemoryPermissions","","Memory permissions of a memory area.",null,null],[12,"bits","","",2,null],[3,"MemoryInfo","","The structure returned by the `query_memory` syscall.",null,null],[12,"baseaddr","","The base address of this memory region.",3,null],[12,"size","","The size of this memory region, from the base address.",3,null],[12,"memtype","","The type of this mapping.",3,null],[12,"memattr","","The attributes of this mapping.",3,null],[12,"perms","","The permissions of this mapping.",3,null],[12,"ipc_ref_count","","Counts how many IPC service requests have an IPC buffer in…",3,null],[12,"device_ref_count","","Unknown.",3,null],[3,"TLS","","Thread Local Storage region.",null,null],[12,"ptr_self","","Pointer pointing to this TLS region (i.e pointing to…",4,null],[12,"_reserved0","","reserved or unknown.",4,null],[12,"ipc_command_buffer","","Buffer used for IPC. Kernel reads, interprets, and copies…",4,null],[12,"_reserved1","","reserved or unknown.",4,null],[12,"ptr_thread_context","","User controlled pointer to thread context. Not observed by…",4,null],[3,"SYSCALL_NAMES","","A table associating a syscall name string for every…",null,null],[12,"__private_field","","",5,null],[4,"MemoryType","","The type of this memory area.",null,null],[13,"Unmapped","","Nothing is stored there. Accessing it will page fault. An…",6,null],[13,"Io","","Mapped by the kernel during process creation, for every IO…",6,null],[13,"Normal","","Mapped by the kernel during process creation, for every…",6,null],[13,"CodeStatic","","Mapped by the kernel during process creation, at the…",6,null],[13,"CodeMutable","","Transitioned from CodeStatic in…",6,null],[13,"Heap","","Mapped using `svcSetHeapSize`.",6,null],[13,"SharedMemory","","Mapped using `svcMapSharedMemory`.",6,null],[13,"Alias","","Mapped by using `svcMapMemory` to remap memory into the…",6,null],[13,"ModuleCodeStatic","","Mapped using `svcMapProcessCodeMemory`.",6,null],[13,"ModuleCodeMutable","","Transitioned from ModuleCodeStatic in…",6,null],[13,"Ipc","","IPC buffers with descriptor flags=0.",6,null],[13,"Stack","","Mapped by using `svcMapMemory` to remap memory into the…",6,null],[13,"ThreadLocal","","Mapped by the kernel during process creation. The TLS…",6,null],[13,"TransferMemoryIsolated","","Mapped using `svcMapTransferMemory` when the owning…",6,null],[13,"TransferMemory","","Mapped using `svcMapTransferMemory` when the owning…",6,null],[13,"ProcessMemory","","Mapped using `svcMapProcessMemory`.",6,null],[13,"Reserved","","Reserved for kernel use.",6,null],[13,"NonSecureIpc","","IPC buffers with descriptor flags=1.",6,null],[13,"NonDeviceIpc","","IPC buffers with descriptor flags=3.",6,null],[13,"KernelStack","","Mapped by the kernel during svcCreateThread. Unused.",6,null],[13,"CodeReadOnly","","Mapped with `svcControlCodeMemory`.",6,null],[13,"CodeWritable","","Mapped with `svcControlCodeMemory`.",6,null],[0,"error","","Kernel errors",null,null],[3,"KernelError","sunrise_libkern::error","Kernel syscall error codes.",null,null],[12,"0","","",7,null],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",7,null],[18,"NotImplemented","","This function is not implemented.",7,null],[18,"InvalidSize","","The size argument is invalid.",7,null],[18,"InvalidAddress","","The passed address is invalid.",7,null],[18,"MemoryFull","","The virtual address space was exhausted.",7,null],[18,"HandleTableFull","","The process\' handle table is full.",7,null],[18,"InvalidMemState","","The memory state is invalid for this action.",7,null],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",7,null],[18,"InvalidMemRange","","Memory range is not at an expected location.",7,null],[18,"InvalidThreadPriority","","Invalid thread priority. Thread priority should be within…",7,null],[18,"InvalidProcessorId","","Invalid processor id. Processor ID should exist on the…",7,null],[18,"InvalidHandle","","Passed handle is invalid.",7,null],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",7,null],[18,"InvalidCombination","","The combination of argument is invalid.",7,null],[18,"Timeout","","A timeout was reached.",7,null],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",7,null],[18,"ExceedingMaximum","","A size or address was given exceeding the maximum allowed…",7,null],[18,"InvalidEnum","","No enum variants match this integer value.",7,null],[18,"NoSuchEntry","","The given entry does not exist.",7,null],[18,"PortRemoteDead","","The remote part of the session was closed.",7,null],[18,"InvalidState","","Attempted to do an operation that\'s invalid in the…",7,null],[18,"ReservedValue","","Attempted to use an unknown value, reserved for future use.",7,null],[11,"make_ret","","Transforms a KernelError into the encoding acceptable for…",7,[[]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",7,[[],["kernelerror",3]]],[11,"from_description","","Turns a kernel error description into a KernelError.",7,[[],["kernelerror",3]]],[11,"description","","Gets the underlying KernelError description.",7,[[]]],[0,"process","sunrise_libkern","Data-structures related to process syscalls.",null,null],[3,"ProcInfoFlags","sunrise_libkern::process","Miscelaneous flags.",null,null],[12,"0","","",8,null],[3,"ProcessCategory","","Category of the process.",null,null],[12,"0","","",9,null],[3,"ProcInfo","","Informations necessary for the create_process syscall.",null,null],[12,"name","","Name of the process (as seen by debuggers).",10,null],[12,"process_category","","Category of the process. Should always be RegularTitle.",10,null],[12,"title_id","","TitleId of the process (as seen by svcGetInfo and…",10,null],[12,"code_addr","","Address where the main module\'s code will be loaded. Must…",10,null],[12,"code_num_pages","","Number of pages to allocate for code.",10,null],[12,"flags","","Miscelaneous flags",10,null],[12,"resource_limit_handle","","Resource limit to use for this process. If None, will use…",10,null],[12,"system_resource_num_pages","","Maximum amount of kernel memory used to create the…",10,null],[3,"KipHeader","","Header for Kernel Builtins. Can be found in the…",null,null],[12,"magic","","Should be *b\\\"KIP1\\\".",11,null],[12,"name","","Name of the program. Pad with \\\\0 if it\'s less than 12 bytes.",11,null],[12,"title_id","","Titleid of the program. Should start with 0x02 to avoid…",11,null],[12,"process_category","","Category of the process. Should always be KernelBuiltin.",11,null],[12,"main_thread_priority","","Priority of the starting thread.",11,null],[12,"default_cpu_core","","CPU core the starting thread runs on.",11,null],[12,"reserved","","Reserved, leave to 0.",11,null],[12,"flags","","Bitflags controlling the behavior of the process:",11,null],[12,"stack_page_count","","Number of pages for the starting thread\'s stack.",11,null],[3,"ProcessState","","The state the process is currently in.",null,null],[12,"0","","",12,null],[3,"ProcessInfoType","","Kind of information to extract from a process wit…",null,null],[12,"0","","",13,null],[4,"PoolPartition","","Kernel memory pool.",null,null],[13,"Application","","Pool of memory usable by applications. Usually 3GiB.",14,null],[13,"Applet","","Pool of memory usable by applets. Usually 512MiB.",14,null],[13,"Sysmodule","","Pool of memory usable by system modules.",14,null],[13,"Nvservices","","Pool of memory usable by nvidia\'s driver.",14,null],[4,"ProcInfoAddrSpace","","Address space type to use when creating a process.",null,null],[13,"AS32Bit","","32-bit address space, spanning from 0x00200000 to…",15,null],[13,"AS32BitNoMap","","32-bit address space without the map region.",15,null],[13,"AS36Bit","","36-bit address space, spanning from 0x08000000 to…",15,null],[13,"AS39Bit","","39-bit address space, spanning from 0x08000000 to…",15,null],[11,"is_64bit","","64-bit instructions support.",8,[[]]],[11,"set_64bit","","64-bit instructions support.",8,[[]]],[11,"address_space_type","","Address space width of the process.",8,[[],["procinfoaddrspace",4]]],[11,"set_address_space_type","","Address space width of the process.",8,[[["procinfoaddrspace",4]]]],[11,"is_debug","","Whether to signal various conditions (such as exceptions).",8,[[]]],[11,"set_debug","","Whether to signal various conditions (such as exceptions).",8,[[]]],[11,"is_aslr","","Enable randomization of the various memory regions (heap,…",8,[[]]],[11,"set_aslr","","Enable randomization of the various memory regions (heap,…",8,[[]]],[11,"is_application","","Process is an application. There can only be one…",8,[[]]],[11,"set_application","","Process is an application. There can only be one…",8,[[]]],[11,"use_secure_memory","","unknown.",8,[[]]],[11,"pool_partition","","The memory pool to use for this process.",8,[[],["poolpartition",4]]],[11,"set_pool_partition","","The memory pool to use for this process.",8,[[["poolpartition",4]]]],[11,"optimize_memory_allocation","","unknown",8,[[]]],[11,"check","","Checks that the ProcInfoFlags doesn\'t contain any unknown…",8,[[],[["kernelerror",3],["result",4]]]],[18,"RegularTitle","","Regular process created through the userspace loader.",9,null],[18,"KernelBuiltin","","Process loaded by the kernel early during the boot process.",9,null],[18,"Created","","Process is freshly created with svcCreateProcess and has…",12,null],[18,"CreatedAttached","","Process has been attached with a debugger before it was…",12,null],[18,"Started","","Process has been started.",12,null],[18,"Crashed","","Process has crashed.",12,null],[18,"StartedAttached","","Process is started and has a debugger attached.",12,null],[18,"Exiting","","Process is currently exiting.",12,null],[18,"Exited","","Process is stopped.",12,null],[18,"DebugSuspended","","Process has been suspended.",12,null],[18,"ProcessState","","Get the state the process is currently in.",13,null],[0,"nr","sunrise_libkern","Syscall numbers",null,null],[17,"SetHeapSize","sunrise_libkern::nr","",null,null],[17,"SetMemoryPermission","","",null,null],[17,"SetMemoryAttribute","","",null,null],[17,"MapMemory","","",null,null],[17,"UnmapMemory","","",null,null],[17,"QueryMemory","","",null,null],[17,"ExitProcess","","",null,null],[17,"CreateThread","","",null,null],[17,"StartThread","","",null,null],[17,"ExitThread","","",null,null],[17,"SleepThread","","",null,null],[17,"GetThreadPriority","","",null,null],[17,"SetThreadPriority","","",null,null],[17,"GetThreadCoreMask","","",null,null],[17,"SetThreadCoreMask","","",null,null],[17,"GetCurrentProcessorNumber","","",null,null],[17,"SignalEvent","","",null,null],[17,"ClearEvent","","",null,null],[17,"MapSharedMemory","","",null,null],[17,"UnmapSharedMemory","","",null,null],[17,"CreateTransferMemory","","",null,null],[17,"CloseHandle","","",null,null],[17,"ResetSignal","","",null,null],[17,"WaitSynchronization","","",null,null],[17,"CancelSynchronization","","",null,null],[17,"ArbitrateLock","","",null,null],[17,"ArbitrateUnlock","","",null,null],[17,"WaitProcessWideKeyAtomic","","",null,null],[17,"SignalProcessWideKey","","",null,null],[17,"GetSystemTick","","",null,null],[17,"ConnectToNamedPort","","",null,null],[17,"SendSyncRequestLight","","",null,null],[17,"SendSyncRequest","","",null,null],[17,"SendSyncRequestWithUserBuffer","","",null,null],[17,"SendAsyncRequestWithUserBuffer","","",null,null],[17,"GetProcessId","","",null,null],[17,"GetThreadId","","",null,null],[17,"Break","","",null,null],[17,"OutputDebugString","","",null,null],[17,"ReturnFromException","","",null,null],[17,"GetInfo","","",null,null],[17,"FlushEntireDataCache","","",null,null],[17,"FlushDataCache","","",null,null],[17,"MapPhysicalMemory","","",null,null],[17,"UnmapPhysicalMemory","","",null,null],[17,"GetFutureThreadInfo","","",null,null],[17,"GetLastThreadInfo","","",null,null],[17,"GetResourceLimitLimitValue","","",null,null],[17,"GetResourceLimitCurrentValue","","",null,null],[17,"SetThreadActivity","","",null,null],[17,"GetThreadContext3","","",null,null],[17,"WaitForAddress","","",null,null],[17,"SignalToAddress","","",null,null],[17,"DumpInfo","","",null,null],[17,"DumpInfoNew","","",null,null],[17,"CreateSession","","",null,null],[17,"AcceptSession","","",null,null],[17,"ReplyAndReceiveLight","","",null,null],[17,"ReplyAndReceive","","",null,null],[17,"ReplyAndReceiveWithUserBuffer","","",null,null],[17,"CreateEvent","","",null,null],[17,"MapPhysicalMemoryUnsafe","","",null,null],[17,"UnmapPhysicalMemoryUnsafe","","",null,null],[17,"SetUnsafeLimit","","",null,null],[17,"CreateCodeMemory","","",null,null],[17,"ControlCodeMemory","","",null,null],[17,"SleepSystem","","",null,null],[17,"ReadWriteRegister","","",null,null],[17,"SetProcessActivity","","",null,null],[17,"CreateSharedMemory","","",null,null],[17,"MapTransferMemory","","",null,null],[17,"UnmapTransferMemory","","",null,null],[17,"CreateInterruptEvent","","",null,null],[17,"QueryPhysicalAddress","","",null,null],[17,"QueryIoMapping","","",null,null],[17,"CreateDeviceAddressSpace","","",null,null],[17,"AttachDeviceAddressSpace","","",null,null],[17,"DetachDeviceAddressSpace","","",null,null],[17,"MapDeviceAddressSpaceByForce","","",null,null],[17,"MapDeviceAddressSpaceAligned","","",null,null],[17,"MapDeviceAddressSpace","","",null,null],[17,"UnmapDeviceAddressSpace","","",null,null],[17,"InvalidateProcessDataCache","","",null,null],[17,"StoreProcessDataCache","","",null,null],[17,"FlushProcessDataCache","","",null,null],[17,"DebugActiveProcess","","",null,null],[17,"BreakDebugProcess","","",null,null],[17,"TerminateDebugProcess","","",null,null],[17,"GetDebugEvent","","",null,null],[17,"ContinueDebugEvent","","",null,null],[17,"GetProcessList","","",null,null],[17,"GetThreadList","","",null,null],[17,"GetDebugThreadContext","","",null,null],[17,"SetDebugThreadContext","","",null,null],[17,"QueryDebugProcessMemory","","",null,null],[17,"ReadDebugProcessMemory","","",null,null],[17,"WriteDebugProcessMemory","","",null,null],[17,"SetHardwareBreakPoint","","",null,null],[17,"GetDebugThreadParam","","",null,null],[17,"GetSystemInfo","","",null,null],[17,"CreatePort","","",null,null],[17,"ManageNamedPort","","",null,null],[17,"ConnectToPort","","",null,null],[17,"SetProcessMemoryPermission","","",null,null],[17,"MapProcessMemory","","",null,null],[17,"UnmapProcessMemory","","",null,null],[17,"QueryProcessMemory","","",null,null],[17,"MapProcessCodeMemory","","",null,null],[17,"UnmapProcessCodeMemory","","",null,null],[17,"CreateProcess","","",null,null],[17,"StartProcess","","",null,null],[17,"TerminateProcess","","",null,null],[17,"GetProcessInfo","","",null,null],[17,"CreateResourceLimit","","",null,null],[17,"SetResourceLimitLimitValue","","",null,null],[17,"CallSecureMonitor","","",null,null],[17,"MapFramebuffer","","",null,null],[17,"StartProcessEntrypoint","","",null,null],[17,"MapMmioRegion","","",null,null],[17,"SetThreadArea","","",null,null],[17,"MaxSvc","","",null,null],[6,"IpcBuffer","sunrise_libkern","Buffer used for Inter Process Communication. Kernel reads,…",null,null],[18,"TY","","The low 8 bits are used to keep the type.",0,null],[18,"PERMISSION_CHANGE_ALLOWED","","Allows the use of `svcSetMemoryPermissions` on this memory…",0,null],[18,"FORCE_READ_WRITABLE_BY_DEBUG_SYSCALLS","","Allow writing to read-only segments with…",0,null],[18,"IPC_SEND_ALLOWED","","Allows sending this region over IPC.",0,null],[18,"NON_DEVICE_IPC_SEND_ALLOWED","","Allows sending this region over IPC with buffer flag set…",0,null],[18,"NON_SECURE_IPC_SEND_ALLOWED","","Allows sending this region over IPC with buffer flag set…",0,null],[18,"PROCESS_PERMISSION_CHANGE_ALLOWED","","Allows the use of `svcSetProcessMemoryPermission` on this…",0,null],[18,"MAP_ALLOWED","","Allows remapping this memory region with `svcMapMemory`.",0,null],[18,"UNMAP_PROCESS_CODE_MEMORY_ALLOWED","","Allows unmapping this memory region through…",0,null],[18,"TRANSFER_MEMORY_ALLOWED","","Allows creating Transfer Memory from this memory region…",0,null],[18,"QUERY_PHYSICAL_ADDRESS_ALLOWED","","Allows using [query_physical_memory] on this memory region.",0,null],[18,"MAP_DEVICE_ALLOWED","","Allows mapping this memory region to a DeviceAddressSpace…",0,null],[18,"MAP_DEVICE_ALIGNED_ALLOWED","","Allows mapping this memory region to a DeviceAddressSpace…",0,null],[18,"IPC_BUFFER_ALLOWED","","Allows using this memory region as an IPC Command Buffer.",0,null],[18,"IS_REFERENCE_COUNTED","","If true, this memory region is reference…",0,null],[18,"MAP_PROCESS_ALLOWED","","Allows mapping this region accross process boundary…",0,null],[18,"ATTRIBUTE_CHANGE_ALLOWED","","Allows using the `svcSetMemoryAttribute` syscall on this…",0,null],[18,"CODE_MEMORY_ALLOWED","","Allows creating a CodeMemory backed by this memory region.",0,null],[18,"ALL_IPC_SEND_ALLOWED","","All IPC Buffer Send permissions are allowed by this type.",0,null],[18,"CAN_IOMMU","","This type can use all IOMMU-related permissions (MapDevice…",0,null],[11,"empty","","Returns an empty set of flags",0,[[],["memorystate",3]]],[11,"all","","Returns the set containing all flags.",0,[[],["memorystate",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",0,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",0,[[],[["memorystate",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",0,[[],["memorystate",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",0,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",0,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",0,[[["memorystate",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",0,[[["memorystate",3]]]],[11,"insert","","Inserts the specified flags in-place.",0,[[["memorystate",3]]]],[11,"remove","","Removes the specified flags in-place.",0,[[["memorystate",3]]]],[11,"toggle","","Toggles the specified flags in-place.",0,[[["memorystate",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",0,[[["memorystate",3]]]],[11,"ty","","[MemoryType] this state represents.",0,[[],["memorytype",4]]],[11,"get_memory_state","","Get the [MemoryState] associated with a [MemoryType].",6,[[],["memorystate",3]]],[18,"BORROWED","","Is mapped in more than one area.",1,null],[18,"IPC_MAPPED","","Is mapped through an IPC request.",1,null],[18,"DEVICE_MAPPED","","Is a device mapping.",1,null],[18,"UNCACHED","","Is caching disabled in the MMU.",1,null],[11,"empty","","Returns an empty set of flags",1,[[],["memoryattributes",3]]],[11,"all","","Returns the set containing all flags.",1,[[],["memoryattributes",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",1,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",1,[[],[["option",4],["memoryattributes",3]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",1,[[],["memoryattributes",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",1,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",1,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",1,[[["memoryattributes",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",1,[[["memoryattributes",3]]]],[11,"insert","","Inserts the specified flags in-place.",1,[[["memoryattributes",3]]]],[11,"remove","","Removes the specified flags in-place.",1,[[["memoryattributes",3]]]],[11,"toggle","","Toggles the specified flags in-place.",1,[[["memoryattributes",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",1,[[["memoryattributes",3]]]],[18,"READABLE","","The area is readable.",2,null],[18,"WRITABLE","","The area is writable.",2,null],[18,"EXECUTABLE","","The area is executable.",2,null],[18,"RO","","The area is ReadOnly.",2,null],[18,"RW","","The area is RW.",2,null],[18,"RX","","The area is RX.",2,null],[11,"empty","","Returns an empty set of flags",2,[[],["memorypermissions",3]]],[11,"all","","Returns the set containing all flags.",2,[[],["memorypermissions",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",2,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",2,[[],[["memorypermissions",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",2,[[],["memorypermissions",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",2,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",2,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",2,[[["memorypermissions",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",2,[[["memorypermissions",3]]]],[11,"insert","","Inserts the specified flags in-place.",2,[[["memorypermissions",3]]]],[11,"remove","","Removes the specified flags in-place.",2,[[["memorypermissions",3]]]],[11,"toggle","","Toggles the specified flags in-place.",2,[[["memorypermissions",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",2,[[["memorypermissions",3]]]],[11,"check","","Checks that the permissions as valid - that is, it should…",2,[[],[["result",4],["kernelerror",3]]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","sunrise_libkern::error","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","sunrise_libkern::process","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"bit","","",8,[[]]],[11,"set_bit","","",8,[[]]],[11,"from","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"into","","",12,[[]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"into","","",13,[[]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"into","","",14,[[]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"into","","",15,[[]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"deref","sunrise_libkern","",5,[[]]],[11,"from","sunrise_libkern::process","",14,[[],["poolpartition",4]]],[11,"from","","",15,[[],["procinfoaddrspace",4]]],[11,"fmt","sunrise_libkern::error","",7,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libkern::process","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libkern","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","Debug on TLS displays only the address of the IPC command…",4,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_libkern::error","",7,[[["formatter",3]],["result",6]]],[11,"sub","sunrise_libkern","Returns the set difference of the two sets of flags.",0,[[["memorystate",3]],["memorystate",3]]],[11,"sub","","Returns the set difference of the two sets of flags.",1,[[["memoryattributes",3]],["memoryattributes",3]]],[11,"sub","","Returns the set difference of the two sets of flags.",2,[[["memorypermissions",3]],["memorypermissions",3]]],[11,"eq","sunrise_libkern::error","",7,[[["kernelerror",3]]]],[11,"ne","","",7,[[["kernelerror",3]]]],[11,"eq","sunrise_libkern::process","",9,[[["processcategory",3]]]],[11,"ne","","",9,[[["processcategory",3]]]],[11,"eq","","",12,[[["processstate",3]]]],[11,"ne","","",12,[[["processstate",3]]]],[11,"eq","","",13,[[["processinfotype",3]]]],[11,"ne","","",13,[[["processinfotype",3]]]],[11,"eq","sunrise_libkern","",0,[[["memorystate",3]]]],[11,"ne","","",0,[[["memorystate",3]]]],[11,"eq","","",6,[[["memorytype",4]]]],[11,"eq","","",1,[[["memoryattributes",3]]]],[11,"ne","","",1,[[["memoryattributes",3]]]],[11,"eq","","",2,[[["memorypermissions",3]]]],[11,"ne","","",2,[[["memorypermissions",3]]]],[11,"cmp","","",0,[[["memorystate",3]],["ordering",4]]],[11,"cmp","","",1,[[["memoryattributes",3]],["ordering",4]]],[11,"cmp","","",2,[[["memorypermissions",3]],["ordering",4]]],[11,"partial_cmp","","",0,[[["memorystate",3]],[["option",4],["ordering",4]]]],[11,"lt","","",0,[[["memorystate",3]]]],[11,"le","","",0,[[["memorystate",3]]]],[11,"gt","","",0,[[["memorystate",3]]]],[11,"ge","","",0,[[["memorystate",3]]]],[11,"partial_cmp","","",1,[[["memoryattributes",3]],[["option",4],["ordering",4]]]],[11,"lt","","",1,[[["memoryattributes",3]]]],[11,"le","","",1,[[["memoryattributes",3]]]],[11,"gt","","",1,[[["memoryattributes",3]]]],[11,"ge","","",1,[[["memoryattributes",3]]]],[11,"partial_cmp","","",2,[[["memorypermissions",3]],[["option",4],["ordering",4]]]],[11,"lt","","",2,[[["memorypermissions",3]]]],[11,"le","","",2,[[["memorypermissions",3]]]],[11,"gt","","",2,[[["memorypermissions",3]]]],[11,"ge","","",2,[[["memorypermissions",3]]]],[11,"sub_assign","","Disables all flags enabled in the set.",0,[[["memorystate",3]]]],[11,"sub_assign","","Disables all flags enabled in the set.",1,[[["memoryattributes",3]]]],[11,"sub_assign","","Disables all flags enabled in the set.",2,[[["memorypermissions",3]]]],[11,"not","","Returns the complement of this set of flags.",0,[[],["memorystate",3]]],[11,"not","","Returns the complement of this set of flags.",1,[[],["memoryattributes",3]]],[11,"not","","Returns the complement of this set of flags.",2,[[],["memorypermissions",3]]],[11,"bitand","","Returns the intersection between the two sets of flags.",0,[[["memorystate",3]],["memorystate",3]]],[11,"bitand","","Returns the intersection between the two sets of flags.",1,[[["memoryattributes",3]],["memoryattributes",3]]],[11,"bitand","","Returns the intersection between the two sets of flags.",2,[[["memorypermissions",3]],["memorypermissions",3]]],[11,"bitor","","Returns the union of the two sets of flags.",0,[[["memorystate",3]],["memorystate",3]]],[11,"bitor","","Returns the union of the two sets of flags.",1,[[["memoryattributes",3]],["memoryattributes",3]]],[11,"bitor","","Returns the union of the two sets of flags.",2,[[["memorypermissions",3]],["memorypermissions",3]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",0,[[["memorystate",3]],["memorystate",3]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",1,[[["memoryattributes",3]],["memoryattributes",3]]],[11,"bitxor","","Returns the left flags, but with all the right flags…",2,[[["memorypermissions",3]],["memorypermissions",3]]],[11,"bitand_assign","","Disables all flags disabled in the set.",0,[[["memorystate",3]]]],[11,"bitand_assign","","Disables all flags disabled in the set.",1,[[["memoryattributes",3]]]],[11,"bitand_assign","","Disables all flags disabled in the set.",2,[[["memorypermissions",3]]]],[11,"bitor_assign","","Adds the set of flags.",0,[[["memorystate",3]]]],[11,"bitor_assign","","Adds the set of flags.",1,[[["memoryattributes",3]]]],[11,"bitor_assign","","Adds the set of flags.",2,[[["memorypermissions",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",0,[[["memorystate",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",1,[[["memoryattributes",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",2,[[["memorypermissions",3]]]],[11,"hash","","",0,[[]]],[11,"hash","","",1,[[]]],[11,"hash","","",2,[[]]],[11,"extend","","",0,[[["intoiterator",8]]]],[11,"extend","","",1,[[["intoiterator",8]]]],[11,"extend","","",2,[[["intoiterator",8]]]],[11,"from_iter","","",0,[[["intoiterator",8]],["memorystate",3]]],[11,"from_iter","","",1,[[["intoiterator",8]],["memoryattributes",3]]],[11,"from_iter","","",2,[[["intoiterator",8]],["memorypermissions",3]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"clone","sunrise_libkern::error","",7,[[],["kernelerror",3]]],[11,"clone","sunrise_libkern::process","",9,[[],["processcategory",3]]],[11,"clone","","",11,[[],["kipheader",3]]],[11,"clone","","",12,[[],["processstate",3]]],[11,"clone","","",13,[[],["processinfotype",3]]],[11,"clone","sunrise_libkern","",0,[[],["memorystate",3]]],[11,"clone","","",6,[[],["memorytype",4]]],[11,"clone","","",1,[[],["memoryattributes",3]]],[11,"clone","","",2,[[],["memorypermissions",3]]],[11,"default","sunrise_libkern::process","",9,[[],["processcategory",3]]],[11,"default","","",11,[[],["kipheader",3]]],[11,"default","","",12,[[],["processstate",3]]],[11,"default","","",13,[[],["processinfotype",3]]],[11,"default","sunrise_libkern","",0,[[],["memorystate",3]]],[11,"default","","",1,[[],["memoryattributes",3]]],[11,"default","","",2,[[],["memorypermissions",3]]],[11,"default","","",3,[[],["memoryinfo",3]]],[11,"initialize","","",5,[[]]],[11,"bit_range","sunrise_libkern::process","",8,[[]]],[11,"set_bit_range","","",8,[[]]]],"p":[[3,"MemoryState"],[3,"MemoryAttributes"],[3,"MemoryPermissions"],[3,"MemoryInfo"],[3,"TLS"],[3,"SYSCALL_NAMES"],[4,"MemoryType"],[3,"KernelError"],[3,"ProcInfoFlags"],[3,"ProcessCategory"],[3,"ProcInfo"],[3,"KipHeader"],[3,"ProcessState"],[3,"ProcessInfoType"],[4,"PoolPartition"],[4,"ProcInfoAddrSpace"]]},\
"sunrise_libtimezone":{"doc":"Local Time crate","i":[[3,"TimeTypeInfo","sunrise_libtimezone","Represent a TimeZone type info.",null,null],[12,"gmt_offset","","The GMT offset of the time type info.",0,null],[12,"is_dst","","True if the time type info represent a Day Saving Time.",0,null],[12,"abbreviation_list_index","","The index inside the TimeZoneRule char array of the…",0,null],[12,"is_std","","True if this represent a Standard Time Daylight.",0,null],[12,"is_gmt","","True if this represent a GMT time.",0,null],[12,"padding","","Explicit padding.",0,null],[3,"TimeZoneRule","","Represent the rules defining a TimeZone.",null,null],[12,"timecnt","","The count of time transitions.",1,null],[12,"typecnt","","The count of time type infos.",1,null],[12,"charcnt","","The count of chars.",1,null],[12,"goback","","Used to control the rule that should apply when a…",1,null],[12,"goahead","","Used to control the rule that should apply when a…",1,null],[12,"ats","","Time transition timepoints.",1,null],[12,"types","","Time transition types.",1,null],[12,"ttis","","Time type infos.",1,null],[12,"chars","","The chars.",1,null],[12,"default_type","","The index of the default type (usually zero).",1,null],[12,"reserved","","Reserved / Unused space.",1,null],[3,"CalendarTimeInfo","","Represent the basic informations of a local time.",null,null],[12,"year","","The year of the local time.",2,null],[12,"month","","The month of the local time.",2,null],[12,"day","","The day of the local time.",2,null],[12,"hour","","The hour of the local time.",2,null],[12,"minute","","The minute of the local time.",2,null],[12,"second","","The seconds of the local time.",2,null],[3,"CalendarAdditionalInfo","","Represent the aditional information attached to a local…",null,null],[12,"day_of_week","","The day of the week of the local time.",3,null],[12,"day_of_year","","The day of the year of the local time.",3,null],[12,"timezone_name","","The name of the timezone of the local time.",3,null],[12,"is_dst","","True if the local time represent a Day Saving Time.",3,null],[12,"gmt_offset","","The GMT offset of the timezone used to generate this local…",3,null],[3,"CalendarTime","","Represent a local time.",null,null],[12,"time","","The local time basic informations.",4,null],[12,"additional_info","","Additional information of the local time.",4,null],[4,"TimeZoneError","","Represent a time zone error.",null,null],[13,"OutOfRange","","The time values got out of range internally (usually an…",5,null],[13,"TimeNotFound","","The given calendar timestamp couldn\'t be computed.",5,null],[13,"InvalidSize","","The given Tzif file couldn\'t be stored to a TimeZoneRule…",5,null],[13,"InvalidData","","Some data inside the Tzif file are invalid.",5,null],[13,"InvalidTypeCount","","Some data inside the Tzif file are invalid (type…",5,null],[13,"InvalidTimeComparison","","An invalid time comparaison occured (is the time in range…",5,null],[13,"Overflow","","Signed overflow/underflow happened.",5,null],[13,"Unknown","","Unknown.",5,null],[5,"create_calendar_time","","Create a CalendarTime from a timestamp and a GMT offset.",null,[[["time",6]],[["calendartime",3],["timezoneresult",6]]]],[0,"conversion","","Conversion module",null,null],[3,"ConversionBuffer","sunrise_libtimezone::conversion","Represent a buffer used to convert a TzIf file to a…",null,null],[12,"work_buffer","","The work buffer containing the TzIf file content.",6,null],[12,"temp_rules","","A temporary storage used to store the result of…",6,null],[3,"TzifHeader","","Represent the header of a Tzif file.",null,null],[12,"magic","","The magic number of a Tzif file (\\\"TZif\\\").",7,null],[12,"version","","The version number of the TzIf file.",7,null],[12,"reserved","","Reserved for future usage.",7,null],[12,"ttis_gmt_count","","The count of GMT TimeTypeInfo.",7,null],[12,"ttis_std_count","","The count of Standard Time Daylight TimeTypeInfo.",7,null],[12,"leap_count","","The count of leap definitions.",7,null],[12,"time_count","","The count of time transitions.",7,null],[12,"type_count","","The count of time type infos.",7,null],[12,"char_count","","The count of chars.",7,null],[3,"Rule","","Represent a rule of a POSIX TimeZone name.",null,null],[12,"rule_type","","The type of this rule.",8,null],[12,"day","","The day of this rule.",8,null],[12,"week","","The day of this rule.",8,null],[12,"month","","The month of this rule.",8,null],[12,"time","","The time of this rule.",8,null],[4,"RuleType","","Represent a rule type of a POSIX TimeZone name.",null,null],[13,"JulianDay","","Represent a day in the Julian Calendar.",9,null],[13,"DayOfYear","","Represent a day of the year.",9,null],[13,"MonthNthDayOfWeek","","Represent the month number and the day of the week.",9,null],[13,"Invalid","","Invalid type.",9,null],[5,"differ_by_repeat","","Return true if t1 - t0 equals to the count of seconds…",null,[[["time",6]]]],[5,"detzcode","","Convert a Tzif 32 bits integer to a platform dependent 32…",null,[[]]],[5,"detzcode64","","Convert a Tzif 64 bits integer to a platform dependent 64…",null,[[]]],[5,"get_qz_name","","Get as shrinked slice at the given delimiter.",null,[[]]],[5,"get_tz_name","","Get the timezone name from a given slice.",null,[[]]],[5,"get_num","","Parse a number and return the rest if the number is in…",null,[[],["option",4]]],[5,"get_secs","","Parse a time and return the rest while giving the seconds…",null,[[],["option",4]]],[5,"get_rule","","Parse the given rule and return the rest if valid.",null,[[["rule",3]],["option",4]]],[5,"get_offset","","Parse the offset of a rule and return the rest if valid.",null,[[],["option",4]]],[5,"translate_rule_to_time","","Translate a given rule to a Time.",null,[[["rule",3]],["time",6]]],[5,"parse_timezone_name","","Parse a POSIX timezone c string into a TimeZoneRule.",null,[[["timezonerule",3]]]],[5,"tzif_header_from_bytes","","Convert a slice to a ref to a TzifHeader with the…",null,[[],["tzifheader",3]]],[5,"load_body","","Load the given timezones rules from a given…",null,[[["timezonerule",3],["conversionbuffer",3]],["timezoneresult",6]]],[17,"GMT_TZ_STRING","","GMT POSIX Time Zone abreviation.",null,null],[17,"TZ_DEFAULT_RULE","","Default POSIX Time Zone rules.",null,null],[0,"misc","sunrise_libtimezone","Misc utils",null,null],[5,"len_cstr","sunrise_libtimezone::misc","Compute the length of a C string.",null,[[]]],[5,"compare_cstr","","Compare two C strings.",null,[[]]],[0,"utils","sunrise_libtimezone","Utils used for local time managment.",null,null],[5,"increment_overflow","sunrise_libtimezone::utils","Increment the given `ip` with `j` if it doesn\'t overflow.",null,[[["num",8],["copy",8],["checkedadd",8]]]],[5,"normalize_overflow","","Normalize and increment the given `ip` with the given…",null,[[]]],[5,"is_leap_year","","Return true if it\'s a leap year.",null,[[]]],[5,"get_leap_days_not_neg","","Actual implementation of get_leap_days.",null,[[]]],[5,"get_leap_days","","Get the total count of leap days since year 1.",null,[[]]],[6,"Time","sunrise_libtimezone","The type used to express time internally.",null,null],[6,"PosixTime","","The type used to express time at the API level.",null,null],[6,"TimeZoneResult","","The Result of a time conversion.",null,null],[17,"TIME_T_MAX","","The max value of the Time type.",null,null],[17,"TIME_T_MIN","","The min value of the Time type.",null,null],[17,"TZ_MAX_TIMES","","The max number of time transitions that can be stored in a…",null,null],[17,"TZ_MAX_TYPES","","The max number of type time infos that can be stored in a…",null,null],[17,"TZ_NAME_MAX","","The max size of a POSIX TimeZone name.",null,null],[17,"TZ_MAX_LEAPS","","The max number of leaps definition in TzIf files.",null,null],[17,"TZ_MAX_CHARS","","The max number of chars that can be stored in a…",null,null],[17,"EPOCH_YEAR","","The year of the UNIX Epoch.",null,null],[17,"YEAR_BASE","","The year base of the EPOCH_YEAR.",null,null],[17,"EPOCH_WEEK_DAY","","The week day of the UNIX Epoch.",null,null],[17,"SECS_PER_MIN","","The count of seconds in a minute.",null,null],[17,"MINS_PER_HOUR","","The count of minutes in an hour.",null,null],[17,"HOURS_PER_DAY","","The count of hours in a day.",null,null],[17,"DAYS_PER_WEEK","","The count of days in a week.",null,null],[17,"DAYS_PER_NYEAR","","The count of days in a common year.",null,null],[17,"DAYS_PER_LYEAR","","The count of days in a leap year.",null,null],[17,"MONS_PER_YEAR","","The count of months in a year.",null,null],[17,"SECS_PER_HOUR","","The count of seconds in an hour.",null,null],[17,"SECS_PER_DAY","","The count of seconds in a day.",null,null],[17,"YEAR_LENGTHS","","The year lengths definition (index 0 is a common year,…",null,null],[17,"MON_LENGTHS","","The month lengths definition (index 0 is a common year,…",null,null],[17,"YEARS_PER_REPEAT","","The number of year before a reset of leap years.",null,null],[17,"AVERAGE_SECS_PER_YEAR","","The average count of seconds per year.",null,null],[17,"SECS_PER_REPEAT","","The number of seconds before a reset of leap years.",null,null],[11,"new","","Create a new TimeTypeInfo.",0,[[]]],[11,"from_bytes","","Load the given timezones rules from a given slice contains…",1,[[]]],[11,"from_mut_bytes","","Load the given timezones rules from a given slice contains…",1,[[]]],[11,"load_rules","","Load the given timezones rules from a given slice…",1,[[["timezonerule",3]],["timezoneresult",6]]],[11,"to_calendar_time","","Convert a PosixTime to a CalendarTime using the current…",1,[[["posixtime",6]],[["calendartime",3],["timezoneresult",6]]]],[11,"to_posix_time","","Convert a CalendarTime to a PosixTime using the current…",1,[[["calendartimeinfo",3]],[["posixtime",6],["timezoneresult",6]]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","sunrise_libtimezone::conversion","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"fmt","sunrise_libtimezone","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"eq","","",0,[[["timetypeinfo",3]]]],[11,"eq","","",2,[[["calendartimeinfo",3]]]],[11,"ne","","",2,[[["calendartimeinfo",3]]]],[11,"partial_cmp","","",2,[[],[["option",4],["ordering",4]]]],[11,"clone","","",0,[[],["timetypeinfo",3]]],[11,"clone","","",1,[[],["timezonerule",3]]],[11,"clone","","",2,[[],["calendartimeinfo",3]]],[11,"clone","","",3,[[],["calendaradditionalinfo",3]]],[11,"clone","","",4,[[],["calendartime",3]]],[11,"default","sunrise_libtimezone::conversion","",8,[[]]],[11,"default","sunrise_libtimezone","",0,[[]]],[11,"default","","",2,[[]]],[11,"default","","",3,[[]]],[11,"default","","",4,[[],["calendartime",3]]],[11,"default","","",1,[[]]]],"p":[[3,"TimeTypeInfo"],[3,"TimeZoneRule"],[3,"CalendarTimeInfo"],[3,"CalendarAdditionalInfo"],[3,"CalendarTime"],[4,"TimeZoneError"],[3,"ConversionBuffer"],[3,"TzifHeader"],[3,"Rule"],[4,"RuleType"]]},\
"sunrise_libuser":{"doc":"Userspace library","i":[[0,"loop_future","sunrise_libuser","Definition of the `LoopFn` combinator, implementing…",null,null],[4,"Loop","sunrise_libuser::loop_future","The status of a `loop_fn` loop.",null,null],[13,"Break","","Indicates that the loop has completed with output `T`.",0,null],[13,"Continue","","Indicates that the loop function should be called again…",0,null],[3,"LoopFn","","A future implementing a tail-recursive loop.",null,null],[12,"future","","Future representing the current loop iteration.",1,null],[12,"func","","Function called on every new iteration to generate that…",1,null],[5,"loop_fn","","Creates a new future implementing a tail-recursive loop.",null,[[],["loopfn",3]]],[4,"Poll","","Indicates whether a value is available or if the current…",null,null],[13,"Ready","","Represents that a value is immediately ready.",2,null],[13,"Pending","","Represents that a value is not ready yet.",2,null],[0,"io","sunrise_libuser","The IO interface",null,null],[8,"Io","sunrise_libuser::io","The Io trait allows for accessing device IO in a generic…",null,null],[16,"Value","","The width of the IO access. Should be a primitive type…",3,null],[10,"read","","Reads from this Io.",3,[[]]],[10,"write","","Writes `value` to this Io.",3,[[]]],[11,"readf","","Read from this Io, and mask the value with `flags`.",3,[[]]],[11,"writef","","Mask `value` with `flags`, and write it to this device…",3,[[]]],[3,"ReadOnly","","A read-only wrapper around an IO device.",null,null],[12,"inner","","",4,null],[3,"WriteOnly","","An Io that we can only write to.",null,null],[12,"inner","","",5,null],[3,"Pio","","Port IO accessor.",null,null],[12,"port","","The io port address.",6,null],[12,"value","","The width of the port.",6,null],[3,"Mmio","","A value that can only be accessed volatilely.",null,null],[12,"value","","The value. Can only be accessed through .read()",7,null],[5,"real_start","sunrise_libuser","calls logger initialization, main, and finally exits the…",null,[[]]],[0,"argv","","Argument handling",null,null],[5,"argc","sunrise_libuser::argv","Get the number of arguments in argv.",null,[[]]],[5,"argv","","Get the argument array. It is guaranteed to have at least…",null,[[]]],[5,"envp","","Get the environ array. It is guaranteed to end with a NULL…",null,[[]]],[5,"__libuser_get_args","","Get the arguments and environment. This will parse and…",null,[[]]],[0,"caps","sunrise_libuser","Kernel Capabilities declaration",null,null],[3,"KipHeader","sunrise_libuser::caps","Header for Kernel Builtins. Can be found in the…",null,null],[12,"magic","","Should be *b\\\"KIP1\\\".",8,null],[12,"name","","Name of the program. Pad with \\\\0 if it\'s less than 12 bytes.",8,null],[12,"title_id","","Titleid of the program. Should start with 0x02 to avoid…",8,null],[12,"process_category","","Category of the process. Should always be KernelBuiltin.",8,null],[12,"main_thread_priority","","Priority of the starting thread.",8,null],[12,"default_cpu_core","","CPU core the starting thread runs on.",8,null],[12,"reserved","","Reserved, leave to 0.",8,null],[12,"flags","","Bitflags controlling the behavior of the process:",8,null],[12,"stack_page_count","","Number of pages for the starting thread\'s stack.",8,null],[3,"ProcessCategory","","Category of the process.",null,null],[12,"0","","",9,null],[5,"kernel_flags","","Create a kernel flag capability. Specifies the…",null,[[]]],[5,"map_normal_page","","Maps the given physical memory page at a random address on…",null,[[]]],[5,"ioport","","Allows the process to use the given IO Ports directly…",null,[[]]],[5,"irq_pair","","Allows the process to create an IRQEvent for those IRQs.…",null,[[]]],[5,"application_type","","Declare the type of the application. 0 is a sysmodule, 1…",null,[[]]],[5,"kernel_release_version","","The minimum kernel version this process expects.",null,[[]]],[5,"handle_table_size","","Declare the maximum number of live handles this process is…",null,[[]]],[5,"debug_flags","","Declares whether this application can be debugged (e.g. it…",null,[[]]],[0,"syscalls","sunrise_libuser","Syscall Wrappers",null,null],[0,"nr","sunrise_libuser::syscalls","Syscall numbers",null,null],[17,"SetHeapSize","sunrise_libuser::syscalls::nr","",null,null],[17,"SetMemoryPermission","","",null,null],[17,"SetMemoryAttribute","","",null,null],[17,"MapMemory","","",null,null],[17,"UnmapMemory","","",null,null],[17,"QueryMemory","","",null,null],[17,"ExitProcess","","",null,null],[17,"CreateThread","","",null,null],[17,"StartThread","","",null,null],[17,"ExitThread","","",null,null],[17,"SleepThread","","",null,null],[17,"GetThreadPriority","","",null,null],[17,"SetThreadPriority","","",null,null],[17,"GetThreadCoreMask","","",null,null],[17,"SetThreadCoreMask","","",null,null],[17,"GetCurrentProcessorNumber","","",null,null],[17,"SignalEvent","","",null,null],[17,"ClearEvent","","",null,null],[17,"MapSharedMemory","","",null,null],[17,"UnmapSharedMemory","","",null,null],[17,"CreateTransferMemory","","",null,null],[17,"CloseHandle","","",null,null],[17,"ResetSignal","","",null,null],[17,"WaitSynchronization","","",null,null],[17,"CancelSynchronization","","",null,null],[17,"ArbitrateLock","","",null,null],[17,"ArbitrateUnlock","","",null,null],[17,"WaitProcessWideKeyAtomic","","",null,null],[17,"SignalProcessWideKey","","",null,null],[17,"GetSystemTick","","",null,null],[17,"ConnectToNamedPort","","",null,null],[17,"SendSyncRequestLight","","",null,null],[17,"SendSyncRequest","","",null,null],[17,"SendSyncRequestWithUserBuffer","","",null,null],[17,"SendAsyncRequestWithUserBuffer","","",null,null],[17,"GetProcessId","","",null,null],[17,"GetThreadId","","",null,null],[17,"Break","","",null,null],[17,"OutputDebugString","","",null,null],[17,"ReturnFromException","","",null,null],[17,"GetInfo","","",null,null],[17,"FlushEntireDataCache","","",null,null],[17,"FlushDataCache","","",null,null],[17,"MapPhysicalMemory","","",null,null],[17,"UnmapPhysicalMemory","","",null,null],[17,"GetFutureThreadInfo","","",null,null],[17,"GetLastThreadInfo","","",null,null],[17,"GetResourceLimitLimitValue","","",null,null],[17,"GetResourceLimitCurrentValue","","",null,null],[17,"SetThreadActivity","","",null,null],[17,"GetThreadContext3","","",null,null],[17,"WaitForAddress","","",null,null],[17,"SignalToAddress","","",null,null],[17,"DumpInfo","","",null,null],[17,"DumpInfoNew","","",null,null],[17,"CreateSession","","",null,null],[17,"AcceptSession","","",null,null],[17,"ReplyAndReceiveLight","","",null,null],[17,"ReplyAndReceive","","",null,null],[17,"ReplyAndReceiveWithUserBuffer","","",null,null],[17,"CreateEvent","","",null,null],[17,"MapPhysicalMemoryUnsafe","","",null,null],[17,"UnmapPhysicalMemoryUnsafe","","",null,null],[17,"SetUnsafeLimit","","",null,null],[17,"CreateCodeMemory","","",null,null],[17,"ControlCodeMemory","","",null,null],[17,"SleepSystem","","",null,null],[17,"ReadWriteRegister","","",null,null],[17,"SetProcessActivity","","",null,null],[17,"CreateSharedMemory","","",null,null],[17,"MapTransferMemory","","",null,null],[17,"UnmapTransferMemory","","",null,null],[17,"CreateInterruptEvent","","",null,null],[17,"QueryPhysicalAddress","","",null,null],[17,"QueryIoMapping","","",null,null],[17,"CreateDeviceAddressSpace","","",null,null],[17,"AttachDeviceAddressSpace","","",null,null],[17,"DetachDeviceAddressSpace","","",null,null],[17,"MapDeviceAddressSpaceByForce","","",null,null],[17,"MapDeviceAddressSpaceAligned","","",null,null],[17,"MapDeviceAddressSpace","","",null,null],[17,"UnmapDeviceAddressSpace","","",null,null],[17,"InvalidateProcessDataCache","","",null,null],[17,"StoreProcessDataCache","","",null,null],[17,"FlushProcessDataCache","","",null,null],[17,"DebugActiveProcess","","",null,null],[17,"BreakDebugProcess","","",null,null],[17,"TerminateDebugProcess","","",null,null],[17,"GetDebugEvent","","",null,null],[17,"ContinueDebugEvent","","",null,null],[17,"GetProcessList","","",null,null],[17,"GetThreadList","","",null,null],[17,"GetDebugThreadContext","","",null,null],[17,"SetDebugThreadContext","","",null,null],[17,"QueryDebugProcessMemory","","",null,null],[17,"ReadDebugProcessMemory","","",null,null],[17,"WriteDebugProcessMemory","","",null,null],[17,"SetHardwareBreakPoint","","",null,null],[17,"GetDebugThreadParam","","",null,null],[17,"GetSystemInfo","","",null,null],[17,"CreatePort","","",null,null],[17,"ManageNamedPort","","",null,null],[17,"ConnectToPort","","",null,null],[17,"SetProcessMemoryPermission","","",null,null],[17,"MapProcessMemory","","",null,null],[17,"UnmapProcessMemory","","",null,null],[17,"QueryProcessMemory","","",null,null],[17,"MapProcessCodeMemory","","",null,null],[17,"UnmapProcessCodeMemory","","",null,null],[17,"CreateProcess","","",null,null],[17,"StartProcess","","",null,null],[17,"TerminateProcess","","",null,null],[17,"GetProcessInfo","","",null,null],[17,"CreateResourceLimit","","",null,null],[17,"SetResourceLimitLimitValue","","",null,null],[17,"CallSecureMonitor","","",null,null],[17,"MapFramebuffer","","",null,null],[17,"StartProcessEntrypoint","","",null,null],[17,"MapMmioRegion","","",null,null],[17,"SetThreadArea","","",null,null],[17,"MaxSvc","","",null,null],[3,"MemoryInfo","sunrise_libuser::syscalls","The structure returned by the `query_memory` syscall.",null,null],[12,"baseaddr","","The base address of this memory region.",10,null],[12,"size","","The size of this memory region, from the base address.",10,null],[12,"memtype","","The type of this mapping.",10,null],[12,"memattr","","The attributes of this mapping.",10,null],[12,"perms","","The permissions of this mapping.",10,null],[12,"ipc_ref_count","","Counts how many IPC service requests have an IPC buffer in…",10,null],[12,"device_ref_count","","Unknown.",10,null],[3,"MemoryPermissions","","Memory permissions of a memory area.",null,null],[12,"bits","","",11,null],[4,"PoolPartition","","Kernel memory pool.",null,null],[13,"Application","","Pool of memory usable by applications. Usually 3GiB.",12,null],[13,"Applet","","Pool of memory usable by applets. Usually 512MiB.",12,null],[13,"Sysmodule","","Pool of memory usable by system modules.",12,null],[13,"Nvservices","","Pool of memory usable by nvidia\'s driver.",12,null],[4,"ProcInfoAddrSpace","","Address space type to use when creating a process.",null,null],[13,"AS32Bit","","32-bit address space, spanning from 0x00200000 to…",13,null],[13,"AS32BitNoMap","","32-bit address space without the map region.",13,null],[13,"AS36Bit","","36-bit address space, spanning from 0x08000000 to…",13,null],[13,"AS39Bit","","39-bit address space, spanning from 0x08000000 to…",13,null],[3,"ProcInfoFlags","","Miscelaneous flags.",null,null],[12,"0","","",14,null],[3,"ProcessCategory","","Category of the process.",null,null],[12,"0","","",9,null],[3,"ProcInfo","","Informations necessary for the create_process syscall.",null,null],[12,"name","","Name of the process (as seen by debuggers).",15,null],[12,"process_category","","Category of the process. Should always be RegularTitle.",15,null],[12,"title_id","","TitleId of the process (as seen by svcGetInfo and…",15,null],[12,"code_addr","","Address where the main module\'s code will be loaded. Must…",15,null],[12,"code_num_pages","","Number of pages to allocate for code.",15,null],[12,"flags","","Miscelaneous flags",15,null],[12,"resource_limit_handle","","Resource limit to use for this process. If None, will use…",15,null],[12,"system_resource_num_pages","","Maximum amount of kernel memory used to create the…",15,null],[3,"KipHeader","","Header for Kernel Builtins. Can be found in the…",null,null],[12,"magic","","Should be *b\\\"KIP1\\\".",8,null],[12,"name","","Name of the program. Pad with \\\\0 if it\'s less than 12 bytes.",8,null],[12,"title_id","","Titleid of the program. Should start with 0x02 to avoid…",8,null],[12,"process_category","","Category of the process. Should always be KernelBuiltin.",8,null],[12,"main_thread_priority","","Priority of the starting thread.",8,null],[12,"default_cpu_core","","CPU core the starting thread runs on.",8,null],[12,"reserved","","Reserved, leave to 0.",8,null],[12,"flags","","Bitflags controlling the behavior of the process:",8,null],[12,"stack_page_count","","Number of pages for the starting thread\'s stack.",8,null],[3,"ProcessState","","The state the process is currently in.",null,null],[12,"0","","",16,null],[3,"ProcessInfoType","","Kind of information to extract from a process wit…",null,null],[12,"0","","",17,null],[3,"Registers","","Register backup structure. The syscall_inner will pop the…",null,null],[12,"eax","","",18,null],[12,"ebx","","",18,null],[12,"ecx","","",18,null],[12,"edx","","",18,null],[12,"esi","","",18,null],[12,"edi","","",18,null],[12,"ebp","","",18,null],[5,"syscall","","Generic syscall function.",null,[[],[["result",4],["kernelerror",3]]]],[5,"set_heap_size","","Resize the heap of a process, just like a brk. It can both…",null,[[],[["kernelerror",3],["result",4]]]],[5,"query_memory","","Query information about an address. Will fetch the…",null,[[],[["kernelerror",3],["result",4]]]],[5,"exit_process","","Exits the process, killing all threads.",null,[[]]],[5,"create_thread","","Creates a thread in the current process.",null,[[],[["result",4],["kernelerror",3],["thread",3]]]],[5,"start_thread","","Starts the thread for the provided handle.",null,[[["thread",3]],[["kernelerror",3],["result",4]]]],[5,"exit_thread","","Exits the current thread.",null,[[]]],[5,"sleep_thread","","Sleeps for a specified amount of time, or yield thread.",null,[[],[["kernelerror",3],["result",4]]]],[5,"signal_event","","Sets the \\\"signaled\\\" state of an event. Calling this on an…",null,[[["writableevent",3]],[["kernelerror",3],["result",4]]]],[5,"clear_event","","Clear the \\\"signaled\\\" state of an event. After calling this…",null,[[["handleref",3]],[["kernelerror",3],["result",4]]]],[5,"create_shared_memory","","Creates a shared memory handle.",null,[[["memorypermissions",3]],[["sharedmemory",3],["kernelerror",3],["result",4]]]],[5,"map_shared_memory","","Maps a shared memory.",null,[[["sharedmemory",3],["memorypermissions",3]],[["kernelerror",3],["result",4]]]],[5,"unmap_shared_memory","","Unmaps a shared memory.",null,[[["sharedmemory",3]],[["kernelerror",3],["result",4]]]],[5,"close_handle","","Close the given handle.",null,[[],[["kernelerror",3],["result",4]]]],[5,"wait_synchronization","","Wait for an event on the given handles.",null,[[["option",4]],[["kernelerror",3],["result",4]]]],[5,"connect_to_named_port","","Creates a session to the given named port.",null,[[],[["kernelerror",3],["result",4],["clientsession",3]]]],[5,"send_sync_request_with_user_buffer","","Send an IPC request through the given pipe.",null,[[["clientsession",3]],[["kernelerror",3],["result",4]]]],[5,"output_debug_string","","Print the given string to the kernel\'s debug output.",null,[[],[["kernelerror",3],["result",4]]]],[5,"create_session","","Create an anonymous session.",null,[[],[["result",4],["kernelerror",3]]]],[5,"accept_session","","Accept a connection on the given port.",null,[[["serverport",3]],[["result",4],["kernelerror",3],["serversession",3]]]],[5,"reply_and_receive_with_user_buffer","","Reply and Receive IPC requests on the given handles.",null,[[["option",4],["handleref",3],["option",4]],[["kernelerror",3],["result",4]]]],[5,"create_event","","Create a [ReadableEvent]/[WritableEvent] pair.",null,[[],[["kernelerror",3],["result",4]]]],[5,"create_interrupt_event","","Create a waitable object for the given IRQ number.",null,[[],[["result",4],["kernelerror",3],["readableevent",3]]]],[5,"query_physical_address","","Gets the physical region a given virtual address maps.",null,[[],[["result",4],["kernelerror",3]]]],[5,"create_port","","Creates an anonymous port.",null,[[],[["result",4],["kernelerror",3]]]],[5,"manage_named_port","","Creates a named port.",null,[[],[["result",4],["kernelerror",3],["serverport",3]]]],[5,"connect_to_port","","Connects to the given named port.",null,[[["clientport",3]],[["kernelerror",3],["result",4],["clientsession",3]]]],[5,"map_framebuffer","","Maps the framebuffer to a kernel-chosen address.",null,[[],[["result",4],["kernelerror",3]]]],[5,"map_mmio_region","","Maps a physical region in the address space of the process.",null,[[],[["kernelerror",3],["result",4]]]],[5,"set_thread_area","","Set thread local area pointer.",null,[[],[["kernelerror",3],["result",4]]]],[5,"set_process_memory_permission","","Change permission of a page-aligned memory region.…",null,[[["process",3],["memorypermissions",3]],[["kernelerror",3],["result",4]]]],[5,"map_process_memory","","Maps the given src memory range from a remote process into…",null,[[["process",3]],[["kernelerror",3],["result",4]]]],[5,"unmap_process_memory","","Unmaps a memory range mapped with [map_process_memory()].…",null,[[["process",3]],[["kernelerror",3],["result",4]]]],[5,"create_process","","Creates a new process with the given parameters.",null,[[["procinfo",3]],[["process",3],["kernelerror",3],["result",4]]]],[5,"start_process","","Start the given process on the provided CPU with the…",null,[[["process",3]],[["kernelerror",3],["result",4]]]],[5,"get_process_info","","Extract information from a process.",null,[[["process",3],["processinfotype",3]],[["kernelerror",3],["result",4]]]],[5,"reset_signal","","Clear the \\\"signaled\\\" state of a readable event or process.…",null,[[["handleref",3]],[["kernelerror",3],["result",4]]]],[5,"get_process_id","","Gets the PID of the given Process handle. Alias handles…",null,[[["process",3]],[["result",4],["kernelerror",3]]]],[5,"terminate_process","","Kills the given process, terminating the execution of all…",null,[[["process",3]],[["kernelerror",3],["result",4]]]],[5,"get_process_list","","Fills the provided array with the pids of currently living…",null,[[],[["kernelerror",3],["result",4]]]],[5,"syscall_inner","","",null,null],[0,"syscall_inner","","",null,null],[5,"syscall_inner","sunrise_libuser::syscalls::syscall_inner","",null,[[["registers",3]]]],[0,"mem","sunrise_libuser","Memory",null,null],[5,"find_free_address","sunrise_libuser::mem","Finds a free memory zone of the given size and alignment…",null,[[],[["result",4],["error",4]]]],[5,"map_mmio","","Maps a Mmio struct in the virtual memory of this process.",null,[[],[["result",4],["kernelerror",3]]]],[5,"virt_to_phys","","Gets the physical address of a structure from its virtual…",null,[[]]],[17,"PAGE_SIZE","","The size of page. Used to interface with the kernel.",null,null],[0,"types","sunrise_libuser","Core kernel types.",null,null],[3,"Handle","sunrise_libuser::types","A Handle is a sort of reference to a Kernel Object. Its…",null,null],[12,"0","","",19,null],[3,"HandleRef","","A fake reference to a Handle. Has the same representation…",null,null],[12,"inner","","The underlying handle number.",20,null],[12,"lifetime","","The real handle this reference is tied to.",20,null],[3,"IRQEvent","","A handle on an IRQ event.",null,null],[12,"0","","",21,null],[3,"ReadableEvent","","The readable part of an event. The user shall use this end…",null,null],[12,"0","","",22,null],[3,"WritableEvent","","The writable part of an event. The user shall use this end…",null,null],[12,"0","","",23,null],[3,"ClientSession","","The client side of an IPC session.",null,null],[12,"0","","",24,null],[3,"ServerSession","","The server side of an IPC session.",null,null],[12,"0","","",25,null],[3,"ClientPort","","The client side of an IPC Port. Allows connecting to an…",null,null],[12,"0","","",26,null],[3,"ServerPort","","The server side of an IPC Port. Allows listening for…",null,null],[12,"0","","",27,null],[3,"Thread","","A Thread. Created with the [create_thread syscall].",null,null],[12,"0","","",28,null],[3,"Process","","A Process. Created with `create_process` syscall, or by…",null,null],[12,"0","","",29,null],[3,"SharedMemory","","A handle to memory that may be mapped in multiple…",null,null],[12,"0","","",30,null],[3,"MappedSharedMemory","","A mapping to a shared memory region.",null,null],[12,"handle","","",31,null],[12,"addr","","",31,null],[12,"size","","",31,null],[12,"perm","","",31,null],[3,"Pid","","Process ID, as returned by IPC.",null,null],[12,"0","","",32,null],[11,"new","","Creates a new handle from the given number. This number…",19,[[],["handle",3]]],[11,"as_ref","","Creates a new reference to this handle. See the…",19,[[],["handleref",3]]],[11,"as_ref_static","","Creates a new static reference to this handle. See the…",19,[[],["handleref",3]]],[11,"staticify","","Remove the lifetime on the current HandleRef. See…",20,[[],["handleref",3]]],[11,"wait_async","","Returns a future that waits for the current handle to get…",20,[[["workqueue",3]]]],[11,"clear","","Clears the signaled state.",22,[[],[["kernelerror",3],["result",4]]]],[11,"wait_async","","Waits for the event to get signaled.",22,[[["workqueue",3]]]],[11,"wait_async_cb","","Turns this ReadableEvent into a semaphore-like structure.",22,[[["workqueue",3]]]],[11,"clear","","Clears the signaled state.",23,[[],[["kernelerror",3],["result",4]]]],[11,"signal","","Signals the event, setting its state to signaled and…",23,[[],[["kernelerror",3],["result",4]]]],[11,"send_sync_request_with_user_buffer","","Send an IPC request to the handle, and wait for a…",24,[[],[["result",4],["error",4]]]],[11,"into_handle","","Consumes the session, returning the underlying handle.…",24,[[],["handle",3]]],[11,"try_clone","","Clones the current object, returning a new handle. The…",24,[[],[["result",4],["clientsession",3],["error",4]]]],[11,"receive","","Receives an IPC request from the session, waiting if none…",25,[[["option",4]],[["result",4],["error",4]]]],[11,"reply","","Replies to an IPC request on the given session. If the…",25,[[],[["result",4],["error",4]]]],[11,"wait_async","","Waits for the server to receive a request.",25,[[["workqueue",3]]]],[11,"connect","","Connects to a port, returning a session on which to send…",26,[[],[["result",4],["clientsession",3],["error",4]]]],[11,"accept","","Accepts a connection to the port, returning a server…",27,[[],[["serversession",3],["error",4],["result",4]]]],[11,"wait_async","","Waits for the server to receive a connection.",27,[[["workqueue",3]]]],[11,"current","","Gets the current process handle. Uses the 0xFFFF8000…",28,[[],["thread",3]]],[11,"current","","Gets the current process handle. Uses the 0xFFFF8001…",29,[[],["process",3]]],[11,"start","","Start the given process on the provided CPU with the…",29,[[],[["result",4],["error",4]]]],[11,"state","","Get the state the given process is currently in.",29,[[],[["error",4],["result",4],["processstate",3]]]],[11,"wait_async","","Waits for the process to change state. Use…",29,[[["workqueue",3]]]],[11,"reset_signal","","Clear the \\\"signaled\\\" state of a process. A process moves…",29,[[],[["result",4],["error",4]]]],[11,"pid","","Gets the [Pid] of this Process.",29,[[],[["result",4],["pid",3],["error",4]]]],[11,"new","","Creates a new Shared Memory handle. The physical memory…",30,[[["memorypermissions",3]],[["result",4],["sharedmemory",3],["error",4]]]],[11,"map","","Maps the current shared memory at the given address,…",30,[[["memorypermissions",3]],[["error",4],["result",4],["mappedsharedmemory",3]]]],[11,"as_ptr","","Gets a raw pointer to the underlying shared memory.",31,[[]]],[11,"as_mut_ptr","","Gets a mutable raw pointer to the underlying shared memory.",31,[[]]],[11,"len","","Gets the byte length of the mapped shared memory.",31,[[]]],[11,"as_shared_mem","","Return a reference to the underlying shared memory. Useful…",31,[[],["sharedmemory",3]]],[0,"ipc","sunrise_libuser","Core IPC Routines",null,null],[3,"MsgPackedHdr","sunrise_libuser::ipc","Represenens the header of an HIPC command.",null,null],[12,"0","","",33,null],[3,"HandleDescriptorHeader","","Part of an HIPC command. Sent only when…",null,null],[12,"0","","",34,null],[3,"IPCBuffer","","An IPC Buffer represents a section of memory to send to…",null,null],[12,"addr","","Address to the value",35,null],[12,"size","","Size of the value",35,null],[12,"ty","","Buffer type",35,null],[12,"phantom","","Tie the buffer\'s lifetime to the value\'s ! This is very…",35,null],[3,"Message","","A generic IPC message, representing either an IPC Request…",null,null],[12,"ty","","Type of the message. This is derived from [MessageTy] and…",36,null],[12,"pid","","Optional PID included in the message. For outgoing…",36,null],[12,"buffers","","Array of IPC Buffers included in the message.",36,null],[12,"copy_handles","","Array of copy handles included in the message. Copy…",36,null],[12,"move_handles","","Array of move handles included in the message. Move…",36,null],[12,"is_request","","Whether this message contains an IPC request or an IPC…",36,null],[12,"cmdid_error","","Contains either the cmdid (if this message is a request)…",36,null],[12,"token","","Optional tracking token. This is used to track the origin…",36,null],[12,"raw","","The raw arguments included in this message.",36,null],[4,"IPCBufferType","","Type of an IPC Buffer. Depending on the type, the kernel…",null,null],[13,"A","","Send Buffer.",37,null],[12,"flags","sunrise_libuser::ipc::IPCBufferType","Determines what MemoryState to use with the mapped memory…",38,null],[13,"B","sunrise_libuser::ipc","Receive Buffer.",37,null],[12,"flags","sunrise_libuser::ipc::IPCBufferType","Determines what MemoryState to use with the mapped memory…",39,null],[13,"W","sunrise_libuser::ipc","SendReceive Buffer.",37,null],[12,"flags","sunrise_libuser::ipc::IPCBufferType","Determines what MemoryState to use with the mapped memory…",40,null],[13,"X","sunrise_libuser::ipc","Pointer.",37,null],[12,"counter","sunrise_libuser::ipc::IPCBufferType","The index of the C buffer to copy this pointer into.",41,null],[13,"C","sunrise_libuser::ipc","Receive List.",37,null],[12,"has_u16_size","sunrise_libuser::ipc::IPCBufferType","If true, the size of the receive list should be written in…",42,null],[4,"MessageTy","sunrise_libuser::ipc","Type of an IPC message.",null,null],[13,"Close","","Requests the other end to close the handle and any…",43,null],[13,"Request","","A normal request.",43,null],[13,"Control","","A request handled by the server handler. See [switchbrew]…",43,null],[5,"find_ty_cmdid","","Quickly find the type and cmdid of an IPC message for the…",null,[[],["option",4]]],[0,"server","","IPC Server primitives",null,null],[3,"Align16","sunrise_libuser::ipc::server","Wrapper struct that forces the alignment to 0x10. Somewhat…",null,null],[12,"0","","",44,null],[5,"encode_bytes","","Encode an 8-character service string into an u64",null,[[]]],[5,"common_port_handler","","Infinite loop future that waits for `port` to get…",null,[[["workqueue",3],["serverport",3]]]],[5,"port_handler","","Creates a port through…",null,[[["workqueue",3]],[["result",4],["error",4]]]],[5,"managed_port_handler","","Creates a port through [syscalls::manage_named_port()]…",null,[[["workqueue",3]],[["result",4],["error",4]]]],[5,"new_session_wrapper","","Creates a new top-level future that handles session.",null,[[["workqueue",3],["serversession",3]]]],[5,"control_dispatch","","Implement the Control ipc cmd types.",null,[[["workqueue",3]],[["result",4],["error",4]]]],[0,"hrtb_hack","","Ideally, that\'s what we would want to write async fn…",null,null],[8,"FutureCallback","sunrise_libuser::ipc::server::hrtb_hack","A similar trait to FnMut() but moving the Ret associated…",null,null],[16,"Ret","","See [type FnMut::Output]",45,null],[10,"call","","See [FnMut::call_mut()].",45,[[]]],[8,"SizedIPCBuffer","sunrise_libuser::ipc","Util used for IPC buffer sizing.",null,null],[10,"size","","Return the size of the type.",46,[[]]],[10,"is_cool","","Check if the address and size are correct.",46,[[]]],[10,"from_raw_parts","","Create a reference to a ipc buffer from an address and a…",46,[[]]],[10,"from_raw_parts_mut","","Create a mutable reference to a ipc buffer from an address…",46,[[]]],[11,"ty","","",33,[[]]],[11,"set_ty","","",33,[[]]],[11,"num_x_descriptors","","",33,[[]]],[11,"set_num_x_descriptors","","",33,[[]]],[11,"num_a_descriptors","","",33,[[]]],[11,"set_num_a_descriptors","","",33,[[]]],[11,"num_b_descriptors","","",33,[[]]],[11,"set_num_b_descriptors","","",33,[[]]],[11,"num_w_descriptors","","",33,[[]]],[11,"set_num_w_descriptors","","",33,[[]]],[11,"raw_section_size","","",33,[[]]],[11,"set_raw_section_size","","",33,[[]]],[11,"c_descriptor_flags","","",33,[[]]],[11,"set_c_descriptor_flags","","",33,[[]]],[11,"enable_handle_descriptor","","",33,[[]]],[11,"set_enable_handle_descriptor","","",33,[[]]],[11,"send_pid","","",34,[[]]],[11,"set_send_pid","","",34,[[]]],[11,"num_copy_handles","","",34,[[]]],[11,"set_num_copy_handles","","",34,[[]]],[11,"num_move_handles","","",34,[[]]],[11,"set_num_move_handles","","",34,[[]]],[11,"is_type_a","","Checks if this buffer is a Send Buffer.",37,[[]]],[11,"is_type_b","","Checks if this buffer is a Receive Buffer.",37,[[]]],[11,"is_type_w","","Checks if this buffer is a SendReceive Buffer.",37,[[]]],[11,"is_type_x","","Checks if this buffer is a Pointer Buffer.",37,[[]]],[11,"out_buffer","","Creates a Type-A IPCBuffer from the given reference.",35,[[],["ipcbuffer",3]]],[11,"in_buffer","","Creates a Type-B IPCBuffer from the given reference.",35,[[],["ipcbuffer",3]]],[11,"in_pointer","","Creates a Type-C IPCBuffer from the given reference.",35,[[],["ipcbuffer",3]]],[11,"out_pointer","","Creates a Type-X IPCBuffer from the given reference.",35,[[],["ipcbuffer",3]]],[11,"buftype","","Gets the [IPCBufferType] of this buffer. The buffer type…",35,[[],["ipcbuffertype",4]]],[11,"new_request","","Create a new request for the given cmdid. If a token is…",36,[[["option",4]],["message",3]]],[11,"new_response","","Create a new empty reply. If the request this reply is…",36,[[["option",4]],["message",3]]],[11,"set_ty","","Sets the message type.",36,[[["messagety",4]]]],[11,"set_error","","Set the error code from a reply.",36,[[]]],[11,"error","","Get the error code from a reply.",36,[[],[["result",4],["error",4]]]],[11,"push_raw","","Sets the raw data of the message.",36,[[]]],[11,"raw","","Gets the raw data of the message.",36,[[]]],[11,"token","","Gets the token of a message. This token is used to track…",36,[[],["option",4]]],[11,"push_handle_move","","Move a handle over IPC. Once the message is sent, the…",36,[[["handle",3]]]],[11,"push_handle_copy","","Copy a handle over IPC. The remote process will have a…",36,[[["handleref",3]]]],[11,"pop_handle_move","","Retrieve a moved handle from this IPC message. Those are…",36,[[],[["handle",3],["error",4],["result",4]]]],[11,"pop_handle_copy","","Retrieve a copied handle from this IPC message. Those are…",36,[[],[["handle",3],["error",4],["result",4]]]],[11,"pop_pid","","Retrieve the PID of the remote process (if sent at all).…",36,[[],[["result",4],["pid",3],["error",4]]]],[11,"pop_in_buffer","","Retreive the next InBuffer (type-A buffer) in the message.",36,[[],[["result",4],["error",4]]]],[11,"pop_out_buffer","","Retreive the next OutBuffer (type-B buffer) in the message.",36,[[],[["result",4],["error",4]]]],[11,"push_out_buffer","","Push an OutBuffer (type-A buffer) backed by the specified…",36,[[]]],[11,"push_in_buffer","","Push an InBuffer (type-B buffer) backed by the specified…",36,[[]]],[11,"push_in_pointer","","Push an InPointer (type-C buffer) backed by the specified…",36,[[]]],[11,"push_out_pointer","","Push an OutPointer (type-X buffer) backed by the specified…",36,[[]]],[11,"send_pid","","Send a Pid with this IPC request.",36,[[["pid",3],["option",4]]]],[11,"pop_in_pointer","","Retreive the next InPointer (type-X buffer) in the message.",36,[[],[["result",4],["error",4]]]],[11,"pack","","Packs this IPC Message to an IPC buffer.",36,[[]]],[11,"unpack","","Parse the passed buffer into an IPC Message.",36,[[],["message",3]]],[0,"threads","sunrise_libuser","Low-level api to create threads and start them.",null,null],[3,"StackContext","sunrise_libuser::threads","Stack allocation informations",null,null],[12,"stack_address","","The addresss of the allocated stack",47,null],[12,"stack_layout","","The stack layout.",47,null],[3,"ThreadContext","","Structure holding the thread local context of a thread.…",null,null],[12,"entry_point","","Pointer to the function this thread should execute after…",48,null],[12,"arg","","The argument to call it with.",48,null],[12,"stack","","The stack used by this thread.",48,null],[12,"tls_elf","","The thread local storage of this thread.",48,null],[12,"thread_handle","","The ThreadHandle of this thread.",48,null],[3,"Thread","","Libuser\'s representation of a thread.",null,null],[12,"0","","",49,null],[5,"get_my_tls_region","","Get a pointer to this thread\'s [TLS] region pointed to by…",null,[[]]],[5,"get_my_thread_context","","Get a reference to this thread\'s [ThreadContext], from the…",null,[[],["threadcontext",3]]],[5,"get_my_ipc_buffer","","Get a pointer to this thread\'s [IPCBuffer], from the [TLS]…",null,[[]]],[5,"thread_trampoline","","Small stub executed by every thread but the main thread…",null,[[]]],[5,"init_main_thread","","Initialisation of the main thread\'s thread local structures:",null,[[]]],[7,"MAIN_THREAD_CONTEXT","","Context of the main thread. Instead of allocating it at…",null,null],[17,"DEFAULT_STACK_SIZE","","Default size of a thread\'s stack, in bytes.",null,null],[11,"new","","Create a new StackContext from a given size. The stack…",47,[[],[["error",4],["result",4]]]],[11,"get_stack_top","","Get the address of the stack top.",47,[[]]],[11,"start","","Start this thread.",49,[[],[["result",4],["error",4]]]],[11,"join","","Wait for the thread to exit.",49,[[],[["result",4],["error",4]]]],[11,"create","","Allocates resources for a thread. To start it, call…",49,[[],[["error",4],["result",4]]]],[11,"as_thread_ref","","Get the underlying thread handle.",49,[[],["threadhandle",3]]],[0,"thread_local_storage","sunrise_libuser","Thread Local Storage on x86",null,null],[3,"TlsElf","sunrise_libuser::thread_local_storage","The Thread Local Storage manager for a thread",null,null],[12,"static_region","","The array of static module blocks + TCB",50,null],[3,"ThreadControlBlock","","Elf TLS TCB",null,null],[12,"tp_self_ptr","","Pointer containing its own address.",51,null],[3,"ThreadLocalStaticRegion","","Represents an allocated thread local static region.",null,null],[12,"ptr","","Pointer to the allocated memory",52,null],[12,"layout","","Layout of the allocated memory. Used when deallocating.",52,null],[12,"tcb_offset","","Offset of the TCB in this allocation.",52,null],[5,"tls_align_up","","The `round` function, as defined in section 3.0:",null,[[]]],[7,"__tls_init_image_addr__","","The address of the start of the TLS initialisation image…",null,null],[7,"__tls_file_size__","","The size of the TLS initialisation image in our `.tdata`.",null,null],[7,"__tls_mem_size__","","The total memsize of the TLS segment: .tdata + .tbss",null,null],[7,"__tls_align__","","The alignment of the TLS segment.",null,null],[11,"allocate","","Allocates and initializes the static region, including TCB.",50,[[]]],[11,"enable_for_current_thread","","Calls [`syscalls::set_thread_area`] with the address of…",50,[[]]],[11,"tcb","","Returns a pointer to the [ThreadControlBlock] in the…",52,[[],["threadcontrolblock",3]]],[11,"allocate","","Allocates a ThreadLocalStaticRegion.",52,[[]]],[0,"futures","sunrise_libuser","Futures Executor",null,null],[3,"Task","sunrise_libuser::futures","A Task represents a future spawned on the [WaitableManager].",null,null],[12,"future","","The future backing this task. When the task is woken up,…",53,null],[12,"waker","","The waker used to wake this task up from sleep,…",53,null],[12,"waiting_on","","List of handles that this task is currently waiting on.",53,null],[3,"WorkQueue","","A WorkQueue represents a handle to a [WaitableManager] on…",null,null],[12,"0","","",54,null],[3,"SimpleWorkQueue","","A variant of a WorkQueue that can only push…",null,null],[12,"0","","",55,null],[3,"QueueWaker","","A waker backed by a WorkQueue and an index in the…",null,null],[12,"queue","","The WorkQueue this waker operates on.",56,null],[12,"id","","An index to the future to poll on wake in the…",56,null],[3,"WaitableManager","","The event loop manager. Waits on the waitable objects…",null,null],[12,"work_queue","","Queue of things to do in the next \\\"tick\\\" of the event loop.",57,null],[12,"registry","","List of futures that are currently running on this executor.",57,null],[4,"WorkItem","","A WorkItem is an element of work that will be executed by…",null,null],[13,"Poll","","Causes the [Task] specified by the index to be woken up…",58,null],[13,"Spawn","","Creates a new [Task] backed by the given future on the…",58,null],[13,"WaitHandle","","Registers the [Task] backed by the given [Waker] to be…",58,null],[13,"UnregisterHandle","","Stop the task identified by the Waker from waiting on this…",58,null],[7,"CURRENT_TASK","","Task currently executing on this thread, or None.",null,null],[11,"spawn","","Spawn a top-level future on the event loop. The future…",54,[[["futureobj",3]]]],[11,"simple","","Turn this WorkQueue into a SimpleWorkQueue.",54,[[],["simpleworkqueue",3]]],[11,"wait_for","","Registers the task represented by the given [Context] to…",55,[[["handleref",3],["context",3]]]],[11,"unwait_for","","Unregisters the task represented by the given [Waker] from…",55,[[["handleref",3],["waker",3]]]],[11,"new","","Creates an empty event loop.",57,[[],["waitablemanager",3]]],[11,"work_queue","","Returns a handle to the underlying WorkQueue backing this…",57,[[],["workqueue",3]]],[11,"run","","Runs the event loop, popping items from the underlying…",57,[[]]],[0,"sm","sunrise_libuser","Auto-generated documentation",null,null],[3,"IUserInterfaceProxy","sunrise_libuser::sm","Service Manager",null,null],[12,"0","","",59,null],[8,"IUserInterface","","Service Manager",null,null],[10,"initialize","","Initialize the UserInterface, acquiring the Pid of the…",60,[[["pid",3],["workqueue",3]],[["result",4],["error",4]]]],[10,"get_service","","Returns a handle to the given service. IPC messages may be…",60,[[["workqueue",3]],[["clientsession",3],["error",4],["result",4]]]],[10,"register_service","","Registers a service with the given name. The user can use…",60,[[["workqueue",3]],[["result",4],["serverport",3],["error",4]]]],[10,"unregister_service","","Unregisters a service with the given name. Future calls to…",60,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",60,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IUserInterfaceAsync","","Service Manager",null,null],[10,"initialize","","Initialize the UserInterface, acquiring the Pid of the…",61,[[["pid",3],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_service","","Returns a handle to the given service. IPC messages may be…",61,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"register_service","","Registers a service with the given name. The user can use…",61,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"unregister_service","","Unregisters a service with the given name. Future calls to…",61,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"dispatch","","Handle an incoming IPC request.",61,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"raw_new","","Creates a new [IUserInterfaceProxy] by connecting to the…",59,[[],[["error",4],["iuserinterfaceproxy",3],["result",4]]]],[11,"new","","Acquires the shared handle to the `sm:` service -…",59,[[],[["iuserinterfaceproxy",3],["error",4],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",59,[[],[["error",4],["result",4]]]],[11,"initialize","","Initialize the UserInterface, acquiring the Pid of the…",59,[[],[["result",4],["error",4]]]],[11,"get_service","","Returns a handle to the given service. IPC messages may be…",59,[[],[["clientsession",3],["error",4],["result",4]]]],[11,"register_service","","Registers a service with the given name. The user can use…",59,[[],[["result",4],["serverport",3],["error",4]]]],[11,"unregister_service","","Unregisters a service with the given name. Future calls to…",59,[[],[["result",4],["error",4]]]],[0,"vi","sunrise_libuser","Auto-generated documentation",null,null],[3,"ViInterfaceProxy","sunrise_libuser::vi","Entry point interface.",null,null],[12,"0","","",62,null],[3,"IBufferProxy","","IPC Window object",null,null],[12,"0","","",63,null],[8,"ViInterface","","Entry point interface.",null,null],[10,"create_buffer","","Create a window.",64,[[["sharedmemory",3],["workqueue",3]],[["ibufferproxy",3],["result",4],["error",4]]]],[10,"get_screen_resolution","","Gets the screen resolution.",64,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"get_font_height","","Gets the height of the font used for rendering a terminal…",64,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"create_terminal","","Create a terminal.",64,[[["sharedmemory",3],["workqueue",3]],[["result",4],["ipipeproxy",3],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",64,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"ViInterfaceAsync","","Entry point interface.",null,null],[10,"create_buffer","","Create a window.",65,[[["sharedmemory",3],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"get_screen_resolution","","Gets the screen resolution.",65,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"get_font_height","","Gets the height of the font used for rendering a terminal…",65,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"create_terminal","","Create a terminal.",65,[[["sharedmemory",3],["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"dispatch","","Handle an incoming IPC request.",65,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IBuffer","","IPC Window object",null,null],[10,"draw","","Blit the buffer to the framebuffer.",66,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",66,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IBufferAsync","","IPC Window object",null,null],[10,"draw","","Blit the buffer to the framebuffer.",67,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"dispatch","","Handle an incoming IPC request.",67,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"raw_new","","Creates a new [ViInterfaceProxy] by connecting to the…",62,[[],[["result",4],["viinterfaceproxy",3],["error",4]]]],[11,"new","","Acquires the shared handle to the `vi:` service -…",62,[[],[["error",4],["result",4],["viinterfaceproxy",3]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",62,[[],[["error",4],["result",4]]]],[11,"create_buffer","","Create a window.",62,[[["sharedmemory",3]],[["ibufferproxy",3],["result",4],["error",4]]]],[11,"get_screen_resolution","","Gets the screen resolution.",62,[[],[["result",4],["error",4]]]],[11,"get_font_height","","Gets the height of the font used for rendering a terminal…",62,[[],[["result",4],["error",4]]]],[11,"create_terminal","","Create a terminal.",62,[[["sharedmemory",3]],[["result",4],["ipipeproxy",3],["error",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",63,[[],[["error",4],["result",4]]]],[11,"draw","","Blit the buffer to the framebuffer.",63,[[],[["result",4],["error",4]]]],[0,"ahci","sunrise_libuser","Auto-generated documentation",null,null],[3,"IDiskProxy","sunrise_libuser::ahci","Interface to an AHCI device.",null,null],[12,"0","","",68,null],[3,"AhciInterfaceProxy","","Main ahci interface.",null,null],[12,"0","","",69,null],[6,"Block","","A block (or sector) used by AHCI I/O operations.",null,null],[8,"IDisk","","Interface to an AHCI device.",null,null],[10,"sector_count","","Retrieves the number of addressable 512-octet sectors on…",70,[[["workqueue",3]],[["error",4],["result",4]]]],[10,"read_dma","","Reads sectors from the disk.",70,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"write_dma","","Writes sectors to the disk.",70,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",70,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IDiskAsync","","Interface to an AHCI device.",null,null],[10,"sector_count","","Retrieves the number of addressable 512-octet sectors on…",71,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"read_dma","","Reads sectors from the disk.",71,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"write_dma","","Writes sectors to the disk.",71,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"dispatch","","Handle an incoming IPC request.",71,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"AhciInterface","","Main ahci interface.",null,null],[10,"discovered_disks_count","","Asks to the ahci service how many disks it has discovered.",72,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"get_disk","","Gets the interface to a disk.",72,[[["workqueue",3]],[["error",4],["idiskproxy",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",72,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"AhciInterfaceAsync","","Main ahci interface.",null,null],[10,"discovered_disks_count","","Asks to the ahci service how many disks it has discovered.",73,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_disk","","Gets the interface to a disk.",73,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",73,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",68,[[],[["error",4],["result",4]]]],[11,"sector_count","","Retrieves the number of addressable 512-octet sectors on…",68,[[],[["error",4],["result",4]]]],[11,"read_dma","","Reads sectors from the disk.",68,[[],[["result",4],["error",4]]]],[11,"write_dma","","Writes sectors to the disk.",68,[[],[["result",4],["error",4]]]],[11,"raw_new","","Creates a new [AhciInterfaceProxy] by connecting to the…",69,[[],[["error",4],["ahciinterfaceproxy",3],["result",4]]]],[11,"new","","Acquires the shared handle to the `ahci:` service -…",69,[[],[["ahciinterfaceproxy",3],["error",4],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",69,[[],[["error",4],["result",4]]]],[11,"discovered_disks_count","","Asks to the ahci service how many disks it has discovered.",69,[[],[["result",4],["error",4]]]],[11,"get_disk","","Gets the interface to a disk.",69,[[],[["error",4],["idiskproxy",3],["result",4]]]],[0,"time","sunrise_libuser","Auto-generated documentation",null,null],[3,"CalendarAdditionalInfo","sunrise_libuser::time","Represent aditional info of a local time",null,null],[12,"day_of_week","","The day of the week of the local time",74,null],[12,"day_of_year","","The day of the year of the local time",74,null],[12,"tz_name","","The name of the timezone of the local time",74,null],[12,"is_daylight_saving_time","","True if the local time represent a Day Saving Time",74,null],[12,"gmt_offset","","The GMT offset of the timezone used to generate this local…",74,null],[3,"CalendarTime","","Represent the basic informations of a local time.",null,null],[12,"year","","The year of the local time",75,null],[12,"month","","The month of the local time",75,null],[12,"day","","The day of the local time",75,null],[12,"hour","","The hour of the local time",75,null],[12,"minute","","The minute of the local time",75,null],[12,"second","","The second of the local time",75,null],[3,"TimeZoneServiceProxy","","TimeZone service object",null,null],[12,"0","","",76,null],[3,"RTCManagerProxy","","RTC interface",null,null],[12,"0","","",77,null],[3,"StaticServiceProxy","","Entry point interface",null,null],[12,"0","","",78,null],[6,"LocationName","","Represent a time zone location name",null,null],[6,"TimeZoneRule","","An opaque type that represent a time zone rule.",null,null],[6,"PosixTime","","Represent a POSIX Timestamp",null,null],[8,"TimeZoneService","","TimeZone service object",null,null],[10,"get_device_location_name","","Get the time zone name used on this devie",79,[[["workqueue",3]],[["error",4],["locationname",6],["result",4]]]],[10,"set_device_location_name","","Set the time zone name used on this devie",79,[[["locationname",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"get_total_location_name_count","","Get the total count of location name available",79,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"load_location_name_list","","Load the list of location name available",79,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"load_timezone_rule","","Load a time zone rule",79,[[["locationname",6],["timezonerule",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"to_calendar_time","","Convert a PosixTime to a local time using a TimeZoneRule",79,[[["posixtime",6],["timezonerule",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"to_calendar_time_with_my_rule","","Convert a PosixTime to a local time using the device…",79,[[["posixtime",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"to_posix_time","","Convert a local time to a PosixTime using a TimeZoneRule.",79,[[["timezonerule",6],["calendartime",3],["workqueue",3]],[["posixtime",6],["result",4],["error",4]]]],[10,"to_posix_time_with_my_rule","","Convert a local time to a PosixTime using the device…",79,[[["calendartime",3],["workqueue",3]],[["posixtime",6],["result",4],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",79,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"TimeZoneServiceAsync","","TimeZone service object",null,null],[10,"get_device_location_name","","Get the time zone name used on this devie",80,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"set_device_location_name","","Set the time zone name used on this devie",80,[[["locationname",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_total_location_name_count","","Get the total count of location name available",80,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"load_location_name_list","","Load the list of location name available",80,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"load_timezone_rule","","Load a time zone rule",80,[[["locationname",6],["timezonerule",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"to_calendar_time","","Convert a PosixTime to a local time using a TimeZoneRule",80,[[["posixtime",6],["timezonerule",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"to_calendar_time_with_my_rule","","Convert a PosixTime to a local time using the device…",80,[[["posixtime",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"to_posix_time","","Convert a local time to a PosixTime using a TimeZoneRule.",80,[[["timezonerule",6],["calendartime",3],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"to_posix_time_with_my_rule","","Convert a local time to a PosixTime using the device…",80,[[["calendartime",3],["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",80,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"RTCManager","","RTC interface",null,null],[10,"get_rtc_time","","Get the current RTC time",81,[[["workqueue",3]],[["posixtime",6],["result",4],["error",4]]]],[10,"get_rtc_event","","Event triggered on RTC time update",81,[[["workqueue",3]],[["error",4],["handleref",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",81,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"RTCManagerAsync","","RTC interface",null,null],[10,"get_rtc_time","","Get the current RTC time",82,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"get_rtc_event","","Event triggered on RTC time update",82,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",82,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"StaticService","","Entry point interface",null,null],[10,"get_timezone_service","","Get the TimeZone service object",83,[[["workqueue",3]],[["result",4],["timezoneserviceproxy",3],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",83,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"StaticServiceAsync","","Entry point interface",null,null],[10,"get_timezone_service","","Get the TimeZone service object",84,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"dispatch","","Handle an incoming IPC request.",84,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",76,[[],[["error",4],["result",4]]]],[11,"get_device_location_name","","Get the time zone name used on this devie",76,[[],[["error",4],["locationname",6],["result",4]]]],[11,"set_device_location_name","","Set the time zone name used on this devie",76,[[["locationname",6]],[["result",4],["error",4]]]],[11,"get_total_location_name_count","","Get the total count of location name available",76,[[],[["result",4],["error",4]]]],[11,"load_location_name_list","","Load the list of location name available",76,[[],[["result",4],["error",4]]]],[11,"load_timezone_rule","","Load a time zone rule",76,[[["locationname",6],["timezonerule",6]],[["result",4],["error",4]]]],[11,"to_calendar_time","","Convert a PosixTime to a local time using a TimeZoneRule",76,[[["posixtime",6],["timezonerule",6]],[["result",4],["error",4]]]],[11,"to_calendar_time_with_my_rule","","Convert a PosixTime to a local time using the device…",76,[[["posixtime",6]],[["result",4],["error",4]]]],[11,"to_posix_time","","Convert a local time to a PosixTime using a TimeZoneRule.",76,[[["timezonerule",6],["calendartime",3]],[["posixtime",6],["result",4],["error",4]]]],[11,"to_posix_time_with_my_rule","","Convert a local time to a PosixTime using the device…",76,[[["calendartime",3]],[["posixtime",6],["result",4],["error",4]]]],[11,"raw_new","","Creates a new [RTCManagerProxy] by connecting to the `rtc`…",77,[[],[["rtcmanagerproxy",3],["error",4],["result",4]]]],[11,"new","","Acquires the shared handle to the `rtc` service -…",77,[[],[["result",4],["rtcmanagerproxy",3],["error",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",77,[[],[["error",4],["result",4]]]],[11,"get_rtc_time","","Get the current RTC time",77,[[],[["posixtime",6],["result",4],["error",4]]]],[11,"get_rtc_event","","Event triggered on RTC time update",77,[[],[["error",4],["handle",3],["result",4]]]],[11,"raw_new_time_u","","Creates a new [StaticServiceProxy] by connecting to the…",78,[[],[["result",4],["staticserviceproxy",3],["error",4]]]],[11,"new_time_u","","Acquires the shared handle to the `time:u` service -…",78,[[],[["error",4],["staticserviceproxy",3],["result",4]]]],[11,"raw_new_time_a","","Creates a new [StaticServiceProxy] by connecting to the…",78,[[],[["result",4],["staticserviceproxy",3],["error",4]]]],[11,"new_time_a","","Acquires the shared handle to the `time:a` service -…",78,[[],[["error",4],["staticserviceproxy",3],["result",4]]]],[11,"raw_new_time_s","","Creates a new [StaticServiceProxy] by connecting to the…",78,[[],[["result",4],["staticserviceproxy",3],["error",4]]]],[11,"new_time_s","","Acquires the shared handle to the `time:s` service -…",78,[[],[["error",4],["staticserviceproxy",3],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",78,[[],[["error",4],["result",4]]]],[11,"get_timezone_service","","Get the TimeZone service object",78,[[],[["result",4],["timezoneserviceproxy",3],["error",4]]]],[0,"fs","sunrise_libuser","Auto-generated documentation",null,null],[3,"FileSystemType","sunrise_libuser::fs","Represent the type of a filesystem.",null,null],[12,"0","","",85,null],[3,"DirectoryEntry","","Represent an entry inside a directory.",null,null],[12,"path","","The path of the resource.",86,null],[12,"attribute","","The attribute of the resource. 1 = Archive bit is set…",86,null],[12,"directory_entry_type","","The type of the resource.",86,null],[12,"file_size","","The size of the file. (0 if it\'s a directory)",86,null],[3,"FileTimeStampRaw","","Represent the attached timestamps on a given resource.",null,null],[12,"creation_timestamp","","The resource creation UNIX timestamp.",87,null],[12,"modified_timestamp","","The resource last modification UNIX timestamp.",87,null],[12,"accessed_timestamp","","The resource last access UNIX timestamp.",87,null],[12,"is_valid","","false if one of the given timestamp couldn\'t have been…",87,null],[3,"DirectoryEntryType","","Represent the type of a given resource when walking a…",null,null],[12,"0","","",88,null],[3,"IFileProxy","","Represent a file in a filesystem.",null,null],[12,"0","","",89,null],[3,"IDirectoryProxy","","Represent a directory in a filesystem.",null,null],[12,"0","","",90,null],[3,"IStorageProxy","","This is the interface for a raw device, usually a block…",null,null],[12,"0","","",91,null],[3,"IFileSystemProxy","","Represent a filesystem.",null,null],[12,"0","","",92,null],[3,"IFileSystemServiceProxy","","Entry point of the file system interface.",null,null],[12,"0","","",93,null],[6,"FileSystemPath","","Represent a path in a filesystem.",null,null],[6,"PartitionId","","A partition unique identifier on a disk.",null,null],[6,"DiskId","","A disk unique identifier.",null,null],[8,"IFile","","Represent a file in a filesystem.",null,null],[10,"read","","Read the content of a file at a given `offset` in…",94,[[["workqueue",3]],[["error",4],["result",4]]]],[10,"write","","Write the content given `in_buf` at the given `offset` in…",94,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"flush","","Flush any data not written on the filesystem.",94,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"set_size","","Resize the file with the given `size`. If the file isn\'t…",94,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"get_size","","Return the current file size.",94,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",94,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IFileAsync","","Represent a file in a filesystem.",null,null],[10,"read","","Read the content of a file at a given `offset` in…",95,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"write","","Write the content given `in_buf` at the given `offset` in…",95,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"flush","","Flush any data not written on the filesystem.",95,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"set_size","","Resize the file with the given `size`. If the file isn\'t…",95,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_size","","Return the current file size.",95,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",95,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IDirectory","","Represent a directory in a filesystem.",null,null],[10,"read","","Read the next directory entries and return the number of…",96,[[["workqueue",3]],[["error",4],["result",4]]]],[10,"get_entry_count","","Return the count of entries in the directory.",96,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",96,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IDirectoryAsync","","Represent a directory in a filesystem.",null,null],[10,"read","","Read the next directory entries and return the number of…",97,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"get_entry_count","","Return the count of entries in the directory.",97,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",97,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IStorage","","This is the interface for a raw device, usually a block…",null,null],[10,"read","","Read the content of a storage at a given `offset` in…",98,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"write","","Write the content given `in_buf` at the given `offset` in…",98,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"flush","","Flush any data not written on the storage.",98,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"set_size","","Resize the storage with the given `size`.",98,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"get_size","","Return the current storage size.",98,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",98,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IStorageAsync","","This is the interface for a raw device, usually a block…",null,null],[10,"read","","Read the content of a storage at a given `offset` in…",99,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"write","","Write the content given `in_buf` at the given `offset` in…",99,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"flush","","Flush any data not written on the storage.",99,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"set_size","","Resize the storage with the given `size`.",99,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_size","","Return the current storage size.",99,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",99,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IFileSystem","","Represent a filesystem.",null,null],[10,"create_file","","Create a file with a given `size` at the specified `path`.",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"delete_file","","Delete a file at the specified `path`.",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"create_directory","","Create a directory at the specified `path`.",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"delete_directory","","Delete a directory at the specified `path`.",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"rename_file","","Rename a file at `old_path` into `new_path`.",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"rename_directory","","Rename a directory at `old_path` into `new_path`",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["error",4]]]],[10,"get_entry_type","","Get the informations about an entry on the filesystem.",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["directoryentrytype",3],["error",4]]]],[10,"open_file","","Open a file at the specified `path` with the given `mode`…",100,[[["filesystempath",6],["workqueue",3]],[["ifileproxy",3],["result",4],["error",4]]]],[10,"open_file_as_ipipe","","Open a file at the specified `path` with the given `mode`…",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["ipipeproxy",3],["error",4]]]],[10,"open_directory","","Open a directory at the specified `path` with the given…",100,[[["filesystempath",6],["workqueue",3]],[["error",4],["result",4],["idirectoryproxy",3]]]],[10,"get_free_space_size","","Get the total availaible space on the given filesystem.",100,[[["filesystempath",6],["workqueue",3]],[["error",4],["result",4]]]],[10,"get_total_space_size","","Get the total size of the filesystem.",100,[[["filesystempath",6],["workqueue",3]],[["error",4],["result",4]]]],[10,"get_file_timestamp_raw","","Return the attached timestamps on a resource at the given…",100,[[["filesystempath",6],["workqueue",3]],[["result",4],["filetimestampraw",3],["error",4]]]],[10,"get_filesystem_type","","Get the type of this filesystem.",100,[[["workqueue",3]],[["error",4],["result",4],["filesystemtype",3]]]],[11,"dispatch","","Handle an incoming IPC request.",100,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IFileSystemAsync","","Represent a filesystem.",null,null],[10,"create_file","","Create a file with a given `size` at the specified `path`.",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"delete_file","","Delete a file at the specified `path`.",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"create_directory","","Create a directory at the specified `path`.",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"delete_directory","","Delete a directory at the specified `path`.",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"rename_file","","Rename a file at `old_path` into `new_path`.",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"rename_directory","","Rename a directory at `old_path` into `new_path`",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_entry_type","","Get the informations about an entry on the filesystem.",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"open_file","","Open a file at the specified `path` with the given `mode`…",101,[[["filesystempath",6],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"open_file_as_ipipe","","Open a file at the specified `path` with the given `mode`…",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"open_directory","","Open a directory at the specified `path` with the given…",101,[[["filesystempath",6],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"get_free_space_size","","Get the total availaible space on the given filesystem.",101,[[["filesystempath",6],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"get_total_space_size","","Get the total size of the filesystem.",101,[[["filesystempath",6],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"get_file_timestamp_raw","","Return the attached timestamps on a resource at the given…",101,[[["filesystempath",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_filesystem_type","","Get the type of this filesystem.",101,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"dispatch","","Handle an incoming IPC request.",101,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IFileSystemService","","Entry point of the file system interface.",null,null],[10,"open_disk_partition","","Open a disk partition filesystem. This may fail if no…",102,[[["diskid",6],["partitionid",6],["workqueue",3]],[["result",4],["ifilesystemproxy",3],["error",4]]]],[10,"open_disk_storage","","Open a disk as a block device. This may fail if no…",102,[[["diskid",6],["workqueue",3]],[["istorageproxy",3],["result",4],["error",4]]]],[10,"get_disks_count","","Get the count of disks availaible.",102,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"format_disk_partition","","Format a disk partition to the given filesystem type.",102,[[["diskid",6],["workqueue",3],["partitionid",6],["filesystemtype",3]],[["result",4],["error",4]]]],[10,"initialize_disk","","Initialize a disk partition table",102,[[["diskid",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",102,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IFileSystemServiceAsync","","Entry point of the file system interface.",null,null],[10,"open_disk_partition","","Open a disk partition filesystem. This may fail if no…",103,[[["diskid",6],["partitionid",6],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"open_disk_storage","","Open a disk as a block device. This may fail if no…",103,[[["diskid",6],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"get_disks_count","","Get the count of disks availaible.",103,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"format_disk_partition","","Format a disk partition to the given filesystem type.",103,[[["diskid",6],["workqueue",3],["partitionid",6],["filesystemtype",3]],[["result",4],["futureobj",3]]]],[10,"initialize_disk","","Initialize a disk partition table",103,[[["diskid",6],["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"dispatch","","Handle an incoming IPC request.",103,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[18,"FAT12","","Represent a FAT12 fileystem.",85,null],[18,"FAT16","","Represent a FAT16 fileystem.",85,null],[18,"FAT32","","Represent a FAT32 fileystem.",85,null],[18,"PackageFileSubmission","","Represent a PFS0.",85,null],[18,"Directory","","The entry is a file.",88,null],[18,"File","","The entry is a directory.",88,null],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",89,[[],[["error",4],["result",4]]]],[11,"read","","Read the content of a file at a given `offset` in…",89,[[],[["error",4],["result",4]]]],[11,"write","","Write the content given `in_buf` at the given `offset` in…",89,[[],[["result",4],["error",4]]]],[11,"flush","","Flush any data not written on the filesystem.",89,[[],[["result",4],["error",4]]]],[11,"set_size","","Resize the file with the given `size`. If the file isn\'t…",89,[[],[["result",4],["error",4]]]],[11,"get_size","","Return the current file size.",89,[[],[["error",4],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",90,[[],[["error",4],["result",4]]]],[11,"read","","Read the next directory entries and return the number of…",90,[[],[["error",4],["result",4]]]],[11,"get_entry_count","","Return the count of entries in the directory.",90,[[],[["error",4],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",91,[[],[["error",4],["result",4]]]],[11,"read","","Read the content of a storage at a given `offset` in…",91,[[],[["result",4],["error",4]]]],[11,"write","","Write the content given `in_buf` at the given `offset` in…",91,[[],[["result",4],["error",4]]]],[11,"flush","","Flush any data not written on the storage.",91,[[],[["result",4],["error",4]]]],[11,"set_size","","Resize the storage with the given `size`.",91,[[],[["result",4],["error",4]]]],[11,"get_size","","Return the current storage size.",91,[[],[["error",4],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",92,[[],[["error",4],["result",4]]]],[11,"create_file","","Create a file with a given `size` at the specified `path`.",92,[[["filesystempath",6]],[["result",4],["error",4]]]],[11,"delete_file","","Delete a file at the specified `path`.",92,[[["filesystempath",6]],[["result",4],["error",4]]]],[11,"create_directory","","Create a directory at the specified `path`.",92,[[["filesystempath",6]],[["result",4],["error",4]]]],[11,"delete_directory","","Delete a directory at the specified `path`.",92,[[["filesystempath",6]],[["result",4],["error",4]]]],[11,"rename_file","","Rename a file at `old_path` into `new_path`.",92,[[["filesystempath",6]],[["result",4],["error",4]]]],[11,"rename_directory","","Rename a directory at `old_path` into `new_path`",92,[[["filesystempath",6]],[["result",4],["error",4]]]],[11,"get_entry_type","","Get the informations about an entry on the filesystem.",92,[[["filesystempath",6]],[["result",4],["directoryentrytype",3],["error",4]]]],[11,"open_file","","Open a file at the specified `path` with the given `mode`…",92,[[["filesystempath",6]],[["ifileproxy",3],["result",4],["error",4]]]],[11,"open_file_as_ipipe","","Open a file at the specified `path` with the given `mode`…",92,[[["filesystempath",6]],[["result",4],["ipipeproxy",3],["error",4]]]],[11,"open_directory","","Open a directory at the specified `path` with the given…",92,[[["filesystempath",6]],[["error",4],["result",4],["idirectoryproxy",3]]]],[11,"get_free_space_size","","Get the total availaible space on the given filesystem.",92,[[["filesystempath",6]],[["error",4],["result",4]]]],[11,"get_total_space_size","","Get the total size of the filesystem.",92,[[["filesystempath",6]],[["error",4],["result",4]]]],[11,"get_file_timestamp_raw","","Return the attached timestamps on a resource at the given…",92,[[["filesystempath",6]],[["result",4],["filetimestampraw",3],["error",4]]]],[11,"get_filesystem_type","","Get the type of this filesystem.",92,[[],[["error",4],["result",4],["filesystemtype",3]]]],[11,"raw_new","","Creates a new [IFileSystemServiceProxy] by connecting to…",93,[[],[["result",4],["error",4],["ifilesystemserviceproxy",3]]]],[11,"new","","Acquires the shared handle to the `fsp-srv` service -…",93,[[],[["result",4],["ifilesystemserviceproxy",3],["error",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",93,[[],[["error",4],["result",4]]]],[11,"open_disk_partition","","Open a disk partition filesystem. This may fail if no…",93,[[["diskid",6],["partitionid",6]],[["result",4],["ifilesystemproxy",3],["error",4]]]],[11,"open_disk_storage","","Open a disk as a block device. This may fail if no…",93,[[["diskid",6]],[["istorageproxy",3],["result",4],["error",4]]]],[11,"get_disks_count","","Get the count of disks availaible.",93,[[],[["result",4],["error",4]]]],[11,"format_disk_partition","","Format a disk partition to the given filesystem type.",93,[[["diskid",6],["partitionid",6],["filesystemtype",3]],[["result",4],["error",4]]]],[11,"initialize_disk","","Initialize a disk partition table",93,[[["diskid",6]],[["result",4],["error",4]]]],[0,"keyboard","sunrise_libuser","Auto-generated documentation",null,null],[3,"HidKeyboardStateType","sunrise_libuser::keyboard","Define the type of the data contained in HidKeyboardState.",null,null],[12,"0","","",104,null],[3,"HidKeyboardScancode","","Autogenerated enum representing the HID keyboard scancode.",null,null],[12,"0","","",105,null],[3,"HidKeyboardState","","Define the state returned by read_keyboard_state.",null,null],[12,"data","","A key or a scancode",106,null],[12,"additional_data","","Additional data used for upper key when…",106,null],[12,"state_type","","The type of the data before.",106,null],[12,"modifiers","","Keyboard modifiers",106,null],[3,"StaticServiceProxy","","Keyboard interface",null,null],[12,"0","","",107,null],[8,"StaticService","","Keyboard interface",null,null],[10,"get_keyboard_event","","Get an handle to an event triggered on keyboard update.",108,[[["workqueue",3]],[["error",4],["handleref",3],["result",4]]]],[10,"read_keyboard_states","","Read the x last pressed keys into the given buffer. A size…",108,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",108,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"StaticServiceAsync","","Keyboard interface",null,null],[10,"get_keyboard_event","","Get an handle to an event triggered on keyboard update.",109,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"read_keyboard_states","","Read the x last pressed keys into the given buffer. A size…",109,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",109,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[18,"Scancode","","This entry is a scancode, the field data contains a…",104,null],[18,"Ascii","","This entry is an ascii char, the field data contains an…",104,null],[18,"Control","","This entry is an old PS2 control key that cannot be mapped…",104,null],[18,"Unknown","","This entry is unknown.",104,null],[18,"None","","The None key (scancode: 0x00)",105,null],[18,"ErrOvf","","The ErrOvf key (scancode: 0x01)",105,null],[18,"A","","The A key (scancode: 0x04)",105,null],[18,"B","","The B key (scancode: 0x05)",105,null],[18,"C","","The C key (scancode: 0x06)",105,null],[18,"D","","The D key (scancode: 0x07)",105,null],[18,"E","","The E key (scancode: 0x08)",105,null],[18,"F","","The F key (scancode: 0x09)",105,null],[18,"G","","The G key (scancode: 0x0a)",105,null],[18,"H","","The H key (scancode: 0x0b)",105,null],[18,"I","","The I key (scancode: 0x0c)",105,null],[18,"J","","The J key (scancode: 0x0d)",105,null],[18,"K","","The K key (scancode: 0x0e)",105,null],[18,"L","","The L key (scancode: 0x0f)",105,null],[18,"M","","The M key (scancode: 0x10)",105,null],[18,"N","","The N key (scancode: 0x11)",105,null],[18,"O","","The O key (scancode: 0x12)",105,null],[18,"P","","The P key (scancode: 0x13)",105,null],[18,"Q","","The Q key (scancode: 0x14)",105,null],[18,"R","","The R key (scancode: 0x15)",105,null],[18,"S","","The S key (scancode: 0x16)",105,null],[18,"T","","The T key (scancode: 0x17)",105,null],[18,"U","","The U key (scancode: 0x18)",105,null],[18,"V","","The V key (scancode: 0x19)",105,null],[18,"W","","The W key (scancode: 0x1a)",105,null],[18,"X","","The X key (scancode: 0x1b)",105,null],[18,"Y","","The Y key (scancode: 0x1c)",105,null],[18,"Z","","The Z key (scancode: 0x1d)",105,null],[18,"Number1","","The Number1 key (scancode: 0x1e)",105,null],[18,"Number2","","The Number2 key (scancode: 0x1f)",105,null],[18,"Number3","","The Number3 key (scancode: 0x20)",105,null],[18,"Number4","","The Number4 key (scancode: 0x21)",105,null],[18,"Number5","","The Number5 key (scancode: 0x22)",105,null],[18,"Number6","","The Number6 key (scancode: 0x23)",105,null],[18,"Number7","","The Number7 key (scancode: 0x24)",105,null],[18,"Number8","","The Number8 key (scancode: 0x25)",105,null],[18,"Number9","","The Number9 key (scancode: 0x26)",105,null],[18,"Number0","","The Number0 key (scancode: 0x27)",105,null],[18,"Enter","","The Enter key (scancode: 0x28)",105,null],[18,"Esc","","The Esc key (scancode: 0x29)",105,null],[18,"Backspace","","The Backspace key (scancode: 0x2a)",105,null],[18,"Tab","","The Tab key (scancode: 0x2b)",105,null],[18,"Space","","The Space key (scancode: 0x2c)",105,null],[18,"Minus","","The Minus key (scancode: 0x2d)",105,null],[18,"Equal","","The Equal key (scancode: 0x2e)",105,null],[18,"Leftbrace","","The Leftbrace key (scancode: 0x2f)",105,null],[18,"Rightbrace","","The Rightbrace key (scancode: 0x30)",105,null],[18,"Backslash","","The Backslash key (scancode: 0x31)",105,null],[18,"Hashtilde","","The Hashtilde key (scancode: 0x32)",105,null],[18,"Semicolon","","The Semicolon key (scancode: 0x33)",105,null],[18,"Apostrophe","","The Apostrophe key (scancode: 0x34)",105,null],[18,"Grave","","The Grave key (scancode: 0x35)",105,null],[18,"Comma","","The Comma key (scancode: 0x36)",105,null],[18,"Dot","","The Dot key (scancode: 0x37)",105,null],[18,"Slash","","The Slash key (scancode: 0x38)",105,null],[18,"CapsLock","","The CapsLock key (scancode: 0x39)",105,null],[18,"F1","","The F1 key (scancode: 0x3a)",105,null],[18,"F2","","The F2 key (scancode: 0x3b)",105,null],[18,"F3","","The F3 key (scancode: 0x3c)",105,null],[18,"F4","","The F4 key (scancode: 0x3d)",105,null],[18,"F5","","The F5 key (scancode: 0x3e)",105,null],[18,"F6","","The F6 key (scancode: 0x3f)",105,null],[18,"F7","","The F7 key (scancode: 0x40)",105,null],[18,"F8","","The F8 key (scancode: 0x41)",105,null],[18,"F9","","The F9 key (scancode: 0x42)",105,null],[18,"F10","","The F10 key (scancode: 0x43)",105,null],[18,"F11","","The F11 key (scancode: 0x44)",105,null],[18,"F12","","The F12 key (scancode: 0x45)",105,null],[18,"SysRQ","","The SysRQ key (scancode: 0x46)",105,null],[18,"ScrollLock","","The ScrollLock key (scancode: 0x47)",105,null],[18,"Pause","","The Pause key (scancode: 0x48)",105,null],[18,"Insert","","The Insert key (scancode: 0x49)",105,null],[18,"Home","","The Home key (scancode: 0x4a)",105,null],[18,"PageUp","","The PageUp key (scancode: 0x4b)",105,null],[18,"Delete","","The Delete key (scancode: 0x4c)",105,null],[18,"End","","The End key (scancode: 0x4d)",105,null],[18,"PageDown","","The PageDown key (scancode: 0x4e)",105,null],[18,"Right","","The Right key (scancode: 0x4f)",105,null],[18,"Left","","The Left key (scancode: 0x50)",105,null],[18,"Down","","The Down key (scancode: 0x51)",105,null],[18,"Up","","The Up key (scancode: 0x52)",105,null],[18,"NumLock","","The Numlock key (scancode: 0x53)",105,null],[18,"Kpslash","","The Kpslash key (scancode: 0x54)",105,null],[18,"Kpasterisk","","The Kpasterisk key (scancode: 0x55)",105,null],[18,"Kpminus","","The Kpminus key (scancode: 0x56)",105,null],[18,"Kpplus","","The Kpplus key (scancode: 0x57)",105,null],[18,"Kpenter","","The Kpenter key (scancode: 0x58)",105,null],[18,"Kp1","","The Kp1 key (scancode: 0x59)",105,null],[18,"Kp2","","The Kp2 key (scancode: 0x5a)",105,null],[18,"Kp3","","The Kp3 key (scancode: 0x5b)",105,null],[18,"Kp4","","The Kp4 key (scancode: 0x5c)",105,null],[18,"Kp5","","The Kp5 key (scancode: 0x5d)",105,null],[18,"Kp6","","The Kp6 key (scancode: 0x5e)",105,null],[18,"Kp7","","The Kp7 key (scancode: 0x5f)",105,null],[18,"Kp8","","The Kp8 key (scancode: 0x60)",105,null],[18,"Kp9","","The Kp9 key (scancode: 0x61)",105,null],[18,"Kp0","","The Kp0 key (scancode: 0x62)",105,null],[18,"Kpdot","","The Kpdot key (scancode: 0x63)",105,null],[18,"Key102nd","","The 102nd key (scancode: 0x64)",105,null],[18,"Compose","","The Compose key (scancode: 0x65)",105,null],[18,"Power","","The Power key (scancode: 0x66)",105,null],[18,"Kpequal","","The Kpequal key (scancode: 0x67)",105,null],[18,"F13","","The F13 key (scancode: 0x68)",105,null],[18,"F14","","The F14 key (scancode: 0x69)",105,null],[18,"F15","","The F15 key (scancode: 0x6a)",105,null],[18,"F16","","The F16 key (scancode: 0x6b)",105,null],[18,"F17","","The F17 key (scancode: 0x6c)",105,null],[18,"F18","","The F18 key (scancode: 0x6d)",105,null],[18,"F19","","The F19 key (scancode: 0x6e)",105,null],[18,"F20","","The F20 key (scancode: 0x6f)",105,null],[18,"F21","","The F21 key (scancode: 0x70)",105,null],[18,"F22","","The F22 key (scancode: 0x71)",105,null],[18,"F23","","The F23 key (scancode: 0x72)",105,null],[18,"F24","","The F24 key (scancode: 0x73)",105,null],[18,"Open","","The Open key (scancode: 0x74)",105,null],[18,"Help","","The Help key (scancode: 0x75)",105,null],[18,"Props","","The Props key (scancode: 0x76)",105,null],[18,"Front","","The Front key (scancode: 0x77)",105,null],[18,"Stop","","The Stop key (scancode: 0x78)",105,null],[18,"Again","","The Again key (scancode: 0x79)",105,null],[18,"Undo","","The Undo key (scancode: 0x7a)",105,null],[18,"Cut","","The Cut key (scancode: 0x7b)",105,null],[18,"Copy","","The Copy key (scancode: 0x7c)",105,null],[18,"Paste","","The Paste key (scancode: 0x7d)",105,null],[18,"Find","","The Find key (scancode: 0x7e)",105,null],[18,"Mute","","The Mute key (scancode: 0x7f)",105,null],[18,"VolumeUp","","The Volumeup key (scancode: 0x80)",105,null],[18,"VolumeDown","","The Volumedown key (scancode: 0x81)",105,null],[18,"CapsLockActive","","The CapsLockActive key (scancode: 0x82 )",105,null],[18,"NumLockActive","","The NumLockActive key (scancode: 0x83 )",105,null],[18,"ScrollLockActive","","The ScrollLockActive key (scancode: 0x84 )",105,null],[18,"KPcomma","","The Kpcomma key (scancode: 0x85)",105,null],[18,"KPleftParen","","The Kpleftparen key (scancode: 0xb6)",105,null],[18,"KPrightParen","","The Kprightparen key (scancode: 0xb7)",105,null],[18,"LeftCtrl","","The LeftCtrl key (scancode: 0xe0)",105,null],[18,"LeftShift","","The LeftShift key (scancode: 0xe1)",105,null],[18,"LeftAlt","","The LeftQlt key (scancode: 0xe2)",105,null],[18,"LeftMeta","","The LeftMeta key (scancode: 0xe3)",105,null],[18,"RightCtrl","","The RightCtrl key (scancode: 0xe4)",105,null],[18,"RightShift","","The RightShift key (scancode: 0xe5)",105,null],[18,"RightAlt","","The RightAlt key (scancode: 0xe6)",105,null],[18,"RightMeta","","The RightMeta key (scancode: 0xe7)",105,null],[18,"MediaPlayPause","","The MediaPlayPause key (scancode: 0xe8)",105,null],[18,"MediaStopCd","","The MediaStopCd key (scancode: 0xe9)",105,null],[18,"MediaPreviousSong","","The MediaPreviousSong key (scancode: 0xea)",105,null],[18,"MediaNextSong","","The MediaNextSong key (scancode: 0xeb)",105,null],[18,"MediaEjectCd","","The MediaEjectCd key (scancode: 0xec)",105,null],[18,"MediaVolumeUp","","The MediaVolumeUp key (scancode: 0xed)",105,null],[18,"MediaVolumeDown","","The MediaVolumeDown key (scancode: 0xee)",105,null],[18,"MediaMute","","The MediaMute key (scancode: 0xef)",105,null],[18,"MediaWWW","","The MediaWWW key (scancode: 0xf0)",105,null],[18,"MediaBack","","The MediaBack key (scancode: 0xf1)",105,null],[18,"MediaForward","","The MediaForward key (scancode: 0xf2)",105,null],[18,"MediaStop","","The MediaStop key (scancode: 0xf3)",105,null],[18,"MediaFind","","The MediaFind key (scancode: 0xf4)",105,null],[18,"MediaScrollUp","","The MediaScrollUp key (scancode: 0xf5)",105,null],[18,"MediaScrollDown","","The MediaScrollDown key (scancode: 0xf6)",105,null],[18,"MediaEdit","","The MediaEdit key (scancode: 0xf7)",105,null],[18,"MediaSleep","","The MediaSleep key (scancode: 0xf8)",105,null],[18,"MediaCoffee","","The MediaCoffee key (scancode: 0xf9)",105,null],[18,"MediaRefresh","","The MediaRefresh key (scancode: 0xfa)",105,null],[18,"MediaCalc","","The MediaCalc key (scancode: 0xfb)",105,null],[11,"raw_new","","Creates a new [StaticServiceProxy] by connecting to the…",107,[[],[["result",4],["staticserviceproxy",3],["error",4]]]],[11,"new","","Acquires the shared handle to the `kbrd:u` service -…",107,[[],[["result",4],["staticserviceproxy",3],["error",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",107,[[],[["error",4],["result",4]]]],[11,"get_keyboard_event","","Get an handle to an event triggered on keyboard update.",107,[[],[["error",4],["handle",3],["result",4]]]],[11,"read_keyboard_states","","Read the x last pressed keys into the given buffer. A size…",107,[[],[["error",4],["result",4]]]],[0,"ldr","sunrise_libuser","Auto-generated documentation",null,null],[3,"ILoaderInterfaceProxy","sunrise_libuser::ldr","A mishmash of Nintendo\'s loader and pm in a single…",null,null],[12,"0","","",110,null],[8,"ILoaderInterface","","A mishmash of Nintendo\'s loader and pm in a single…",null,null],[10,"create_title","","Create and load the process `title_name` with the given…",111,[[["workqueue",3]],[["error",4],["result",4]]]],[10,"launch_title","","Starts a process created with create_title.",111,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"wait","","Wait for the process with the given pid, returning the…",111,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"get_name","","Get process name.",111,[[["workqueue",3]],[["error",4],["result",4]]]],[10,"kill","","Wait for the process with the given pid, returning the…",111,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"get_state","","Gets the state of the provided pid",111,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"get_process_state_changed_event","","Get an event that gets signaled whenever a process changes…",111,[[["workqueue",3]],[["error",4],["handleref",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",111,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"ILoaderInterfaceAsync","","A mishmash of Nintendo\'s loader and pm in a single…",null,null],[10,"create_title","","Create and load the process `title_name` with the given…",112,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"launch_title","","Starts a process created with create_title.",112,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"wait","","Wait for the process with the given pid, returning the…",112,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_name","","Get process name.",112,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"kill","","Wait for the process with the given pid, returning the…",112,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_state","","Gets the state of the provided pid",112,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"get_process_state_changed_event","","Get an event that gets signaled whenever a process changes…",112,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",112,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"raw_new","","Creates a new [ILoaderInterfaceProxy] by connecting to the…",110,[[],[["error",4],["result",4],["iloaderinterfaceproxy",3]]]],[11,"new","","Acquires the shared handle to the `ldr:shel` service -…",110,[[],[["error",4],["iloaderinterfaceproxy",3],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",110,[[],[["error",4],["result",4]]]],[11,"create_title","","Create and load the process `title_name` with the given…",110,[[],[["error",4],["result",4]]]],[11,"launch_title","","Starts a process created with create_title.",110,[[],[["result",4],["error",4]]]],[11,"wait","","Wait for the process with the given pid, returning the…",110,[[],[["result",4],["error",4]]]],[11,"get_name","","Get process name.",110,[[],[["error",4],["result",4]]]],[11,"kill","","Wait for the process with the given pid, returning the…",110,[[],[["result",4],["error",4]]]],[11,"get_state","","Gets the state of the provided pid",110,[[],[["result",4],["error",4]]]],[11,"get_process_state_changed_event","","Get an event that gets signaled whenever a process changes…",110,[[],[["result",4],["readableevent",3],["error",4]]]],[0,"twili","sunrise_libuser","Auto-generated documentation",null,null],[3,"IPipeProxy","sunrise_libuser::twili","IPC Pipe Object",null,null],[12,"0","","",113,null],[3,"ITwiliServiceProxy","","The Twili Service is responsible for providing the…",null,null],[12,"0","","",114,null],[3,"ITwiliManagerServiceProxy","","The Twili Manager is responsible for registering a…",null,null],[12,"0","","",115,null],[8,"IPipe","","IPC Pipe Object",null,null],[10,"read","","Reads data from the pipe.",116,[[["workqueue",3]],[["error",4],["result",4]]]],[10,"write","","Writes data to the other side of the pipe.",116,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",116,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IPipeAsync","","IPC Pipe Object",null,null],[10,"read","","Reads data from the pipe.",117,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"write","","Writes data to the other side of the pipe.",117,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"dispatch","","Handle an incoming IPC request.",117,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"ITwiliService","","The Twili Service is responsible for providing the…",null,null],[10,"open_pipes","","Recover the stdin/stdout/stderr pipes for the current…",118,[[["pid",3],["workqueue",3]],[["result",4],["error",4]]]],[10,"create_pipe","","Creates a pipe whose write gets buffered and returned to…",118,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",118,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"ITwiliServiceAsync","","The Twili Service is responsible for providing the…",null,null],[10,"open_pipes","","Recover the stdin/stdout/stderr pipes for the current…",119,[[["pid",3],["workqueue",3]],[["futureobj",3],["result",4]]]],[10,"create_pipe","","Creates a pipe whose write gets buffered and returned to…",119,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",119,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"ITwiliManagerService","","The Twili Manager is responsible for registering a…",null,null],[10,"register_pipes","","Registers the pipe of a remote process.",120,[[["ipipeproxy",3],["workqueue",3]],[["result",4],["error",4]]]],[10,"create_pipe","","Creates a pipe whose write gets buffered and returned to…",120,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"dispatch","","Handle an incoming IPC request.",120,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"ITwiliManagerServiceAsync","","The Twili Manager is responsible for registering a…",null,null],[10,"register_pipes","","Registers the pipe of a remote process.",121,[[["ipipeproxy",3],["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"create_pipe","","Creates a pipe whose write gets buffered and returned to…",121,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",121,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",113,[[],[["error",4],["result",4]]]],[11,"read","","Reads data from the pipe.",113,[[],[["error",4],["result",4]]]],[11,"write","","Writes data to the other side of the pipe.",113,[[],[["result",4],["error",4]]]],[11,"raw_new","","Creates a new [ITwiliServiceProxy] by connecting to the…",114,[[],[["result",4],["error",4],["itwiliserviceproxy",3]]]],[11,"new","","Acquires the shared handle to the `twili` service -…",114,[[],[["error",4],["result",4],["itwiliserviceproxy",3]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",114,[[],[["error",4],["result",4]]]],[11,"open_pipes","","Recover the stdin/stdout/stderr pipes for the current…",114,[[],[["result",4],["error",4]]]],[11,"create_pipe","","Creates a pipe whose write gets buffered and returned to…",114,[[],[["result",4],["error",4]]]],[11,"raw_new","","Creates a new [ITwiliManagerServiceProxy] by connecting to…",115,[[],[["error",4],["result",4],["itwilimanagerserviceproxy",3]]]],[11,"new","","Acquires the shared handle to the `twili:m` service -…",115,[[],[["error",4],["result",4],["itwilimanagerserviceproxy",3]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",115,[[],[["error",4],["result",4]]]],[11,"register_pipes","","Registers the pipe of a remote process.",115,[[["ipipeproxy",3]],[["result",4],["error",4]]]],[11,"create_pipe","","Creates a pipe whose write gets buffered and returned to…",115,[[],[["result",4],["error",4]]]],[0,"example","sunrise_libuser","Auto-generated documentation",null,null],[3,"IExample4Proxy","sunrise_libuser::example","There are two more kinds of types that are important:…",null,null],[12,"0","","",122,null],[3,"IExample3SubsessionProxy","","An instance of this interface cannot be acquired by asking…",null,null],[12,"0","","",123,null],[3,"IExample2Proxy","","Let\'s make things a bit more interesting by adding a…",null,null],[12,"0","","",124,null],[3,"IExample3Proxy","","Interfaces can also return other interfaces. We call an…",null,null],[12,"0","","",125,null],[3,"IExample1Proxy","","Here\'s a simple example of an interface. This is a service…",null,null],[12,"0","","",126,null],[8,"IExample4","","There are two more kinds of types that are important:…",null,null],[10,"function","","Here\'s a simple function taking a buffer as an argument…",127,[[["workqueue",3]],[["error",4],["sharedmemory",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",127,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample4Async","","There are two more kinds of types that are important:…",null,null],[10,"function","","Here\'s a simple function taking a buffer as an argument…",128,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",128,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample3Subsession","","An instance of this interface cannot be acquired by asking…",null,null],[11,"dispatch","","Handle an incoming IPC request.",129,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample3SubsessionAsync","","An instance of this interface cannot be acquired by asking…",null,null],[11,"dispatch","","Handle an incoming IPC request.",130,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample2","","Let\'s make things a bit more interesting by adding a…",null,null],[10,"function","","This is the most simple kind of function: It takes no…",131,[[["workqueue",3]],[["result",4],["error",4]]]],[10,"function2","","Here\'s a more complex function. This function takes two…",131,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",131,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample2Async","","Let\'s make things a bit more interesting by adding a…",null,null],[10,"function","","This is the most simple kind of function: It takes no…",132,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[10,"function2","","Here\'s a more complex function. This function takes two…",132,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",132,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample3","","Interfaces can also return other interfaces. We call an…",null,null],[10,"function","","The type of an instance of an interface is…",133,[[["workqueue",3]],[["error",4],["result",4],["iexample3subsessionproxy",3]]]],[11,"dispatch","","Handle an incoming IPC request.",133,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample3Async","","Interfaces can also return other interfaces. We call an…",null,null],[10,"function","","The type of an instance of an interface is…",134,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"dispatch","","Handle an incoming IPC request.",134,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample1","","Here\'s a simple example of an interface. This is a service…",null,null],[11,"dispatch","","Handle an incoming IPC request.",135,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[8,"IExample1Async","","Here\'s a simple example of an interface. This is a service…",null,null],[11,"dispatch","","Handle an incoming IPC request.",136,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"raw_new","","Creates a new [IExample4Proxy] by connecting to the…",122,[[],[["iexample4proxy",3],["result",4],["error",4]]]],[11,"new","","Acquires the shared handle to the `hello:4` service -…",122,[[],[["result",4],["iexample4proxy",3],["error",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",122,[[],[["error",4],["result",4]]]],[11,"function","","Here\'s a simple function taking a buffer as an argument…",122,[[],[["error",4],["sharedmemory",3],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",123,[[],[["error",4],["result",4]]]],[11,"raw_new","","Creates a new [IExample2Proxy] by connecting to the…",124,[[],[["error",4],["result",4],["iexample2proxy",3]]]],[11,"new","","Acquires the shared handle to the `hello:2` service -…",124,[[],[["error",4],["result",4],["iexample2proxy",3]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",124,[[],[["error",4],["result",4]]]],[11,"function","","This is the most simple kind of function: It takes no…",124,[[],[["result",4],["error",4]]]],[11,"function2","","Here\'s a more complex function. This function takes two…",124,[[],[["error",4],["result",4]]]],[11,"raw_new","","Creates a new [IExample3Proxy] by connecting to the…",125,[[],[["error",4],["result",4],["iexample3proxy",3]]]],[11,"new","","Acquires the shared handle to the `hello:3` service -…",125,[[],[["error",4],["iexample3proxy",3],["result",4]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",125,[[],[["error",4],["result",4]]]],[11,"function","","The type of an instance of an interface is…",125,[[],[["error",4],["result",4],["iexample3subsessionproxy",3]]]],[11,"raw_new","","Creates a new [IExample1Proxy] by connecting to the…",126,[[],[["result",4],["error",4],["iexample1proxy",3]]]],[11,"new","","Acquires the shared handle to the `hello:1` service -…",126,[[],[["error",4],["result",4],["iexample1proxy",3]]]],[11,"clone_current_object","","Clones the current object, returning a new handle. The…",126,[[],[["error",4],["result",4]]]],[0,"error","sunrise_libuser","Error handling",null,null],[3,"KernelError","sunrise_libuser::error","Kernel syscall error codes.",null,null],[12,"0","","",137,null],[3,"Module","","",null,null],[12,"0","","",138,null],[3,"FileSystemError","","FileSystem driver errors.",null,null],[12,"0","","",139,null],[3,"LibuserError","","Internal libuser errors.",null,null],[12,"0","","",140,null],[3,"SmError","","Service Manager errors.",null,null],[12,"0","","",141,null],[3,"AhciError","","AHCI driver errors.",null,null],[12,"0","","",142,null],[3,"TimeError","","Time errors.",null,null],[12,"0","","",143,null],[3,"LoaderError","","Loader errors.",null,null],[12,"0","","",144,null],[3,"PmError","","PM Errors.",null,null],[12,"0","","",145,null],[3,"HidError","","HID driver errors.",null,null],[12,"0","","",146,null],[3,"ViError","","Vi driver errors.",null,null],[12,"0","","",147,null],[3,"TwiliError","","Twili Pipe errors.",null,null],[12,"0","","",148,null],[4,"Error","","The global error type. Every error defined here can be…",null,null],[13,"Kernel","","A Kernel Error. Usually returned by syscalls.",149,null],[13,"Loader","","Loader error.",149,null],[13,"Pm","","Process Manager error.",149,null],[13,"Sm","","Service Manager error.",149,null],[13,"Vi","","Vi Error",149,null],[13,"Libuser","","Internal Libuser error.",149,null],[13,"Ahci","","Ahci driver error.",149,null],[13,"Time","","Time errors",149,null],[13,"FileSystem","","Filesystem driver error",149,null],[13,"Hid","","HID errors",149,null],[13,"Twili","","Twili Pipe errors",149,null],[13,"Unknown","","An unknown error type. Either someone returned a custom…",149,null],[11,"from_code","","Create an Error from a packed error code, creating a…",149,[[],["error",4]]],[11,"as_code","","Pack this error into an error code. Note that the returned…",149,[[]]],[18,"Kernel","","",138,null],[18,"FileSystem","","",138,null],[18,"Loader","","",138,null],[18,"Pm","","",138,null],[18,"Sm","","",138,null],[18,"Vi","","",138,null],[18,"Time","","",138,null],[18,"Hid","","",138,null],[18,"Libuser","","",138,null],[18,"Ahci","","",138,null],[18,"Twili","","",138,null],[18,"Unknown","","Unknown error.",139,null],[18,"PathNotFound","","The given resource couldn\'t be found.",139,null],[18,"PathExists","","A resource at the given path already exist.",139,null],[18,"InUse","","Resource already in use.",139,null],[18,"NoSpaceLeft","","There isn\'t enough space for a resource to be stored.",139,null],[18,"InvalidPartition","","The partition wasn\'t used as it\'s invalid.",139,null],[18,"OutOfRange","","Specified value is out of range.",139,null],[18,"WriteFailed","","A writing operation failed on the attached storage device.",139,null],[18,"ReadFailed","","A read operation failed on the attached storage device.",139,null],[18,"PartitionNotFound","","The given partition cannot be found.",139,null],[18,"InvalidInput","","The given input wasn\'t valid.",139,null],[18,"PathTooLong","","The given path is too long to be resolved.",139,null],[18,"ReadOnlyFileSystem","","Attempted to modify a read-only filesystem.",139,null],[18,"AccessDenied","","The access to a given resource has been denied.",139,null],[18,"FileNotFound","","The requested file wasn\'t found.",139,null],[18,"UnsupportedOperation","","The requested operation isn\'t supported by the detail.",139,null],[18,"DirectoryNotFound","","The requested directory wasn\'t found.",139,null],[18,"NotAFile","","The given resource cannot be represented as a file.",139,null],[18,"NotADirectory","","The given resource cannot be represented as a directory.",139,null],[18,"DiskNotFound","","The given disk id doesn\'t correspond to a any known disk.",139,null],[18,"AddressSpaceExhausted","","An attempt to find available space failed.",140,null],[18,"InvalidMoveHandleCount","","Too many move handles were passed to an IPC message.",140,null],[18,"InvalidCopyHandleCount","","Too many copy handles were passed to an IPC message.",140,null],[18,"PidMissing","","Attempted to read PID from an IPC message containing none.",140,null],[18,"InvalidIpcBufferCount","","Not enough IPC buffers were passed to an IPC message.",140,null],[18,"InvalidIpcBuffer","","Invalid IPCBuffer",140,null],[18,"InvalidIpcRequest","","Invalid IPC request",140,null],[18,"OutOfProcesses","","Too many processes spawned.",141,null],[18,"NotInitialized","","Attempted to use the service manager without initializing…",141,null],[18,"MaxSessions","","This service already reached the maximum amount of…",141,null],[18,"ServiceAlreadyRegistered","","Attempted to register a service that already exists.",141,null],[18,"OutOfServices","","Too many services have been created.",141,null],[18,"InvalidName","","The name is too long. Make sure it\'s only 7 characters and…",141,null],[18,"ServiceNotRegistered","","Attempted to unregister a service that was not previously…",141,null],[18,"PermissionDenied","","Process SACs do not allow accessing or hosting this service.",141,null],[18,"ServiceAccessControlTooBig","","The provided SACs are too big.",141,null],[18,"InvalidArg","","Passed argument were found to be illegal.",142,null],[18,"BufferTooScattered","","Passed buffer for DMA is too physically scattered. This…",142,null],[18,"IoError","","The hardware reported an error.",142,null],[18,"TimeNotFound","","The given calendar timestamp couldn\'t be computed.",143,null],[18,"Overflow","","Signed overflow/underflow happened.",143,null],[18,"OutOfRange","","The given input value was out of the timezone rule range.",143,null],[18,"TimeZoneConversionFailed","","Something when wrong during timezone conversion.",143,null],[18,"TimeZoneNotFound","","The requested timezone wasn\'t found",143,null],[18,"InvalidKacs","","KACs are invalid.",144,null],[18,"InvalidPath","","Invalid path read.",144,null],[18,"ProgramNotFound","","Tried to launch a title that does not exist.",144,null],[18,"InvalidElf","","The ELF is corrupted.",144,null],[18,"PidNotFound","","Pid not found",145,null],[18,"NoKeyboardStateUpdate","","The keyboard was idle and no new data can be provided.",146,null],[18,"InvalidUtf8","","The given string is not UTF-8.",147,null],[18,"OperationUnsupported","","Attempted to read on the write-side, or write on the…",148,null],[0,"allocator","sunrise_libuser","Heap allocator.",null,null],[3,"Allocator","sunrise_libuser::allocator","The libuser heap allocator.",null,null],[12,"0","","",150,null],[11,"expand","","Safely expands the heap if possible.",150,[[["mutexguard",3]],[["kernelerror",3],["result",4]]]],[11,"new","","Creates an empty heap.",150,[[],["allocator",3]]],[0,"terminal","sunrise_libuser","Terminal rendering APIs",null,null],[3,"Terminal","sunrise_libuser::terminal","A struct for logging text to the window.",null,null],[12,"buffer","","Internal write buffer.",151,null],[12,"pipe","","The vi pipe backing this terminal.",151,null],[4,"WindowSize","","Window creation requested size.",null,null],[13,"Fullscreen","","Takes the full screen.",152,null],[13,"FontLines","","Takes a given amount of lines.",152,null],[13,"Manual","","Manually position the window at the given x/y, with a…",152,null],[11,"new","","Creates a new Window of the requested size for terminal…",151,[[["windowsize",4]],[["terminal",3],["result",4],["error",4]]]],[11,"draw","","Flush the write buffer and draw the text.",151,[[],[["result",4],["error",4]]]],[11,"clone_pipe","","Clone this terminal\'s pipe.",151,[[],[["ipipeproxy",3],["error",4],["result",4]]]],[11,"read","","Read a line of text. Note that it might return without…",151,[[],[["error",4],["result",4]]]],[0,"ps2","sunrise_libuser","PS2 Keyboard APIs",null,null],[3,"InnerKeyboard","sunrise_libuser::ps2","Inner state of a managed keyboard.",null,null],[12,"ipc_session","","The session to kbrd:u",153,null],[12,"keys_queue","","The queue containing the keyboard state received from IPC.",153,null],[3,"Keyboard","","A managed keyboard.",null,null],[12,"inner","","Inner state",154,null],[12,"readable_event","","An event triggered on keyboard update.",154,null],[11,"new","","Creates a keyboard by connecting to the ipc service.",154,[[],[["error",4],["result",4]]]],[11,"read_key","","Waits for a single key press, and return its unicode…",154,[[]]],[11,"read_keystate_async","","Asynchronously waits for a single keystate change, and…",154,[[["workqueue",3]]]],[11,"read_key_async","","Asynchronously waits for a single key press, and return…",154,[[["workqueue",3]]]],[11,"try_read_key","","If a key press is pending, return its unicode…",154,[[],["option",4]]],[11,"try_read_keystate","","If a keystate change is pending, return the raw keystate.…",154,[[],[["hidkeyboardstate",3],["option",4]]]],[11,"update_keys","","Update keys from the keyboard service.",153,[[]]],[11,"try_read_cached_key","","Try to read a key from the internal cache queue.",153,[[],["option",4]]],[11,"try_read_key","","If a key press is pending, return its unicode…",153,[[],["option",4]]],[11,"try_read_keystate","","If a keystate change is pending, return the raw keystate.…",153,[[],[["hidkeyboardstate",3],["option",4]]]],[0,"window","sunrise_libuser","Window creation and drawing APIs",null,null],[3,"Color","sunrise_libuser::window","A rgb color",null,null],[12,"b","","Blue component",155,null],[12,"g","","Green component",155,null],[12,"r","","Red component",155,null],[12,"a","","Alpha component",155,null],[3,"Window","","A managed window.",null,null],[12,"buf","","The framebuffer memory shared with Vi. Drawing to this…",156,null],[12,"handle","","Vi handle for this window.",156,null],[12,"width","","Width of the window.",156,null],[12,"height","","Height of the window.",156,null],[12,"bpp","","Bits per pixel for the framebuffer.",156,null],[11,"rgb","","Creates a color from the r/g/b components. Alpha will be…",155,[[],["color",3]]],[11,"new","","Creates a window in the vi compositor.",156,[[],[["result",4],["window",3],["error",4]]]],[11,"draw","","Ask the compositor to redraw the window.",156,[[],[["result",4],["error",4]]]],[11,"width","","window width in pixels. Does not account for bpp",156,[[]]],[11,"height","","window height in pixels. Does not account for bpp",156,[[]]],[11,"bpp","","The number of bits that forms a pixel. Used to compute…",156,[[]]],[11,"get_px_offset","","Gets the offset in memory of a pixel based on an x and y.",156,[[]]],[11,"write_px","","Writes a pixel in the window respecting the bgr pattern",156,[[["color",3]]]],[11,"write_px_at","","Writes a pixel in the window respecting the bgr pattern…",156,[[["color",3]]]],[11,"get_buffer","","Gets the underlying framebuffer",156,[[]]],[11,"clear","","Clears the whole window, making it black.",156,[[]]],[0,"zero_box","sunrise_libuser","A module that allocates zeroed types on the heap without…",null,null],[3,"ZeroBox","sunrise_libuser::zero_box","A wrapper around a Box that can initialize itself directly…",null,null],[12,"owned_box","","The box we secretely wrap.",157,null],[8,"ZeroInitialized","","A marker trait indicating that zero values is a valid…",null,null],[11,"new","","Regular Box initialisation.",157,[[],["zerobox",3]]],[11,"new_zeroed","","Allocate a ZeroBox directly on the heap, and zero it.",157,[[],["zerobox",3]]],[0,"log_impl","sunrise_libuser","Implementation for the log crate",null,null],[3,"Logger","sunrise_libuser::log_impl","Log implementation structure.",null,null],[5,"init","","Initializes the global logger with the svc logger.",null,[[]]],[14,"capabilities","sunrise_libuser","Define the capabilities array in the .kernel_caps section.…",null,null],[14,"kip_header","","Define the kernel built-ins in the .kip_header section.…",null,null],[11,"size","sunrise_libuser::loop_future","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"into_future","","",1,[[]]],[11,"try_poll","","",1,[[["pin",3],["context",3]],["poll",4]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"from","","",2,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"size","sunrise_libuser::io","",4,[[]]],[11,"is_cool","","",4,[[]]],[11,"from_raw_parts","","",4,[[]]],[11,"from_raw_parts_mut","","",4,[[]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"size","","",5,[[]]],[11,"is_cool","","",5,[[]]],[11,"from_raw_parts","","",5,[[]]],[11,"from_raw_parts_mut","","",5,[[]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"size","","",6,[[]]],[11,"is_cool","","",6,[[]]],[11,"from_raw_parts","","",6,[[]]],[11,"from_raw_parts_mut","","",6,[[]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"size","","",7,[[]]],[11,"is_cool","","",7,[[]]],[11,"from_raw_parts","","",7,[[]]],[11,"from_raw_parts_mut","","",7,[[]]],[11,"from","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"size","sunrise_libuser::syscalls","",8,[[]]],[11,"is_cool","","",8,[[]]],[11,"from_raw_parts","","",8,[[]]],[11,"from_raw_parts_mut","","",8,[[]]],[11,"from","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"size","","",9,[[]]],[11,"is_cool","","",9,[[]]],[11,"from_raw_parts","","",9,[[]]],[11,"from_raw_parts_mut","","",9,[[]]],[11,"from","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"into","","",9,[[]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"size","","",10,[[]]],[11,"is_cool","","",10,[[]]],[11,"from_raw_parts","","",10,[[]]],[11,"from_raw_parts_mut","","",10,[[]]],[11,"from","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"into","","",10,[[]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"size","","",11,[[]]],[11,"is_cool","","",11,[[]]],[11,"from_raw_parts","","",11,[[]]],[11,"from_raw_parts_mut","","",11,[[]]],[11,"from","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"into","","",11,[[]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"size","","",12,[[]]],[11,"is_cool","","",12,[[]]],[11,"from_raw_parts","","",12,[[]]],[11,"from_raw_parts_mut","","",12,[[]]],[11,"from","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"into","","",12,[[]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"size","","",13,[[]]],[11,"is_cool","","",13,[[]]],[11,"from_raw_parts","","",13,[[]]],[11,"from_raw_parts_mut","","",13,[[]]],[11,"from","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"into","","",13,[[]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"size","","",14,[[]]],[11,"is_cool","","",14,[[]]],[11,"from_raw_parts","","",14,[[]]],[11,"from_raw_parts_mut","","",14,[[]]],[11,"from","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"into","","",14,[[]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"bit","","",14,[[]]],[11,"set_bit","","",14,[[]]],[11,"size","","",15,[[]]],[11,"is_cool","","",15,[[]]],[11,"from_raw_parts","","",15,[[]]],[11,"from_raw_parts_mut","","",15,[[]]],[11,"from","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"into","","",15,[[]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"size","","",16,[[]]],[11,"is_cool","","",16,[[]]],[11,"from_raw_parts","","",16,[[]]],[11,"from_raw_parts_mut","","",16,[[]]],[11,"from","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"into","","",16,[[]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"to_owned","","",16,[[]]],[11,"clone_into","","",16,[[]]],[11,"size","","",17,[[]]],[11,"is_cool","","",17,[[]]],[11,"from_raw_parts","","",17,[[]]],[11,"from_raw_parts_mut","","",17,[[]]],[11,"from","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"into","","",17,[[]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow","","",17,[[]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"to_owned","","",17,[[]]],[11,"clone_into","","",17,[[]]],[11,"size","","",18,[[]]],[11,"is_cool","","",18,[[]]],[11,"from_raw_parts","","",18,[[]]],[11,"from_raw_parts_mut","","",18,[[]]],[11,"from","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"into","","",18,[[]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow","","",18,[[]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"size","sunrise_libuser::types","",19,[[]]],[11,"is_cool","","",19,[[]]],[11,"from_raw_parts","","",19,[[]]],[11,"from_raw_parts_mut","","",19,[[]]],[11,"from","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"into","","",19,[[]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow","","",19,[[]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"size","","",20,[[]]],[11,"is_cool","","",20,[[]]],[11,"from_raw_parts","","",20,[[]]],[11,"from_raw_parts_mut","","",20,[[]]],[11,"from","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"into","","",20,[[]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow","","",20,[[]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"to_owned","","",20,[[]]],[11,"clone_into","","",20,[[]]],[11,"size","","",21,[[]]],[11,"is_cool","","",21,[[]]],[11,"from_raw_parts","","",21,[[]]],[11,"from_raw_parts_mut","","",21,[[]]],[11,"from","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"into","","",21,[[]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"size","","",22,[[]]],[11,"is_cool","","",22,[[]]],[11,"from_raw_parts","","",22,[[]]],[11,"from_raw_parts_mut","","",22,[[]]],[11,"from","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"into","","",22,[[]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"size","","",23,[[]]],[11,"is_cool","","",23,[[]]],[11,"from_raw_parts","","",23,[[]]],[11,"from_raw_parts_mut","","",23,[[]]],[11,"from","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"into","","",23,[[]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"size","","",24,[[]]],[11,"is_cool","","",24,[[]]],[11,"from_raw_parts","","",24,[[]]],[11,"from_raw_parts_mut","","",24,[[]]],[11,"from","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"into","","",24,[[]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow","","",24,[[]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"size","","",25,[[]]],[11,"is_cool","","",25,[[]]],[11,"from_raw_parts","","",25,[[]]],[11,"from_raw_parts_mut","","",25,[[]]],[11,"from","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"into","","",25,[[]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow","","",25,[[]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"size","","",26,[[]]],[11,"is_cool","","",26,[[]]],[11,"from_raw_parts","","",26,[[]]],[11,"from_raw_parts_mut","","",26,[[]]],[11,"from","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"into","","",26,[[]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow","","",26,[[]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"size","","",27,[[]]],[11,"is_cool","","",27,[[]]],[11,"from_raw_parts","","",27,[[]]],[11,"from_raw_parts_mut","","",27,[[]]],[11,"from","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"into","","",27,[[]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow","","",27,[[]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"size","","",28,[[]]],[11,"is_cool","","",28,[[]]],[11,"from_raw_parts","","",28,[[]]],[11,"from_raw_parts_mut","","",28,[[]]],[11,"from","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"into","","",28,[[]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow","","",28,[[]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"size","","",29,[[]]],[11,"is_cool","","",29,[[]]],[11,"from_raw_parts","","",29,[[]]],[11,"from_raw_parts_mut","","",29,[[]]],[11,"from","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"into","","",29,[[]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow","","",29,[[]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"size","","",30,[[]]],[11,"is_cool","","",30,[[]]],[11,"from_raw_parts","","",30,[[]]],[11,"from_raw_parts_mut","","",30,[[]]],[11,"from","","",30,[[]]],[11,"try_from","","",30,[[],["result",4]]],[11,"into","","",30,[[]]],[11,"try_into","","",30,[[],["result",4]]],[11,"borrow","","",30,[[]]],[11,"borrow_mut","","",30,[[]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"size","","",31,[[]]],[11,"is_cool","","",31,[[]]],[11,"from_raw_parts","","",31,[[]]],[11,"from_raw_parts_mut","","",31,[[]]],[11,"from","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"into","","",31,[[]]],[11,"try_into","","",31,[[],["result",4]]],[11,"borrow","","",31,[[]]],[11,"borrow_mut","","",31,[[]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"size","","",32,[[]]],[11,"is_cool","","",32,[[]]],[11,"from_raw_parts","","",32,[[]]],[11,"from_raw_parts_mut","","",32,[[]]],[11,"from","","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"into","","",32,[[]]],[11,"try_into","","",32,[[],["result",4]]],[11,"borrow","","",32,[[]]],[11,"borrow_mut","","",32,[[]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"to_owned","","",32,[[]]],[11,"clone_into","","",32,[[]]],[11,"size","sunrise_libuser::ipc","",33,[[]]],[11,"is_cool","","",33,[[]]],[11,"from_raw_parts","","",33,[[]]],[11,"from_raw_parts_mut","","",33,[[]]],[11,"from","","",33,[[]]],[11,"try_from","","",33,[[],["result",4]]],[11,"into","","",33,[[]]],[11,"try_into","","",33,[[],["result",4]]],[11,"borrow","","",33,[[]]],[11,"borrow_mut","","",33,[[]]],[11,"type_id","","",33,[[],["typeid",3]]],[11,"bit","","",33,[[]]],[11,"set_bit","","",33,[[]]],[11,"size","","",34,[[]]],[11,"is_cool","","",34,[[]]],[11,"from_raw_parts","","",34,[[]]],[11,"from_raw_parts_mut","","",34,[[]]],[11,"from","","",34,[[]]],[11,"try_from","","",34,[[],["result",4]]],[11,"into","","",34,[[]]],[11,"try_into","","",34,[[],["result",4]]],[11,"borrow","","",34,[[]]],[11,"borrow_mut","","",34,[[]]],[11,"type_id","","",34,[[],["typeid",3]]],[11,"bit","","",34,[[]]],[11,"set_bit","","",34,[[]]],[11,"size","","",35,[[]]],[11,"is_cool","","",35,[[]]],[11,"from_raw_parts","","",35,[[]]],[11,"from_raw_parts_mut","","",35,[[]]],[11,"from","","",35,[[]]],[11,"try_from","","",35,[[],["result",4]]],[11,"into","","",35,[[]]],[11,"try_into","","",35,[[],["result",4]]],[11,"borrow","","",35,[[]]],[11,"borrow_mut","","",35,[[]]],[11,"type_id","","",35,[[],["typeid",3]]],[11,"to_owned","","",35,[[]]],[11,"clone_into","","",35,[[]]],[11,"size","","",36,[[]]],[11,"is_cool","","",36,[[]]],[11,"from_raw_parts","","",36,[[]]],[11,"from_raw_parts_mut","","",36,[[]]],[11,"from","","",36,[[]]],[11,"try_from","","",36,[[],["result",4]]],[11,"into","","",36,[[]]],[11,"try_into","","",36,[[],["result",4]]],[11,"borrow","","",36,[[]]],[11,"borrow_mut","","",36,[[]]],[11,"type_id","","",36,[[],["typeid",3]]],[11,"size","","",37,[[]]],[11,"is_cool","","",37,[[]]],[11,"from_raw_parts","","",37,[[]]],[11,"from_raw_parts_mut","","",37,[[]]],[11,"from","","",37,[[]]],[11,"try_from","","",37,[[],["result",4]]],[11,"into","","",37,[[]]],[11,"try_into","","",37,[[],["result",4]]],[11,"borrow","","",37,[[]]],[11,"borrow_mut","","",37,[[]]],[11,"type_id","","",37,[[],["typeid",3]]],[11,"to_owned","","",37,[[]]],[11,"clone_into","","",37,[[]]],[11,"size","","",43,[[]]],[11,"is_cool","","",43,[[]]],[11,"from_raw_parts","","",43,[[]]],[11,"from_raw_parts_mut","","",43,[[]]],[11,"from","","",43,[[]]],[11,"try_from","","",43,[[],["result",4]]],[11,"into","","",43,[[]]],[11,"try_into","","",43,[[],["result",4]]],[11,"borrow","","",43,[[]]],[11,"borrow_mut","","",43,[[]]],[11,"type_id","","",43,[[],["typeid",3]]],[11,"size","sunrise_libuser::ipc::server","",44,[[]]],[11,"is_cool","","",44,[[]]],[11,"from_raw_parts","","",44,[[]]],[11,"from_raw_parts_mut","","",44,[[]]],[11,"from","","",44,[[]]],[11,"try_from","","",44,[[],["result",4]]],[11,"into","","",44,[[]]],[11,"try_into","","",44,[[],["result",4]]],[11,"borrow","","",44,[[]]],[11,"borrow_mut","","",44,[[]]],[11,"type_id","","",44,[[],["typeid",3]]],[11,"size","sunrise_libuser::threads","",47,[[]]],[11,"is_cool","","",47,[[]]],[11,"from_raw_parts","","",47,[[]]],[11,"from_raw_parts_mut","","",47,[[]]],[11,"from","","",47,[[]]],[11,"try_from","","",47,[[],["result",4]]],[11,"into","","",47,[[]]],[11,"try_into","","",47,[[],["result",4]]],[11,"borrow","","",47,[[]]],[11,"borrow_mut","","",47,[[]]],[11,"type_id","","",47,[[],["typeid",3]]],[11,"size","","",48,[[]]],[11,"is_cool","","",48,[[]]],[11,"from_raw_parts","","",48,[[]]],[11,"from_raw_parts_mut","","",48,[[]]],[11,"from","","",48,[[]]],[11,"try_from","","",48,[[],["result",4]]],[11,"into","","",48,[[]]],[11,"try_into","","",48,[[],["result",4]]],[11,"borrow","","",48,[[]]],[11,"borrow_mut","","",48,[[]]],[11,"type_id","","",48,[[],["typeid",3]]],[11,"size","","",49,[[]]],[11,"is_cool","","",49,[[]]],[11,"from_raw_parts","","",49,[[]]],[11,"from_raw_parts_mut","","",49,[[]]],[11,"from","","",49,[[]]],[11,"try_from","","",49,[[],["result",4]]],[11,"into","","",49,[[]]],[11,"try_into","","",49,[[],["result",4]]],[11,"borrow","","",49,[[]]],[11,"borrow_mut","","",49,[[]]],[11,"type_id","","",49,[[],["typeid",3]]],[11,"size","sunrise_libuser::thread_local_storage","",50,[[]]],[11,"is_cool","","",50,[[]]],[11,"from_raw_parts","","",50,[[]]],[11,"from_raw_parts_mut","","",50,[[]]],[11,"from","","",50,[[]]],[11,"try_from","","",50,[[],["result",4]]],[11,"into","","",50,[[]]],[11,"try_into","","",50,[[],["result",4]]],[11,"borrow","","",50,[[]]],[11,"borrow_mut","","",50,[[]]],[11,"type_id","","",50,[[],["typeid",3]]],[11,"size","","",51,[[]]],[11,"is_cool","","",51,[[]]],[11,"from_raw_parts","","",51,[[]]],[11,"from_raw_parts_mut","","",51,[[]]],[11,"from","","",51,[[]]],[11,"try_from","","",51,[[],["result",4]]],[11,"into","","",51,[[]]],[11,"try_into","","",51,[[],["result",4]]],[11,"borrow","","",51,[[]]],[11,"borrow_mut","","",51,[[]]],[11,"type_id","","",51,[[],["typeid",3]]],[11,"size","","",52,[[]]],[11,"is_cool","","",52,[[]]],[11,"from_raw_parts","","",52,[[]]],[11,"from_raw_parts_mut","","",52,[[]]],[11,"from","","",52,[[]]],[11,"try_from","","",52,[[],["result",4]]],[11,"into","","",52,[[]]],[11,"try_into","","",52,[[],["result",4]]],[11,"borrow","","",52,[[]]],[11,"borrow_mut","","",52,[[]]],[11,"type_id","","",52,[[],["typeid",3]]],[11,"size","sunrise_libuser::futures","",53,[[]]],[11,"is_cool","","",53,[[]]],[11,"from_raw_parts","","",53,[[]]],[11,"from_raw_parts_mut","","",53,[[]]],[11,"from","","",53,[[]]],[11,"try_from","","",53,[[],["result",4]]],[11,"into","","",53,[[]]],[11,"try_into","","",53,[[],["result",4]]],[11,"borrow","","",53,[[]]],[11,"borrow_mut","","",53,[[]]],[11,"type_id","","",53,[[],["typeid",3]]],[11,"size","","",54,[[]]],[11,"is_cool","","",54,[[]]],[11,"from_raw_parts","","",54,[[]]],[11,"from_raw_parts_mut","","",54,[[]]],[11,"from","","",54,[[]]],[11,"try_from","","",54,[[],["result",4]]],[11,"into","","",54,[[]]],[11,"try_into","","",54,[[],["result",4]]],[11,"borrow","","",54,[[]]],[11,"borrow_mut","","",54,[[]]],[11,"type_id","","",54,[[],["typeid",3]]],[11,"to_owned","","",54,[[]]],[11,"clone_into","","",54,[[]]],[11,"size","","",55,[[]]],[11,"is_cool","","",55,[[]]],[11,"from_raw_parts","","",55,[[]]],[11,"from_raw_parts_mut","","",55,[[]]],[11,"from","","",55,[[]]],[11,"try_from","","",55,[[],["result",4]]],[11,"into","","",55,[[]]],[11,"try_into","","",55,[[],["result",4]]],[11,"borrow","","",55,[[]]],[11,"borrow_mut","","",55,[[]]],[11,"type_id","","",55,[[],["typeid",3]]],[11,"to_owned","","",55,[[]]],[11,"clone_into","","",55,[[]]],[11,"size","","",56,[[]]],[11,"is_cool","","",56,[[]]],[11,"from_raw_parts","","",56,[[]]],[11,"from_raw_parts_mut","","",56,[[]]],[11,"from","","",56,[[]]],[11,"try_from","","",56,[[],["result",4]]],[11,"into","","",56,[[]]],[11,"try_into","","",56,[[],["result",4]]],[11,"borrow","","",56,[[]]],[11,"borrow_mut","","",56,[[]]],[11,"type_id","","",56,[[],["typeid",3]]],[11,"to_owned","","",56,[[]]],[11,"clone_into","","",56,[[]]],[11,"size","","",57,[[]]],[11,"is_cool","","",57,[[]]],[11,"from_raw_parts","","",57,[[]]],[11,"from_raw_parts_mut","","",57,[[]]],[11,"from","","",57,[[]]],[11,"try_from","","",57,[[],["result",4]]],[11,"into","","",57,[[]]],[11,"try_into","","",57,[[],["result",4]]],[11,"borrow","","",57,[[]]],[11,"borrow_mut","","",57,[[]]],[11,"type_id","","",57,[[],["typeid",3]]],[11,"size","","",58,[[]]],[11,"is_cool","","",58,[[]]],[11,"from_raw_parts","","",58,[[]]],[11,"from_raw_parts_mut","","",58,[[]]],[11,"from","","",58,[[]]],[11,"try_from","","",58,[[],["result",4]]],[11,"into","","",58,[[]]],[11,"try_into","","",58,[[],["result",4]]],[11,"borrow","","",58,[[]]],[11,"borrow_mut","","",58,[[]]],[11,"type_id","","",58,[[],["typeid",3]]],[11,"size","sunrise_libuser::sm","",59,[[]]],[11,"is_cool","","",59,[[]]],[11,"from_raw_parts","","",59,[[]]],[11,"from_raw_parts_mut","","",59,[[]]],[11,"from","","",59,[[]]],[11,"try_from","","",59,[[],["result",4]]],[11,"into","","",59,[[]]],[11,"try_into","","",59,[[],["result",4]]],[11,"borrow","","",59,[[]]],[11,"borrow_mut","","",59,[[]]],[11,"type_id","","",59,[[],["typeid",3]]],[11,"size","sunrise_libuser::vi","",62,[[]]],[11,"is_cool","","",62,[[]]],[11,"from_raw_parts","","",62,[[]]],[11,"from_raw_parts_mut","","",62,[[]]],[11,"from","","",62,[[]]],[11,"try_from","","",62,[[],["result",4]]],[11,"into","","",62,[[]]],[11,"try_into","","",62,[[],["result",4]]],[11,"borrow","","",62,[[]]],[11,"borrow_mut","","",62,[[]]],[11,"type_id","","",62,[[],["typeid",3]]],[11,"size","","",63,[[]]],[11,"is_cool","","",63,[[]]],[11,"from_raw_parts","","",63,[[]]],[11,"from_raw_parts_mut","","",63,[[]]],[11,"from","","",63,[[]]],[11,"try_from","","",63,[[],["result",4]]],[11,"into","","",63,[[]]],[11,"try_into","","",63,[[],["result",4]]],[11,"borrow","","",63,[[]]],[11,"borrow_mut","","",63,[[]]],[11,"type_id","","",63,[[],["typeid",3]]],[11,"size","sunrise_libuser::ahci","",68,[[]]],[11,"is_cool","","",68,[[]]],[11,"from_raw_parts","","",68,[[]]],[11,"from_raw_parts_mut","","",68,[[]]],[11,"from","","",68,[[]]],[11,"try_from","","",68,[[],["result",4]]],[11,"into","","",68,[[]]],[11,"try_into","","",68,[[],["result",4]]],[11,"borrow","","",68,[[]]],[11,"borrow_mut","","",68,[[]]],[11,"type_id","","",68,[[],["typeid",3]]],[11,"size","","",69,[[]]],[11,"is_cool","","",69,[[]]],[11,"from_raw_parts","","",69,[[]]],[11,"from_raw_parts_mut","","",69,[[]]],[11,"from","","",69,[[]]],[11,"try_from","","",69,[[],["result",4]]],[11,"into","","",69,[[]]],[11,"try_into","","",69,[[],["result",4]]],[11,"borrow","","",69,[[]]],[11,"borrow_mut","","",69,[[]]],[11,"type_id","","",69,[[],["typeid",3]]],[11,"size","sunrise_libuser::time","",74,[[]]],[11,"is_cool","","",74,[[]]],[11,"from_raw_parts","","",74,[[]]],[11,"from_raw_parts_mut","","",74,[[]]],[11,"from","","",74,[[]]],[11,"try_from","","",74,[[],["result",4]]],[11,"into","","",74,[[]]],[11,"try_into","","",74,[[],["result",4]]],[11,"borrow","","",74,[[]]],[11,"borrow_mut","","",74,[[]]],[11,"type_id","","",74,[[],["typeid",3]]],[11,"to_owned","","",74,[[]]],[11,"clone_into","","",74,[[]]],[11,"size","","",75,[[]]],[11,"is_cool","","",75,[[]]],[11,"from_raw_parts","","",75,[[]]],[11,"from_raw_parts_mut","","",75,[[]]],[11,"from","","",75,[[]]],[11,"try_from","","",75,[[],["result",4]]],[11,"into","","",75,[[]]],[11,"try_into","","",75,[[],["result",4]]],[11,"borrow","","",75,[[]]],[11,"borrow_mut","","",75,[[]]],[11,"type_id","","",75,[[],["typeid",3]]],[11,"to_owned","","",75,[[]]],[11,"clone_into","","",75,[[]]],[11,"size","","",76,[[]]],[11,"is_cool","","",76,[[]]],[11,"from_raw_parts","","",76,[[]]],[11,"from_raw_parts_mut","","",76,[[]]],[11,"from","","",76,[[]]],[11,"try_from","","",76,[[],["result",4]]],[11,"into","","",76,[[]]],[11,"try_into","","",76,[[],["result",4]]],[11,"borrow","","",76,[[]]],[11,"borrow_mut","","",76,[[]]],[11,"type_id","","",76,[[],["typeid",3]]],[11,"size","","",77,[[]]],[11,"is_cool","","",77,[[]]],[11,"from_raw_parts","","",77,[[]]],[11,"from_raw_parts_mut","","",77,[[]]],[11,"from","","",77,[[]]],[11,"try_from","","",77,[[],["result",4]]],[11,"into","","",77,[[]]],[11,"try_into","","",77,[[],["result",4]]],[11,"borrow","","",77,[[]]],[11,"borrow_mut","","",77,[[]]],[11,"type_id","","",77,[[],["typeid",3]]],[11,"size","","",78,[[]]],[11,"is_cool","","",78,[[]]],[11,"from_raw_parts","","",78,[[]]],[11,"from_raw_parts_mut","","",78,[[]]],[11,"from","","",78,[[]]],[11,"try_from","","",78,[[],["result",4]]],[11,"into","","",78,[[]]],[11,"try_into","","",78,[[],["result",4]]],[11,"borrow","","",78,[[]]],[11,"borrow_mut","","",78,[[]]],[11,"type_id","","",78,[[],["typeid",3]]],[11,"size","sunrise_libuser::fs","",85,[[]]],[11,"is_cool","","",85,[[]]],[11,"from_raw_parts","","",85,[[]]],[11,"from_raw_parts_mut","","",85,[[]]],[11,"from","","",85,[[]]],[11,"try_from","","",85,[[],["result",4]]],[11,"into","","",85,[[]]],[11,"try_into","","",85,[[],["result",4]]],[11,"borrow","","",85,[[]]],[11,"borrow_mut","","",85,[[]]],[11,"type_id","","",85,[[],["typeid",3]]],[11,"to_owned","","",85,[[]]],[11,"clone_into","","",85,[[]]],[11,"size","","",86,[[]]],[11,"is_cool","","",86,[[]]],[11,"from_raw_parts","","",86,[[]]],[11,"from_raw_parts_mut","","",86,[[]]],[11,"from","","",86,[[]]],[11,"try_from","","",86,[[],["result",4]]],[11,"into","","",86,[[]]],[11,"try_into","","",86,[[],["result",4]]],[11,"borrow","","",86,[[]]],[11,"borrow_mut","","",86,[[]]],[11,"type_id","","",86,[[],["typeid",3]]],[11,"to_owned","","",86,[[]]],[11,"clone_into","","",86,[[]]],[11,"size","","",87,[[]]],[11,"is_cool","","",87,[[]]],[11,"from_raw_parts","","",87,[[]]],[11,"from_raw_parts_mut","","",87,[[]]],[11,"from","","",87,[[]]],[11,"try_from","","",87,[[],["result",4]]],[11,"into","","",87,[[]]],[11,"try_into","","",87,[[],["result",4]]],[11,"borrow","","",87,[[]]],[11,"borrow_mut","","",87,[[]]],[11,"type_id","","",87,[[],["typeid",3]]],[11,"to_owned","","",87,[[]]],[11,"clone_into","","",87,[[]]],[11,"size","","",88,[[]]],[11,"is_cool","","",88,[[]]],[11,"from_raw_parts","","",88,[[]]],[11,"from_raw_parts_mut","","",88,[[]]],[11,"from","","",88,[[]]],[11,"try_from","","",88,[[],["result",4]]],[11,"into","","",88,[[]]],[11,"try_into","","",88,[[],["result",4]]],[11,"borrow","","",88,[[]]],[11,"borrow_mut","","",88,[[]]],[11,"type_id","","",88,[[],["typeid",3]]],[11,"to_owned","","",88,[[]]],[11,"clone_into","","",88,[[]]],[11,"size","","",89,[[]]],[11,"is_cool","","",89,[[]]],[11,"from_raw_parts","","",89,[[]]],[11,"from_raw_parts_mut","","",89,[[]]],[11,"from","","",89,[[]]],[11,"try_from","","",89,[[],["result",4]]],[11,"into","","",89,[[]]],[11,"try_into","","",89,[[],["result",4]]],[11,"borrow","","",89,[[]]],[11,"borrow_mut","","",89,[[]]],[11,"type_id","","",89,[[],["typeid",3]]],[11,"size","","",90,[[]]],[11,"is_cool","","",90,[[]]],[11,"from_raw_parts","","",90,[[]]],[11,"from_raw_parts_mut","","",90,[[]]],[11,"from","","",90,[[]]],[11,"try_from","","",90,[[],["result",4]]],[11,"into","","",90,[[]]],[11,"try_into","","",90,[[],["result",4]]],[11,"borrow","","",90,[[]]],[11,"borrow_mut","","",90,[[]]],[11,"type_id","","",90,[[],["typeid",3]]],[11,"size","","",91,[[]]],[11,"is_cool","","",91,[[]]],[11,"from_raw_parts","","",91,[[]]],[11,"from_raw_parts_mut","","",91,[[]]],[11,"from","","",91,[[]]],[11,"try_from","","",91,[[],["result",4]]],[11,"into","","",91,[[]]],[11,"try_into","","",91,[[],["result",4]]],[11,"borrow","","",91,[[]]],[11,"borrow_mut","","",91,[[]]],[11,"type_id","","",91,[[],["typeid",3]]],[11,"size","","",92,[[]]],[11,"is_cool","","",92,[[]]],[11,"from_raw_parts","","",92,[[]]],[11,"from_raw_parts_mut","","",92,[[]]],[11,"from","","",92,[[]]],[11,"try_from","","",92,[[],["result",4]]],[11,"into","","",92,[[]]],[11,"try_into","","",92,[[],["result",4]]],[11,"borrow","","",92,[[]]],[11,"borrow_mut","","",92,[[]]],[11,"type_id","","",92,[[],["typeid",3]]],[11,"size","","",93,[[]]],[11,"is_cool","","",93,[[]]],[11,"from_raw_parts","","",93,[[]]],[11,"from_raw_parts_mut","","",93,[[]]],[11,"from","","",93,[[]]],[11,"try_from","","",93,[[],["result",4]]],[11,"into","","",93,[[]]],[11,"try_into","","",93,[[],["result",4]]],[11,"borrow","","",93,[[]]],[11,"borrow_mut","","",93,[[]]],[11,"type_id","","",93,[[],["typeid",3]]],[11,"size","sunrise_libuser::keyboard","",104,[[]]],[11,"is_cool","","",104,[[]]],[11,"from_raw_parts","","",104,[[]]],[11,"from_raw_parts_mut","","",104,[[]]],[11,"from","","",104,[[]]],[11,"try_from","","",104,[[],["result",4]]],[11,"into","","",104,[[]]],[11,"try_into","","",104,[[],["result",4]]],[11,"borrow","","",104,[[]]],[11,"borrow_mut","","",104,[[]]],[11,"type_id","","",104,[[],["typeid",3]]],[11,"to_owned","","",104,[[]]],[11,"clone_into","","",104,[[]]],[11,"size","","",105,[[]]],[11,"is_cool","","",105,[[]]],[11,"from_raw_parts","","",105,[[]]],[11,"from_raw_parts_mut","","",105,[[]]],[11,"from","","",105,[[]]],[11,"try_from","","",105,[[],["result",4]]],[11,"into","","",105,[[]]],[11,"try_into","","",105,[[],["result",4]]],[11,"borrow","","",105,[[]]],[11,"borrow_mut","","",105,[[]]],[11,"type_id","","",105,[[],["typeid",3]]],[11,"to_owned","","",105,[[]]],[11,"clone_into","","",105,[[]]],[11,"size","","",106,[[]]],[11,"is_cool","","",106,[[]]],[11,"from_raw_parts","","",106,[[]]],[11,"from_raw_parts_mut","","",106,[[]]],[11,"from","","",106,[[]]],[11,"try_from","","",106,[[],["result",4]]],[11,"into","","",106,[[]]],[11,"try_into","","",106,[[],["result",4]]],[11,"borrow","","",106,[[]]],[11,"borrow_mut","","",106,[[]]],[11,"type_id","","",106,[[],["typeid",3]]],[11,"to_owned","","",106,[[]]],[11,"clone_into","","",106,[[]]],[11,"size","","",107,[[]]],[11,"is_cool","","",107,[[]]],[11,"from_raw_parts","","",107,[[]]],[11,"from_raw_parts_mut","","",107,[[]]],[11,"from","","",107,[[]]],[11,"try_from","","",107,[[],["result",4]]],[11,"into","","",107,[[]]],[11,"try_into","","",107,[[],["result",4]]],[11,"borrow","","",107,[[]]],[11,"borrow_mut","","",107,[[]]],[11,"type_id","","",107,[[],["typeid",3]]],[11,"size","sunrise_libuser::ldr","",110,[[]]],[11,"is_cool","","",110,[[]]],[11,"from_raw_parts","","",110,[[]]],[11,"from_raw_parts_mut","","",110,[[]]],[11,"from","","",110,[[]]],[11,"try_from","","",110,[[],["result",4]]],[11,"into","","",110,[[]]],[11,"try_into","","",110,[[],["result",4]]],[11,"borrow","","",110,[[]]],[11,"borrow_mut","","",110,[[]]],[11,"type_id","","",110,[[],["typeid",3]]],[11,"size","sunrise_libuser::twili","",113,[[]]],[11,"is_cool","","",113,[[]]],[11,"from_raw_parts","","",113,[[]]],[11,"from_raw_parts_mut","","",113,[[]]],[11,"from","","",113,[[]]],[11,"try_from","","",113,[[],["result",4]]],[11,"into","","",113,[[]]],[11,"try_into","","",113,[[],["result",4]]],[11,"borrow","","",113,[[]]],[11,"borrow_mut","","",113,[[]]],[11,"type_id","","",113,[[],["typeid",3]]],[11,"size","","",114,[[]]],[11,"is_cool","","",114,[[]]],[11,"from_raw_parts","","",114,[[]]],[11,"from_raw_parts_mut","","",114,[[]]],[11,"from","","",114,[[]]],[11,"try_from","","",114,[[],["result",4]]],[11,"into","","",114,[[]]],[11,"try_into","","",114,[[],["result",4]]],[11,"borrow","","",114,[[]]],[11,"borrow_mut","","",114,[[]]],[11,"type_id","","",114,[[],["typeid",3]]],[11,"size","","",115,[[]]],[11,"is_cool","","",115,[[]]],[11,"from_raw_parts","","",115,[[]]],[11,"from_raw_parts_mut","","",115,[[]]],[11,"from","","",115,[[]]],[11,"try_from","","",115,[[],["result",4]]],[11,"into","","",115,[[]]],[11,"try_into","","",115,[[],["result",4]]],[11,"borrow","","",115,[[]]],[11,"borrow_mut","","",115,[[]]],[11,"type_id","","",115,[[],["typeid",3]]],[11,"size","sunrise_libuser::example","",122,[[]]],[11,"is_cool","","",122,[[]]],[11,"from_raw_parts","","",122,[[]]],[11,"from_raw_parts_mut","","",122,[[]]],[11,"from","","",122,[[]]],[11,"try_from","","",122,[[],["result",4]]],[11,"into","","",122,[[]]],[11,"try_into","","",122,[[],["result",4]]],[11,"borrow","","",122,[[]]],[11,"borrow_mut","","",122,[[]]],[11,"type_id","","",122,[[],["typeid",3]]],[11,"size","","",123,[[]]],[11,"is_cool","","",123,[[]]],[11,"from_raw_parts","","",123,[[]]],[11,"from_raw_parts_mut","","",123,[[]]],[11,"from","","",123,[[]]],[11,"try_from","","",123,[[],["result",4]]],[11,"into","","",123,[[]]],[11,"try_into","","",123,[[],["result",4]]],[11,"borrow","","",123,[[]]],[11,"borrow_mut","","",123,[[]]],[11,"type_id","","",123,[[],["typeid",3]]],[11,"size","","",124,[[]]],[11,"is_cool","","",124,[[]]],[11,"from_raw_parts","","",124,[[]]],[11,"from_raw_parts_mut","","",124,[[]]],[11,"from","","",124,[[]]],[11,"try_from","","",124,[[],["result",4]]],[11,"into","","",124,[[]]],[11,"try_into","","",124,[[],["result",4]]],[11,"borrow","","",124,[[]]],[11,"borrow_mut","","",124,[[]]],[11,"type_id","","",124,[[],["typeid",3]]],[11,"size","","",125,[[]]],[11,"is_cool","","",125,[[]]],[11,"from_raw_parts","","",125,[[]]],[11,"from_raw_parts_mut","","",125,[[]]],[11,"from","","",125,[[]]],[11,"try_from","","",125,[[],["result",4]]],[11,"into","","",125,[[]]],[11,"try_into","","",125,[[],["result",4]]],[11,"borrow","","",125,[[]]],[11,"borrow_mut","","",125,[[]]],[11,"type_id","","",125,[[],["typeid",3]]],[11,"size","","",126,[[]]],[11,"is_cool","","",126,[[]]],[11,"from_raw_parts","","",126,[[]]],[11,"from_raw_parts_mut","","",126,[[]]],[11,"from","","",126,[[]]],[11,"try_from","","",126,[[],["result",4]]],[11,"into","","",126,[[]]],[11,"try_into","","",126,[[],["result",4]]],[11,"borrow","","",126,[[]]],[11,"borrow_mut","","",126,[[]]],[11,"type_id","","",126,[[],["typeid",3]]],[11,"size","sunrise_libuser::error","",137,[[]]],[11,"is_cool","","",137,[[]]],[11,"from_raw_parts","","",137,[[]]],[11,"from_raw_parts_mut","","",137,[[]]],[11,"from","","",137,[[]]],[11,"try_from","","",137,[[],["result",4]]],[11,"into","","",137,[[]]],[11,"try_into","","",137,[[],["result",4]]],[11,"borrow","","",137,[[]]],[11,"borrow_mut","","",137,[[]]],[11,"type_id","","",137,[[],["typeid",3]]],[11,"to_owned","","",137,[[]]],[11,"clone_into","","",137,[[]]],[11,"to_string","","",137,[[],["string",3]]],[11,"size","","",138,[[]]],[11,"is_cool","","",138,[[]]],[11,"from_raw_parts","","",138,[[]]],[11,"from_raw_parts_mut","","",138,[[]]],[11,"from","","",138,[[]]],[11,"try_from","","",138,[[],["result",4]]],[11,"into","","",138,[[]]],[11,"try_into","","",138,[[],["result",4]]],[11,"borrow","","",138,[[]]],[11,"borrow_mut","","",138,[[]]],[11,"type_id","","",138,[[],["typeid",3]]],[11,"to_owned","","",138,[[]]],[11,"clone_into","","",138,[[]]],[11,"size","","",139,[[]]],[11,"is_cool","","",139,[[]]],[11,"from_raw_parts","","",139,[[]]],[11,"from_raw_parts_mut","","",139,[[]]],[11,"from","","",139,[[]]],[11,"try_from","","",139,[[],["result",4]]],[11,"into","","",139,[[]]],[11,"try_into","","",139,[[],["result",4]]],[11,"borrow","","",139,[[]]],[11,"borrow_mut","","",139,[[]]],[11,"type_id","","",139,[[],["typeid",3]]],[11,"to_owned","","",139,[[]]],[11,"clone_into","","",139,[[]]],[11,"size","","",140,[[]]],[11,"is_cool","","",140,[[]]],[11,"from_raw_parts","","",140,[[]]],[11,"from_raw_parts_mut","","",140,[[]]],[11,"from","","",140,[[]]],[11,"try_from","","",140,[[],["result",4]]],[11,"into","","",140,[[]]],[11,"try_into","","",140,[[],["result",4]]],[11,"borrow","","",140,[[]]],[11,"borrow_mut","","",140,[[]]],[11,"type_id","","",140,[[],["typeid",3]]],[11,"to_owned","","",140,[[]]],[11,"clone_into","","",140,[[]]],[11,"size","","",141,[[]]],[11,"is_cool","","",141,[[]]],[11,"from_raw_parts","","",141,[[]]],[11,"from_raw_parts_mut","","",141,[[]]],[11,"from","","",141,[[]]],[11,"try_from","","",141,[[],["result",4]]],[11,"into","","",141,[[]]],[11,"try_into","","",141,[[],["result",4]]],[11,"borrow","","",141,[[]]],[11,"borrow_mut","","",141,[[]]],[11,"type_id","","",141,[[],["typeid",3]]],[11,"to_owned","","",141,[[]]],[11,"clone_into","","",141,[[]]],[11,"size","","",142,[[]]],[11,"is_cool","","",142,[[]]],[11,"from_raw_parts","","",142,[[]]],[11,"from_raw_parts_mut","","",142,[[]]],[11,"from","","",142,[[]]],[11,"try_from","","",142,[[],["result",4]]],[11,"into","","",142,[[]]],[11,"try_into","","",142,[[],["result",4]]],[11,"borrow","","",142,[[]]],[11,"borrow_mut","","",142,[[]]],[11,"type_id","","",142,[[],["typeid",3]]],[11,"to_owned","","",142,[[]]],[11,"clone_into","","",142,[[]]],[11,"size","","",143,[[]]],[11,"is_cool","","",143,[[]]],[11,"from_raw_parts","","",143,[[]]],[11,"from_raw_parts_mut","","",143,[[]]],[11,"from","","",143,[[]]],[11,"try_from","","",143,[[],["result",4]]],[11,"into","","",143,[[]]],[11,"try_into","","",143,[[],["result",4]]],[11,"borrow","","",143,[[]]],[11,"borrow_mut","","",143,[[]]],[11,"type_id","","",143,[[],["typeid",3]]],[11,"to_owned","","",143,[[]]],[11,"clone_into","","",143,[[]]],[11,"size","","",144,[[]]],[11,"is_cool","","",144,[[]]],[11,"from_raw_parts","","",144,[[]]],[11,"from_raw_parts_mut","","",144,[[]]],[11,"from","","",144,[[]]],[11,"try_from","","",144,[[],["result",4]]],[11,"into","","",144,[[]]],[11,"try_into","","",144,[[],["result",4]]],[11,"borrow","","",144,[[]]],[11,"borrow_mut","","",144,[[]]],[11,"type_id","","",144,[[],["typeid",3]]],[11,"to_owned","","",144,[[]]],[11,"clone_into","","",144,[[]]],[11,"size","","",145,[[]]],[11,"is_cool","","",145,[[]]],[11,"from_raw_parts","","",145,[[]]],[11,"from_raw_parts_mut","","",145,[[]]],[11,"from","","",145,[[]]],[11,"try_from","","",145,[[],["result",4]]],[11,"into","","",145,[[]]],[11,"try_into","","",145,[[],["result",4]]],[11,"borrow","","",145,[[]]],[11,"borrow_mut","","",145,[[]]],[11,"type_id","","",145,[[],["typeid",3]]],[11,"to_owned","","",145,[[]]],[11,"clone_into","","",145,[[]]],[11,"size","","",146,[[]]],[11,"is_cool","","",146,[[]]],[11,"from_raw_parts","","",146,[[]]],[11,"from_raw_parts_mut","","",146,[[]]],[11,"from","","",146,[[]]],[11,"try_from","","",146,[[],["result",4]]],[11,"into","","",146,[[]]],[11,"try_into","","",146,[[],["result",4]]],[11,"borrow","","",146,[[]]],[11,"borrow_mut","","",146,[[]]],[11,"type_id","","",146,[[],["typeid",3]]],[11,"to_owned","","",146,[[]]],[11,"clone_into","","",146,[[]]],[11,"size","","",147,[[]]],[11,"is_cool","","",147,[[]]],[11,"from_raw_parts","","",147,[[]]],[11,"from_raw_parts_mut","","",147,[[]]],[11,"from","","",147,[[]]],[11,"try_from","","",147,[[],["result",4]]],[11,"into","","",147,[[]]],[11,"try_into","","",147,[[],["result",4]]],[11,"borrow","","",147,[[]]],[11,"borrow_mut","","",147,[[]]],[11,"type_id","","",147,[[],["typeid",3]]],[11,"to_owned","","",147,[[]]],[11,"clone_into","","",147,[[]]],[11,"size","","",148,[[]]],[11,"is_cool","","",148,[[]]],[11,"from_raw_parts","","",148,[[]]],[11,"from_raw_parts_mut","","",148,[[]]],[11,"from","","",148,[[]]],[11,"try_from","","",148,[[],["result",4]]],[11,"into","","",148,[[]]],[11,"try_into","","",148,[[],["result",4]]],[11,"borrow","","",148,[[]]],[11,"borrow_mut","","",148,[[]]],[11,"type_id","","",148,[[],["typeid",3]]],[11,"to_owned","","",148,[[]]],[11,"clone_into","","",148,[[]]],[11,"size","","",149,[[]]],[11,"is_cool","","",149,[[]]],[11,"from_raw_parts","","",149,[[]]],[11,"from_raw_parts_mut","","",149,[[]]],[11,"from","","",149,[[]]],[11,"try_from","","",149,[[],["result",4]]],[11,"into","","",149,[[]]],[11,"try_into","","",149,[[],["result",4]]],[11,"borrow","","",149,[[]]],[11,"borrow_mut","","",149,[[]]],[11,"type_id","","",149,[[],["typeid",3]]],[11,"to_string","","",149,[[],["string",3]]],[11,"size","sunrise_libuser::allocator","",150,[[]]],[11,"is_cool","","",150,[[]]],[11,"from_raw_parts","","",150,[[]]],[11,"from_raw_parts_mut","","",150,[[]]],[11,"from","","",150,[[]]],[11,"try_from","","",150,[[],["result",4]]],[11,"into","","",150,[[]]],[11,"try_into","","",150,[[],["result",4]]],[11,"borrow","","",150,[[]]],[11,"borrow_mut","","",150,[[]]],[11,"type_id","","",150,[[],["typeid",3]]],[11,"size","sunrise_libuser::terminal","",151,[[]]],[11,"is_cool","","",151,[[]]],[11,"from_raw_parts","","",151,[[]]],[11,"from_raw_parts_mut","","",151,[[]]],[11,"from","","",151,[[]]],[11,"try_from","","",151,[[],["result",4]]],[11,"into","","",151,[[]]],[11,"try_into","","",151,[[],["result",4]]],[11,"borrow","","",151,[[]]],[11,"borrow_mut","","",151,[[]]],[11,"type_id","","",151,[[],["typeid",3]]],[11,"size","","",152,[[]]],[11,"is_cool","","",152,[[]]],[11,"from_raw_parts","","",152,[[]]],[11,"from_raw_parts_mut","","",152,[[]]],[11,"from","","",152,[[]]],[11,"try_from","","",152,[[],["result",4]]],[11,"into","","",152,[[]]],[11,"try_into","","",152,[[],["result",4]]],[11,"borrow","","",152,[[]]],[11,"borrow_mut","","",152,[[]]],[11,"type_id","","",152,[[],["typeid",3]]],[11,"to_owned","","",152,[[]]],[11,"clone_into","","",152,[[]]],[11,"size","sunrise_libuser::ps2","",153,[[]]],[11,"is_cool","","",153,[[]]],[11,"from_raw_parts","","",153,[[]]],[11,"from_raw_parts_mut","","",153,[[]]],[11,"from","","",153,[[]]],[11,"try_from","","",153,[[],["result",4]]],[11,"into","","",153,[[]]],[11,"try_into","","",153,[[],["result",4]]],[11,"borrow","","",153,[[]]],[11,"borrow_mut","","",153,[[]]],[11,"type_id","","",153,[[],["typeid",3]]],[11,"size","","",154,[[]]],[11,"is_cool","","",154,[[]]],[11,"from_raw_parts","","",154,[[]]],[11,"from_raw_parts_mut","","",154,[[]]],[11,"from","","",154,[[]]],[11,"try_from","","",154,[[],["result",4]]],[11,"into","","",154,[[]]],[11,"try_into","","",154,[[],["result",4]]],[11,"borrow","","",154,[[]]],[11,"borrow_mut","","",154,[[]]],[11,"type_id","","",154,[[],["typeid",3]]],[11,"size","sunrise_libuser::window","",155,[[]]],[11,"is_cool","","",155,[[]]],[11,"from_raw_parts","","",155,[[]]],[11,"from_raw_parts_mut","","",155,[[]]],[11,"from","","",155,[[]]],[11,"try_from","","",155,[[],["result",4]]],[11,"into","","",155,[[]]],[11,"try_into","","",155,[[],["result",4]]],[11,"borrow","","",155,[[]]],[11,"borrow_mut","","",155,[[]]],[11,"type_id","","",155,[[],["typeid",3]]],[11,"to_owned","","",155,[[]]],[11,"clone_into","","",155,[[]]],[11,"size","","",156,[[]]],[11,"is_cool","","",156,[[]]],[11,"from_raw_parts","","",156,[[]]],[11,"from_raw_parts_mut","","",156,[[]]],[11,"from","","",156,[[]]],[11,"try_from","","",156,[[],["result",4]]],[11,"into","","",156,[[]]],[11,"try_into","","",156,[[],["result",4]]],[11,"borrow","","",156,[[]]],[11,"borrow_mut","","",156,[[]]],[11,"type_id","","",156,[[],["typeid",3]]],[11,"size","sunrise_libuser::zero_box","",157,[[]]],[11,"is_cool","","",157,[[]]],[11,"from_raw_parts","","",157,[[]]],[11,"from_raw_parts_mut","","",157,[[]]],[11,"from","","",157,[[]]],[11,"try_from","","",157,[[],["result",4]]],[11,"into","","",157,[[]]],[11,"try_into","","",157,[[],["result",4]]],[11,"borrow","","",157,[[]]],[11,"borrow_mut","","",157,[[]]],[11,"type_id","","",157,[[],["typeid",3]]],[11,"size","sunrise_libuser::log_impl","",158,[[]]],[11,"is_cool","","",158,[[]]],[11,"from_raw_parts","","",158,[[]]],[11,"from_raw_parts_mut","","",158,[[]]],[11,"from","","",158,[[]]],[11,"try_from","","",158,[[],["result",4]]],[11,"into","","",158,[[]]],[11,"try_into","","",158,[[],["result",4]]],[11,"borrow","","",158,[[]]],[11,"borrow_mut","","",158,[[]]],[11,"type_id","","",158,[[],["typeid",3]]],[11,"into_result","sunrise_libuser::loop_future","",2,[[],["result",4]]],[11,"from_error","","",2,[[],[["poll",4],["option",4]]]],[11,"from_ok","","",2,[[],[["poll",4],["option",4]]]],[11,"into_result","","",2,[[],["result",4]]],[11,"from_error","","",2,[[],[["poll",4],["result",4]]]],[11,"from_ok","","",2,[[],[["poll",4],["result",4]]]],[11,"hash","","",2,[[]]],[11,"partial_cmp","","",2,[[["poll",4]],[["ordering",4],["option",4]]]],[11,"lt","","",2,[[["poll",4]]]],[11,"le","","",2,[[["poll",4]]]],[11,"gt","","",2,[[["poll",4]]]],[11,"ge","","",2,[[["poll",4]]]],[11,"clone","","",2,[[],["poll",4]]],[11,"eq","","",2,[[["poll",4]]]],[11,"ne","","",2,[[["poll",4]]]],[11,"fmt","","",2,[[["formatter",3]],[["result",4],["error",3]]]],[11,"cmp","","",2,[[["poll",4]],["ordering",4]]],[11,"from","","",2,[[],["poll",4]]],[11,"fmt","sunrise_libuser::io","Debug volatilely reads `value`.",7,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",4,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_libuser::loop_future","",0,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_libuser::io","Debug does not access the write only value.",5,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",6,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_libuser::loop_future","",1,[[["formatter",3]],[["result",4],["error",3]]]],[11,"poll","","",1,[[["pin",3],["loopfn",3],["context",3]],["poll",4]]],[11,"read","sunrise_libuser::io","Performs a volatile read of the value.",7,[[]]],[11,"write","","Performs a volatile write of the value.",7,[[]]],[11,"read","","Read",6,[[]]],[11,"write","","Write",6,[[]]],[11,"read","","Read",6,[[]]],[11,"write","","Write",6,[[]]],[11,"read","","Read",6,[[]]],[11,"write","","Write",6,[[]]],[11,"clone","","",6,[[],["pio",3]]],[11,"fmt","sunrise_libuser::syscalls","",11,[[["formatter",3]],[["result",4],["error",3]]]],[11,"from","","",12,[[],["poolpartition",4]]],[11,"from","","",13,[[],["procinfoaddrspace",4]]],[11,"eq","","",17,[[["processinfotype",3]]]],[11,"ne","","",17,[[["processinfotype",3]]]],[11,"eq","sunrise_libuser::error","",137,[[["kernelerror",3]]]],[11,"ne","","",137,[[["kernelerror",3]]]],[11,"eq","sunrise_libuser::syscalls","",9,[[["processcategory",3]]]],[11,"ne","","",9,[[["processcategory",3]]]],[11,"eq","","",16,[[["processstate",3]]]],[11,"ne","","",16,[[["processstate",3]]]],[11,"eq","","",11,[[["memorypermissions",3]]]],[11,"ne","","",11,[[["memorypermissions",3]]]],[11,"bitand_assign","","Disables all flags disabled in the set.",11,[[["memorypermissions",3]]]],[11,"extend","","",11,[[]]],[11,"fmt","sunrise_libuser::error","",137,[[["formatter",3]],[["result",4],["error",3]]]],[11,"clone","sunrise_libuser::syscalls","",11,[[],["memorypermissions",3]]],[11,"clone","","",16,[[],["processstate",3]]],[11,"clone","sunrise_libuser::error","",137,[[],["kernelerror",3]]],[11,"clone","sunrise_libuser::syscalls","",8,[[],["kipheader",3]]],[11,"clone","","",17,[[],["processinfotype",3]]],[11,"clone","","",9,[[],["processcategory",3]]],[11,"sub","","Returns the set difference of the two sets of flags.",11,[[["memorypermissions",3]],["memorypermissions",3]]],[11,"bitor","","Returns the union of the two sets of flags.",11,[[["memorypermissions",3]],["memorypermissions",3]]],[11,"fmt","","",11,[[["formatter",3]],[["result",4],["error",3]]]],[11,"sub_assign","","Disables all flags enabled in the set.",11,[[["memorypermissions",3]]]],[11,"bitor_assign","","Adds the set of flags.",11,[[["memorypermissions",3]]]],[11,"partial_cmp","","",11,[[["memorypermissions",3]],[["ordering",4],["option",4]]]],[11,"lt","","",11,[[["memorypermissions",3]]]],[11,"le","","",11,[[["memorypermissions",3]]]],[11,"gt","","",11,[[["memorypermissions",3]]]],[11,"ge","","",11,[[["memorypermissions",3]]]],[11,"bitxor_assign","","Toggles the set of flags.",11,[[["memorypermissions",3]]]],[11,"fmt","","",16,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",12,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",17,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",10,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",15,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",8,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",13,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",9,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",14,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",11,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_libuser::error","",137,[[["formatter",3]],[["result",4],["error",3]]]],[11,"bitxor","sunrise_libuser::syscalls","Returns the left flags, but with all the right flags…",11,[[["memorypermissions",3]],["memorypermissions",3]]],[11,"hash","","",11,[[]]],[11,"bit_range","","",14,[[]]],[11,"set_bit_range","","",14,[[]]],[11,"not","","Returns the complement of this set of flags.",11,[[],["memorypermissions",3]]],[11,"fmt","","",11,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",11,[[["formatter",3]],[["result",4],["error",3]]]],[11,"from_iter","","",11,[[],["memorypermissions",3]]],[11,"cmp","","",11,[[["memorypermissions",3]],["ordering",4]]],[11,"bitand","","Returns the intersection between the two sets of flags.",11,[[["memorypermissions",3]],["memorypermissions",3]]],[11,"default","","",17,[[],["processinfotype",3]]],[11,"default","","",8,[[],["kipheader",3]]],[11,"default","","",16,[[],["processstate",3]]],[11,"default","","",11,[[],["memorypermissions",3]]],[11,"default","","",10,[[],["memoryinfo",3]]],[11,"default","","",9,[[],["processcategory",3]]],[11,"deref","sunrise_libuser::ipc::server","",44,[[]]],[11,"deref","sunrise_libuser::zero_box","",157,[[]]],[11,"deref_mut","sunrise_libuser::ipc::server","",44,[[]]],[11,"deref_mut","sunrise_libuser::zero_box","",157,[[]]],[11,"from","sunrise_libuser::types","",24,[[["iuserinterfaceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::sm","",59,[[["clientsession",3]],["iuserinterfaceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["viinterfaceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::vi","",62,[[["clientsession",3]],["viinterfaceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["ibufferproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::vi","",63,[[["clientsession",3]],["ibufferproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["idiskproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::ahci","",68,[[["clientsession",3]],["idiskproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["ahciinterfaceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::ahci","",69,[[["clientsession",3]],["ahciinterfaceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["timezoneserviceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::time","",76,[[["clientsession",3]],["timezoneserviceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["rtcmanagerproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::time","",77,[[["clientsession",3]],["rtcmanagerproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["staticserviceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::time","",78,[[["clientsession",3]],["staticserviceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["ifileproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::fs","",89,[[["clientsession",3]],["ifileproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["idirectoryproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::fs","",90,[[["clientsession",3]],["idirectoryproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["istorageproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::fs","",91,[[["clientsession",3]],["istorageproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["ifilesystemproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::fs","",92,[[["clientsession",3]],["ifilesystemproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["ifilesystemserviceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::fs","",93,[[["clientsession",3]],["ifilesystemserviceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["staticserviceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::keyboard","",107,[[["clientsession",3]],["staticserviceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["iloaderinterfaceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::ldr","",110,[[["clientsession",3]],["iloaderinterfaceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["ipipeproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::twili","",113,[[["clientsession",3]],["ipipeproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["itwiliserviceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::twili","",114,[[["clientsession",3]],["itwiliserviceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["itwilimanagerserviceproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::twili","",115,[[["clientsession",3]],["itwilimanagerserviceproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["iexample4proxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::example","",122,[[["clientsession",3]],["iexample4proxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["iexample3subsessionproxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::example","",123,[[["clientsession",3]],["iexample3subsessionproxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["iexample2proxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::example","",124,[[["clientsession",3]],["iexample2proxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["iexample3proxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::example","",125,[[["clientsession",3]],["iexample3proxy",3]]],[11,"from","sunrise_libuser::types","",24,[[["iexample1proxy",3]],["clientsession",3]]],[11,"from","sunrise_libuser::example","",126,[[["clientsession",3]],["iexample1proxy",3]]],[11,"from","sunrise_libuser::error","",149,[[["kernelerror",3]]]],[11,"from","","",149,[[["filesystemerror",3]]]],[11,"from","","",149,[[["libusererror",3]]]],[11,"from","","",149,[[["smerror",3]]]],[11,"from","","",149,[[["ahcierror",3]]]],[11,"from","","",149,[[["timeerror",3]]]],[11,"from","","",149,[[["loadererror",3]]]],[11,"from","","",149,[[["pmerror",3]]]],[11,"from","","",149,[[["hiderror",3]]]],[11,"from","","",149,[[["vierror",3]]]],[11,"from","","",149,[[["twilierror",3]]]],[11,"fmt","sunrise_libuser::types","",19,[[["formatter",3]],["result",6]]],[11,"fmt","","",20,[[["formatter",3]],["result",6]]],[11,"fmt","","",21,[[["formatter",3]],["result",6]]],[11,"fmt","","",22,[[["formatter",3]],["result",6]]],[11,"fmt","","",23,[[["formatter",3]],["result",6]]],[11,"fmt","","",24,[[["formatter",3]],["result",6]]],[11,"fmt","","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",26,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",29,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","","",31,[[["formatter",3]],["result",6]]],[11,"fmt","","",32,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::ipc::server","",44,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::ipc","",33,[[["formatter",3]],["result",6]]],[11,"fmt","","",34,[[["formatter",3]],["result",6]]],[11,"fmt","","",37,[[["formatter",3]],["result",6]]],[11,"fmt","","",35,[[["formatter",3]],["result",6]]],[11,"fmt","","",43,[[["formatter",3]],["result",6]]],[11,"fmt","","",36,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::threads","",47,[[["formatter",3]],["result",6]]],[11,"fmt","","",48,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","","",49,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::thread_local_storage","",50,[[["formatter",3]],["result",6]]],[11,"fmt","","",51,[[["formatter",3]],["result",6]]],[11,"fmt","","",52,[[["formatter",3]],[["result",4],["error",3]]]],[11,"fmt","sunrise_libuser::futures","",53,[[["formatter",3]],["result",6]]],[11,"fmt","","",54,[[["formatter",3]],["result",6]]],[11,"fmt","","",55,[[["formatter",3]],["result",6]]],[11,"fmt","","",58,[[["formatter",3]],["result",6]]],[11,"fmt","","",56,[[["formatter",3]],["result",6]]],[11,"fmt","","",57,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::sm","",59,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::vi","",62,[[["formatter",3]],["result",6]]],[11,"fmt","","",63,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::ahci","",68,[[["formatter",3]],["result",6]]],[11,"fmt","","",69,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::time","",74,[[["formatter",3]],["result",6]]],[11,"fmt","","",75,[[["formatter",3]],["result",6]]],[11,"fmt","","",76,[[["formatter",3]],["result",6]]],[11,"fmt","","",77,[[["formatter",3]],["result",6]]],[11,"fmt","","",78,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::fs","",85,[[["formatter",3]],["result",6]]],[11,"fmt","","",86,[[["formatter",3]],["result",6]]],[11,"fmt","","",87,[[["formatter",3]],["result",6]]],[11,"fmt","","",88,[[["formatter",3]],["result",6]]],[11,"fmt","","",89,[[["formatter",3]],["result",6]]],[11,"fmt","","",90,[[["formatter",3]],["result",6]]],[11,"fmt","","",91,[[["formatter",3]],["result",6]]],[11,"fmt","","",92,[[["formatter",3]],["result",6]]],[11,"fmt","","",93,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::keyboard","",104,[[["formatter",3]],["result",6]]],[11,"fmt","","",105,[[["formatter",3]],["result",6]]],[11,"fmt","","",106,[[["formatter",3]],["result",6]]],[11,"fmt","","",107,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::ldr","",110,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::twili","",113,[[["formatter",3]],["result",6]]],[11,"fmt","","",114,[[["formatter",3]],["result",6]]],[11,"fmt","","",115,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::example","",122,[[["formatter",3]],["result",6]]],[11,"fmt","","",123,[[["formatter",3]],["result",6]]],[11,"fmt","","",124,[[["formatter",3]],["result",6]]],[11,"fmt","","",125,[[["formatter",3]],["result",6]]],[11,"fmt","","",126,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::error","",149,[[["formatter",3]],["result",6]]],[11,"fmt","","",138,[[["formatter",3]],["result",6]]],[11,"fmt","","",139,[[["formatter",3]],["result",6]]],[11,"fmt","","",140,[[["formatter",3]],["result",6]]],[11,"fmt","","",141,[[["formatter",3]],["result",6]]],[11,"fmt","","",142,[[["formatter",3]],["result",6]]],[11,"fmt","","",143,[[["formatter",3]],["result",6]]],[11,"fmt","","",144,[[["formatter",3]],["result",6]]],[11,"fmt","","",145,[[["formatter",3]],["result",6]]],[11,"fmt","","",146,[[["formatter",3]],["result",6]]],[11,"fmt","","",147,[[["formatter",3]],["result",6]]],[11,"fmt","","",148,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::terminal","",152,[[["formatter",3]],["result",6]]],[11,"fmt","","",151,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::ps2","",153,[[["formatter",3]],["result",6]]],[11,"fmt","","",154,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::window","",155,[[["formatter",3]],["result",6]]],[11,"fmt","","",156,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::zero_box","",157,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libuser::error","",149,[[["formatter",3]],["result",6]]],[11,"eq","sunrise_libuser::types","",19,[[["handle",3]]]],[11,"ne","","",19,[[["handle",3]]]],[11,"eq","","",20,[[["handleref",3]]]],[11,"ne","","",20,[[["handleref",3]]]],[11,"eq","","",32,[[["pid",3]]]],[11,"ne","","",32,[[["pid",3]]]],[11,"eq","sunrise_libuser::fs","",85,[[["filesystemtype",3]]]],[11,"ne","","",85,[[["filesystemtype",3]]]],[11,"eq","","",88,[[["directoryentrytype",3]]]],[11,"ne","","",88,[[["directoryentrytype",3]]]],[11,"eq","sunrise_libuser::keyboard","",104,[[["hidkeyboardstatetype",3]]]],[11,"ne","","",104,[[["hidkeyboardstatetype",3]]]],[11,"eq","","",105,[[["hidkeyboardscancode",3]]]],[11,"ne","","",105,[[["hidkeyboardscancode",3]]]],[11,"eq","sunrise_libuser::error","",138,[[["module",3]]]],[11,"ne","","",138,[[["module",3]]]],[11,"eq","","",139,[[["filesystemerror",3]]]],[11,"ne","","",139,[[["filesystemerror",3]]]],[11,"eq","","",140,[[["libusererror",3]]]],[11,"ne","","",140,[[["libusererror",3]]]],[11,"eq","","",141,[[["smerror",3]]]],[11,"ne","","",141,[[["smerror",3]]]],[11,"eq","","",142,[[["ahcierror",3]]]],[11,"ne","","",142,[[["ahcierror",3]]]],[11,"eq","","",143,[[["timeerror",3]]]],[11,"ne","","",143,[[["timeerror",3]]]],[11,"eq","","",144,[[["loadererror",3]]]],[11,"ne","","",144,[[["loadererror",3]]]],[11,"eq","","",145,[[["pmerror",3]]]],[11,"ne","","",145,[[["pmerror",3]]]],[11,"eq","","",146,[[["hiderror",3]]]],[11,"ne","","",146,[[["hiderror",3]]]],[11,"eq","","",147,[[["vierror",3]]]],[11,"ne","","",147,[[["vierror",3]]]],[11,"eq","","",148,[[["twilierror",3]]]],[11,"ne","","",148,[[["twilierror",3]]]],[11,"cmp","sunrise_libuser::types","",32,[[["pid",3]],["ordering",4]]],[11,"partial_cmp","","",32,[[["pid",3]],[["option",4],["ordering",4]]]],[11,"lt","","",32,[[["pid",3]]]],[11,"le","","",32,[[["pid",3]]]],[11,"gt","","",32,[[["pid",3]]]],[11,"ge","","",32,[[["pid",3]]]],[11,"drop","","",19,[[]]],[11,"drop","","",24,[[]]],[11,"drop","","",31,[[]]],[11,"drop","sunrise_libuser::threads","",47,[[]]],[11,"drop","","",49,[[]]],[11,"drop","sunrise_libuser::thread_local_storage","Dropping a ThreadLocalStaticRegion deallocates it.",52,[[]]],[11,"index","sunrise_libuser::ipc::server","",44,[[]]],[11,"write_str","sunrise_libuser::terminal","",151,[[],[["result",4],["error",3]]]],[11,"write_str","sunrise_libuser::twili","",113,[[],[["result",4],["error",3]]]],[11,"as_ref","sunrise_libuser::zero_box","",157,[[]]],[11,"as_mut","","",157,[[]]],[11,"clone","sunrise_libuser::types","",20,[[],["handleref",3]]],[11,"clone","","",32,[[],["pid",3]]],[11,"clone","sunrise_libuser::ipc","",37,[[],["ipcbuffertype",4]]],[11,"clone","","",35,[[],["ipcbuffer",3]]],[11,"clone","sunrise_libuser::futures","",54,[[],["workqueue",3]]],[11,"clone","","",55,[[],["simpleworkqueue",3]]],[11,"clone","","",56,[[],["queuewaker",3]]],[11,"clone","sunrise_libuser::time","",74,[[],["calendaradditionalinfo",3]]],[11,"clone","","",75,[[],["calendartime",3]]],[11,"clone","sunrise_libuser::fs","",85,[[],["filesystemtype",3]]],[11,"clone","","",86,[[],["directoryentry",3]]],[11,"clone","","",87,[[],["filetimestampraw",3]]],[11,"clone","","",88,[[],["directoryentrytype",3]]],[11,"clone","sunrise_libuser::keyboard","",104,[[],["hidkeyboardstatetype",3]]],[11,"clone","","",105,[[],["hidkeyboardscancode",3]]],[11,"clone","","",106,[[],["hidkeyboardstate",3]]],[11,"clone","sunrise_libuser::error","",138,[[],["module",3]]],[11,"clone","","",139,[[],["filesystemerror",3]]],[11,"clone","","",140,[[],["libusererror",3]]],[11,"clone","","",141,[[],["smerror",3]]],[11,"clone","","",142,[[],["ahcierror",3]]],[11,"clone","","",143,[[],["timeerror",3]]],[11,"clone","","",144,[[],["loadererror",3]]],[11,"clone","","",145,[[],["pmerror",3]]],[11,"clone","","",146,[[],["hiderror",3]]],[11,"clone","","",147,[[],["vierror",3]]],[11,"clone","","",148,[[],["twilierror",3]]],[11,"clone","sunrise_libuser::terminal","",152,[[],["windowsize",4]]],[11,"clone","sunrise_libuser::window","",155,[[],["color",3]]],[11,"default","sunrise_libuser::futures","",54,[[],["workqueue",3]]],[11,"default","","",55,[[],["simpleworkqueue",3]]],[11,"default","","",57,[[]]],[11,"alloc","sunrise_libuser::allocator","",150,[[["layout",3]]]],[11,"dealloc","","",150,[[["layout",3]]]],[11,"bit_range","sunrise_libuser::ipc","",33,[[]]],[11,"set_bit_range","","",33,[[]]],[11,"bit_range","","",34,[[]]],[11,"set_bit_range","","",34,[[]]],[11,"enabled","sunrise_libuser::log_impl","",158,[[["metadata",3]]]],[11,"log","","",158,[[["record",3]]]],[11,"flush","","",158,[[]]],[11,"wake_by_ref","sunrise_libuser::futures","",56,[[["arc",3]]]],[11,"map","sunrise_libuser::loop_future","Changes the ready value of this `Poll` with the closure…",2,[[],["poll",4]]],[11,"is_ready","","Returns `true` if this is `Poll::Ready`",2,[[]]],[11,"is_pending","","Returns `true` if this is `Poll::Pending`",2,[[]]],[11,"map_ok","","Changes the success value of this `Poll` with the closure…",2,[[],[["poll",4],["result",4]]]],[11,"map_err","","Changes the error value of this `Poll` with the closure…",2,[[],[["result",4],["poll",4]]]],[11,"map_ok","","Changes the success value of this `Poll` with the closure…",2,[[],[["poll",4],["option",4]]]],[11,"map_err","","Changes the error value of this `Poll` with the closure…",2,[[],[["option",4],["poll",4]]]],[11,"new","sunrise_libuser::io","Create a read-only wrapper around the IO device address.",4,[[],["readonly",3]]],[11,"read","","Reads from this Io.",4,[[]]],[11,"readf","","Read from this Io, and mask the value with `flags`.",4,[[]]],[11,"new","","Creates a WriteOnly Io.",5,[[],["writeonly",3]]],[11,"write","","Writes `value` to this Io.",5,[[]]],[11,"new","","Create a PIO from a given port",6,[[],["pio",3]]],[11,"new","","Create a new Mmio without initializing.",7,[[],["mmio",3]]],[18,"RegularTitle","sunrise_libuser::syscalls","Regular process created through the userspace loader.",9,null],[18,"KernelBuiltin","","Process loaded by the kernel early during the boot process.",9,null],[11,"check","","Checks that the permissions as valid - that is, it should…",11,[[],[["result",4],["kernelerror",3]]]],[18,"READABLE","","The area is readable.",11,null],[18,"WRITABLE","","The area is writable.",11,null],[18,"EXECUTABLE","","The area is executable.",11,null],[18,"RO","","The area is ReadOnly.",11,null],[18,"RW","","The area is RW.",11,null],[18,"RX","","The area is RX.",11,null],[11,"empty","","Returns an empty set of flags",11,[[],["memorypermissions",3]]],[11,"all","","Returns the set containing all flags.",11,[[],["memorypermissions",3]]],[11,"bits","","Returns the raw value of the flags currently stored.",11,[[]]],[11,"from_bits","","Convert from underlying bit representation, unless that…",11,[[],[["memorypermissions",3],["option",4]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any…",11,[[],["memorypermissions",3]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",11,[[]]],[11,"is_all","","Returns `true` if all flags are currently set.",11,[[]]],[11,"intersects","","Returns `true` if there are flags common to both `self`…",11,[[["memorypermissions",3]]]],[11,"contains","","Returns `true` all of the flags in `other` are contained…",11,[[["memorypermissions",3]]]],[11,"insert","","Inserts the specified flags in-place.",11,[[["memorypermissions",3]]]],[11,"remove","","Removes the specified flags in-place.",11,[[["memorypermissions",3]]]],[11,"toggle","","Toggles the specified flags in-place.",11,[[["memorypermissions",3]]]],[11,"set","","Inserts or removes the specified flags depending on the…",11,[[["memorypermissions",3]]]],[11,"check","","Checks that the ProcInfoFlags doesn\'t contain any unknown…",14,[[],[["result",4],["kernelerror",3]]]],[11,"is_64bit","","64-bit instructions support.",14,[[]]],[11,"set_64bit","","64-bit instructions support.",14,[[]]],[11,"address_space_type","","Address space width of the process.",14,[[],["procinfoaddrspace",4]]],[11,"set_address_space_type","","Address space width of the process.",14,[[["procinfoaddrspace",4]]]],[11,"is_debug","","Whether to signal various conditions (such as exceptions).",14,[[]]],[11,"set_debug","","Whether to signal various conditions (such as exceptions).",14,[[]]],[11,"is_aslr","","Enable randomization of the various memory regions (heap,…",14,[[]]],[11,"set_aslr","","Enable randomization of the various memory regions (heap,…",14,[[]]],[11,"is_application","","Process is an application. There can only be one…",14,[[]]],[11,"set_application","","Process is an application. There can only be one…",14,[[]]],[11,"use_secure_memory","","unknown.",14,[[]]],[11,"pool_partition","","The memory pool to use for this process.",14,[[],["poolpartition",4]]],[11,"set_pool_partition","","The memory pool to use for this process.",14,[[["poolpartition",4]]]],[11,"optimize_memory_allocation","","unknown",14,[[]]],[18,"Created","","Process is freshly created with svcCreateProcess and has…",16,null],[18,"CreatedAttached","","Process has been attached with a debugger before it was…",16,null],[18,"Started","","Process has been started.",16,null],[18,"Crashed","","Process has crashed.",16,null],[18,"StartedAttached","","Process is started and has a debugger attached.",16,null],[18,"Exiting","","Process is currently exiting.",16,null],[18,"Exited","","Process is stopped.",16,null],[18,"DebugSuspended","","Process has been suspended.",16,null],[18,"ProcessState","","Get the state the process is currently in.",17,null],[11,"make_ret","sunrise_libuser::error","Transforms a KernelError into the encoding acceptable for…",137,[[]]],[11,"from_syscall_ret","","Turns a syscall return value into a Kernel Error.",137,[[],["kernelerror",3]]],[11,"from_description","","Turns a kernel error description into a KernelError.",137,[[],["kernelerror",3]]],[11,"description","","Gets the underlying KernelError description.",137,[[]]],[18,"InvalidKernelCaps","","Kernel capabilities are invalid.",137,null],[18,"NotImplemented","","This function is not implemented.",137,null],[18,"InvalidSize","","The size argument is invalid.",137,null],[18,"InvalidAddress","","The passed address is invalid.",137,null],[18,"MemoryFull","","The virtual address space was exhausted.",137,null],[18,"HandleTableFull","","The process\' handle table is full.",137,null],[18,"InvalidMemState","","The memory state is invalid for this action.",137,null],[18,"InvalidMemPerms","","The memory permissions passed are wrong.",137,null],[18,"InvalidMemRange","","Memory range is not at an expected location.",137,null],[18,"InvalidThreadPriority","","Invalid thread priority. Thread priority should be within…",137,null],[18,"InvalidProcessorId","","Invalid processor id. Processor ID should exist on the…",137,null],[18,"InvalidHandle","","Passed handle is invalid.",137,null],[18,"CopyFromUserFailed","","Attempt to copy the userspace address failed.",137,null],[18,"InvalidCombination","","The combination of argument is invalid.",137,null],[18,"Timeout","","A timeout was reached.",137,null],[18,"Canceled","","The syscall was cancelled through cancel_synchronization.",137,null],[18,"ExceedingMaximum","","A size or address was given exceeding the maximum allowed…",137,null],[18,"InvalidEnum","","No enum variants match this integer value.",137,null],[18,"NoSuchEntry","","The given entry does not exist.",137,null],[18,"PortRemoteDead","","The remote part of the session was closed.",137,null],[18,"InvalidState","","Attempted to do an operation that\'s invalid in the…",137,null],[18,"ReservedValue","","Attempted to use an unknown value, reserved for future use.",137,null]],"p":[[4,"Loop"],[3,"LoopFn"],[4,"Poll"],[8,"Io"],[3,"ReadOnly"],[3,"WriteOnly"],[3,"Pio"],[3,"Mmio"],[3,"KipHeader"],[3,"ProcessCategory"],[3,"MemoryInfo"],[3,"MemoryPermissions"],[4,"PoolPartition"],[4,"ProcInfoAddrSpace"],[3,"ProcInfoFlags"],[3,"ProcInfo"],[3,"ProcessState"],[3,"ProcessInfoType"],[3,"Registers"],[3,"Handle"],[3,"HandleRef"],[3,"IRQEvent"],[3,"ReadableEvent"],[3,"WritableEvent"],[3,"ClientSession"],[3,"ServerSession"],[3,"ClientPort"],[3,"ServerPort"],[3,"Thread"],[3,"Process"],[3,"SharedMemory"],[3,"MappedSharedMemory"],[3,"Pid"],[3,"MsgPackedHdr"],[3,"HandleDescriptorHeader"],[3,"IPCBuffer"],[3,"Message"],[4,"IPCBufferType"],[13,"A"],[13,"B"],[13,"W"],[13,"X"],[13,"C"],[4,"MessageTy"],[3,"Align16"],[8,"FutureCallback"],[8,"SizedIPCBuffer"],[3,"StackContext"],[3,"ThreadContext"],[3,"Thread"],[3,"TlsElf"],[3,"ThreadControlBlock"],[3,"ThreadLocalStaticRegion"],[3,"Task"],[3,"WorkQueue"],[3,"SimpleWorkQueue"],[3,"QueueWaker"],[3,"WaitableManager"],[4,"WorkItem"],[3,"IUserInterfaceProxy"],[8,"IUserInterface"],[8,"IUserInterfaceAsync"],[3,"ViInterfaceProxy"],[3,"IBufferProxy"],[8,"ViInterface"],[8,"ViInterfaceAsync"],[8,"IBuffer"],[8,"IBufferAsync"],[3,"IDiskProxy"],[3,"AhciInterfaceProxy"],[8,"IDisk"],[8,"IDiskAsync"],[8,"AhciInterface"],[8,"AhciInterfaceAsync"],[3,"CalendarAdditionalInfo"],[3,"CalendarTime"],[3,"TimeZoneServiceProxy"],[3,"RTCManagerProxy"],[3,"StaticServiceProxy"],[8,"TimeZoneService"],[8,"TimeZoneServiceAsync"],[8,"RTCManager"],[8,"RTCManagerAsync"],[8,"StaticService"],[8,"StaticServiceAsync"],[3,"FileSystemType"],[3,"DirectoryEntry"],[3,"FileTimeStampRaw"],[3,"DirectoryEntryType"],[3,"IFileProxy"],[3,"IDirectoryProxy"],[3,"IStorageProxy"],[3,"IFileSystemProxy"],[3,"IFileSystemServiceProxy"],[8,"IFile"],[8,"IFileAsync"],[8,"IDirectory"],[8,"IDirectoryAsync"],[8,"IStorage"],[8,"IStorageAsync"],[8,"IFileSystem"],[8,"IFileSystemAsync"],[8,"IFileSystemService"],[8,"IFileSystemServiceAsync"],[3,"HidKeyboardStateType"],[3,"HidKeyboardScancode"],[3,"HidKeyboardState"],[3,"StaticServiceProxy"],[8,"StaticService"],[8,"StaticServiceAsync"],[3,"ILoaderInterfaceProxy"],[8,"ILoaderInterface"],[8,"ILoaderInterfaceAsync"],[3,"IPipeProxy"],[3,"ITwiliServiceProxy"],[3,"ITwiliManagerServiceProxy"],[8,"IPipe"],[8,"IPipeAsync"],[8,"ITwiliService"],[8,"ITwiliServiceAsync"],[8,"ITwiliManagerService"],[8,"ITwiliManagerServiceAsync"],[3,"IExample4Proxy"],[3,"IExample3SubsessionProxy"],[3,"IExample2Proxy"],[3,"IExample3Proxy"],[3,"IExample1Proxy"],[8,"IExample4"],[8,"IExample4Async"],[8,"IExample3Subsession"],[8,"IExample3SubsessionAsync"],[8,"IExample2"],[8,"IExample2Async"],[8,"IExample3"],[8,"IExample3Async"],[8,"IExample1"],[8,"IExample1Async"],[3,"KernelError"],[3,"Module"],[3,"FileSystemError"],[3,"LibuserError"],[3,"SmError"],[3,"AhciError"],[3,"TimeError"],[3,"LoaderError"],[3,"PmError"],[3,"HidError"],[3,"ViError"],[3,"TwiliError"],[4,"Error"],[3,"Allocator"],[3,"Terminal"],[4,"WindowSize"],[3,"InnerKeyboard"],[3,"Keyboard"],[3,"Color"],[3,"Window"],[3,"ZeroBox"],[3,"Logger"]]},\
"sunrise_libutils":{"doc":"A messy crate with various utilities shared between the…","i":[[3,"CursorWrite","sunrise_libutils","A minimal Cursor for writing, for use in libcore.",null,null],[12,"data","","Data backing this cursor.",0,null],[12,"pos","","Position of the cursor in the data.",0,null],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",null,null],[12,"data","","Data backing this cursor.",1,null],[12,"pos","","Position of the cursor in the data.",1,null],[5,"align_up","","Align the address to the next alignment.",null,[[["bitand",8],["num",8],["copy",8],["not",8]],[["not",8],["num",8],["copy",8],["bitand",8]]]],[5,"align_down","","Align the address to the previous alignment.",null,[[["bitand",8],["num",8],["copy",8],["not",8]],[["not",8],["num",8],["copy",8],["bitand",8]]]],[5,"align_up_checked","","align_up, but checks if addr overflows",null,[[],["option",4]]],[5,"div_ceil","","Counts the numbers of `b` in `a`, rounding the result up.",null,[[["num",8],["copy",8]],[["num",8],["copy",8]]]],[5,"print_hexdump","","Displays memory as hexdump",null,[[]]],[5,"print_hexdump_as_if_at_addr","","Makes a hexdump of a slice, but display different…",null,[[]]],[5,"bit_array_first_zero","","Returns the index of the first 0 in a bit array.",null,[[],["option",4]]],[5,"bit_array_first_one","","Returns the index of the first 1 in a bit array.",null,[[],["option",4]]],[5,"bit_array_first_count_one","","Returns the index of the first instance of count…",null,[[],["option",4]]],[5,"log2_floor","","Returns the floored base 2 logarithm of the number.",null,[[]]],[5,"log2_ceil","","Returns the ceiled base 2 logarithm of the number.",null,[[]]],[5,"cast_mut","","Cast a slice while keeping the lifetimes.",null,[[]]],[0,"io","","The IO interface",null,null],[3,"Pio","sunrise_libutils::io","Port IO accessor.",null,null],[12,"port","","The io port address.",2,null],[12,"value","","The width of the port.",2,null],[3,"Mmio","","A value that can only be accessed volatilely.",null,null],[12,"value","","The value. Can only be accessed through .read()",3,null],[3,"ReadOnly","","A read-only wrapper around an IO device.",null,null],[12,"inner","","",4,null],[3,"WriteOnly","","An Io that we can only write to.",null,null],[12,"inner","","",5,null],[0,"pio","","Port Io",null,null],[3,"Pio","sunrise_libutils::io::pio","Port IO accessor.",null,null],[12,"port","","The io port address.",2,null],[12,"value","","The width of the port.",2,null],[11,"new","sunrise_libutils::io","Create a PIO from a given port",2,[[]]],[0,"mmio","","Wrapper around a mmio value",null,null],[3,"Mmio","sunrise_libutils::io::mmio","A value that can only be accessed volatilely.",null,null],[12,"value","","The value. Can only be accessed through .read()",3,null],[11,"new","sunrise_libutils::io","Create a new Mmio without initializing.",3,[[]]],[8,"Io","","The Io trait allows for accessing device IO in a generic…",null,null],[16,"Value","","The width of the IO access. Should be a primitive type…",6,null],[10,"read","","Reads from this Io.",6,[[]]],[10,"write","","Writes `value` to this Io.",6,[[]]],[11,"readf","","Read from this Io, and mask the value with `flags`.",6,[[]]],[11,"writef","","Mask `value` with `flags`, and write it to this device…",6,[[]]],[11,"new","","Create a read-only wrapper around the IO device address.",4,[[],["readonly",3]]],[11,"read","","Reads from this Io.",4,[[]]],[11,"readf","","Read from this Io, and mask the value with `flags`.",4,[[]]],[11,"new","","Creates a WriteOnly Io.",5,[[],["writeonly",3]]],[11,"write","","Writes `value` to this Io.",5,[[]]],[0,"cursor","sunrise_libutils","Simple cursor",null,null],[3,"CursorWrite","sunrise_libutils::cursor","A minimal Cursor for writing, for use in libcore.",null,null],[12,"data","","Data backing this cursor.",0,null],[12,"pos","","Position of the cursor in the data.",0,null],[3,"CursorRead","","A minimal Cursor for writing, for use in libcore.",null,null],[12,"data","","Data backing this cursor.",1,null],[12,"pos","","Position of the cursor in the data.",1,null],[11,"new","sunrise_libutils","Creates a new cursor wrapping the provided underlying…",0,[[],["cursorwrite",3]]],[11,"pos","","Returns the current position of this cursor.",0,[[]]],[11,"skip_write","","Skip the given amount of bytes, returning a mutable slice…",0,[[]]],[11,"write_u8","","Writes an u8 in the given byte ordering.",0,[[]]],[11,"write_u16","","Writes a u16 in the given byte ordering.",0,[[]]],[11,"write_u32","","Writes a u32 in the given byte ordering.",0,[[]]],[11,"write_u64","","Writes a u64 in the given byte ordering.",0,[[]]],[11,"write","","Writes the given byte slice entirely.",0,[[]]],[11,"write_raw","","Writes the given structure.",0,[[["copy",8]]]],[11,"new","","Creates a new cursor wrapping the provided underlying…",1,[[],["cursorread",3]]],[11,"pos","","Returns the current position of this cursor.",1,[[]]],[11,"read_u8","","Reads an u8 in the given byteorder.",1,[[]]],[11,"read_u16","","Reads an u16 in the given byteorder.",1,[[]]],[11,"read_u32","","Reads an u32 in the given byteorder.",1,[[]]],[11,"read_u64","","Reads an u64 in the given byteorder.",1,[[]]],[11,"assert","","Reads `v.len()` bytes from the stream, and asserts that it…",1,[[]]],[11,"skip_read","","Skips `bytelen` bytes, returning a slice to them for…",1,[[]]],[11,"read_raw","","Reads the given structure from the bytestream.",1,[[],["copy",8]]],[0,"loop_future","","Definition of the `LoopFn` combinator, implementing…",null,null],[3,"LoopFn","sunrise_libutils::loop_future","A future implementing a tail-recursive loop.",null,null],[12,"future","","Future representing the current loop iteration.",7,null],[12,"func","","Function called on every new iteration to generate that…",7,null],[4,"Loop","","The status of a `loop_fn` loop.",null,null],[13,"Break","","Indicates that the loop has completed with output `T`.",8,null],[13,"Continue","","Indicates that the loop function should be called again…",8,null],[5,"loop_fn","","Creates a new future implementing a tail-recursive loop.",null,[[],["loopfn",3]]],[8,"BitArrayExt","sunrise_libutils","Extension of the [BitField] trait, that adds the…",null,null],[11,"set_bits_area","","Sets a range of bits to `value` in the BitField.",9,[[["range",3]]]],[14,"enum_with_val","","Creates a fake C-like enum, where all bit values are…",null,null],[14,"initialize_to_zero","","A macro to initialize a struct directly in global.",null,null],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","sunrise_libutils::io","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","sunrise_libutils::loop_future","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"into_future","","",7,[[]]],[11,"from","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"read","sunrise_libutils::io","Read",2,[[]]],[11,"write","","Write",2,[[]]],[11,"read","","Read",2,[[]]],[11,"write","","Write",2,[[]]],[11,"read","","Read",2,[[]]],[11,"write","","Write",2,[[]]],[11,"read","","Performs a volatile read of the value.",3,[[]]],[11,"write","","Performs a volatile write of the value.",3,[[]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","Debug volatilely reads `value`.",3,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","Debug does not access the write only value.",5,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","sunrise_libutils","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_libutils::loop_future","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"clone","sunrise_libutils::io","",2,[[],["pio",3]]],[11,"poll","sunrise_libutils::loop_future","",7,[[["context",3],["pin",3]],["poll",4]]]],"p":[[3,"CursorWrite"],[3,"CursorRead"],[3,"Pio"],[3,"Mmio"],[3,"ReadOnly"],[3,"WriteOnly"],[8,"Io"],[3,"LoopFn"],[4,"Loop"],[8,"BitArrayExt"]]},\
"sunrise_loader":{"doc":"Userspace Loader","i":[[3,"PROCESSES","sunrise_loader","",null,null],[12,"__private_field","","",0,null],[3,"PROCESS_STATE_CHANGED","","Public ReadableEvent that gets signaled when a process…",null,null],[12,"__private_field","","",1,null],[3,"BOOT_FROM_FS","","The filesystem to boot titles from.",null,null],[12,"__private_field","","",2,null],[3,"LoaderIface","","Struct implementing the ldr:shel service.",null,null],[5,"boot","","Start the given titleid by loading its content from the…",null,[[["ifilesystemproxy",3]],[["result",4],["pid",3],["error",4]]]],[5,"main","","",null,[[]]],[0,"elf_loader","","Loads Elfs.",null,null],[5,"from_data","sunrise_loader::elf_loader","Turn a byte array into an ELF file.",null,[[],[["elffile",3],["error",4],["result",4]]]],[5,"get_size","","Gets the size of the allocation necessary to load all the…",null,[[["elffile",3]],[["result",4],["error",4]]]],[5,"get_kacs","","Gets the desired kernel access controls for a process…",null,[[["elffile",3]],["option",4]]],[5,"load_file","","Loads the given executable into the given process/address…",null,[[["process",3],["elffile",3]],[["result",4],["error",4]]]],[5,"load_segment","","Loads an elf segment by coping file_size bytes to the…",null,[[["process",3],["elffile",3],["programheader",4]],[["result",4],["error",4]]]],[7,"HEADER","sunrise_loader","",null,null],[7,"CAPABILITIES","","",null,null],[17,"MAX_ELF_SIZE","","Max size of an ELF before we issue a warning. Loader needs…",null,null],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"size","","",3,[[]]],[11,"is_cool","","",3,[[]]],[11,"from_raw_parts","","",3,[[]]],[11,"from_raw_parts_mut","","",3,[[]]],[11,"deref","","",0,[[],["mutex",3]]],[11,"deref","","",1,[[]]],[11,"deref","","",2,[[],["ifilesystemproxy",3]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"clone","","",3,[[],["loaderiface",3]]],[11,"default","","",3,[[],["loaderiface",3]]],[11,"create_title","","",3,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"launch_title","","",3,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"wait","","",3,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"get_state","","",3,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"get_process_state_changed_event","","",3,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"kill","","",3,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"get_name","","",3,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"initialize","","",0,[[]]],[11,"initialize","","",1,[[]]],[11,"initialize","","",2,[[]]]],"p":[[3,"PROCESSES"],[3,"PROCESS_STATE_CHANGED"],[3,"BOOT_FROM_FS"],[3,"LoaderIface"]]},\
"sunrise_shell":{"doc":"Shell","i":[[3,"CURRENT_WORK_DIRECTORY","sunrise_shell","Represent the current work directory.",null,null],[12,"__private_field","","",0,null],[3,"Command","","A command to run as part of a pipeline.",null,null],[12,"args","","Array of arguments to pass to the subcommand. First…",1,null],[12,"redirect_stdin","","The filename to take stdin from.",1,null],[12,"redirect_stdout","","The filename to redirect stdout to.",1,null],[12,"pipe_stdout","","True if stdout should be piped to the next command in the…",1,null],[4,"Job","","Represents a command currently running.",null,null],[13,"BuiltIn","","This job is a builtin running in a separate thread.",2,null],[12,"thread","sunrise_shell::Job","This job\'s underlying thread handle.",3,null],[13,"Process","sunrise_shell","This job is an external binary running in a different…",2,null],[12,"pid","sunrise_shell::Job","This job\'s underlying pid.",4,null],[5,"login","sunrise_shell","Asks the user to login repeatedly. Returns with an error…",null,[[["ifilesystemproxy",3],["terminal",3],["keyboard",3]],[["error",4],["result",4]]]],[5,"get_next_line_no_echo","","Read key presses until a \\\\n is detected, and return the…",null,[[["keyboard",3]],["string",3]]],[5,"get_next_line","","Read key presses until a \\\\n is detected, and return the…",null,[[["terminal",3]],["string",3]]],[5,"parse_line","","Parses a single command from the given string. Returns the…",null,[[]]],[5,"generate_cmd","","Generate a list of command from a given command line.",null,[[],[["vec",3],["command",3]]]],[5,"generate_jobs","","Generate a vector of [Job] from a command line.",null,[[["itwilimanagerserviceproxy",3],["terminal",3],["ifilesystemproxy",3],["iloaderinterfaceproxy",3]],[["result",4],["vec",3],["error",4]]]],[5,"main","","",null,[[]]],[5,"split_path","","Splits a path at the first `/` it encounters.",null,[[]]],[5,"get_absolute_path","","Get an absolute path from an user path",null,[[],["string",3]]],[5,"get_path_relative_to_current_directory","","Get a path relative to the current directory",null,[[],["string",3]]],[5,"cat","","Print a file on the standard output.",null,[[["ifilesystemproxy",3]],[["error",4],["result",4]]]],[0,"subcommands","","Shell builtin subcommands",null,null],[3,"SUBCOMMANDS","sunrise_shell::subcommands","List of subcommands. See module documentation.",null,null],[12,"__private_field","","",5,null],[3,"RunArgs","","The structure sent to the builtin subcommand\'s trampoline…",null,null],[12,"stdin","","Stdin pipe to use for this subcommand.",6,null],[12,"stdout","","Stdout pipe to use for this subcommand.",6,null],[12,"stderr","","Stderr pipe to use for this subcommand.",6,null],[12,"args","","Args to pass to the subcommand\'s main.",6,null],[12,"ret","","Return value of this subcommand.",6,null],[12,"f","","Subcommand\'s main function.",6,null],[5,"run","","Trampoline function for a subcommand thread. Takes a…",null,[[]]],[0,"useradd","","Adds a new user to /etc/passwd with the specified username.",null,null],[5,"main","sunrise_shell::subcommands::useradd","Adds a new user to /etc/passwd with the specified username.",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"showgif","sunrise_shell::subcommands","Show a gif in a new window",null,null],[5,"main","sunrise_shell::subcommands::showgif","Shows a GIF in a new window, blocking the caller. When a…",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"pwd","sunrise_shell::subcommands","Print the current working directory.",null,null],[5,"main","sunrise_shell::subcommands::pwd","Print the current working directory.",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"cd","sunrise_shell::subcommands","Subcommand to change the CWD.",null,null],[5,"main","sunrise_shell::subcommands::cd","Change the current working directory",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"test_threads","sunrise_shell::subcommands","Test function ensuring threads are working properly.",null,null],[5,"main","sunrise_shell::subcommands::test_threads","Test function ensuring threads are working properly.",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"test_divide_by_zero","sunrise_shell::subcommands","Test function ensuring divide by zero interruption kills…",null,null],[5,"main","sunrise_shell::subcommands::test_divide_by_zero","Test function ensuring divide by zero interruption kills…",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"test_page_fault","sunrise_shell::subcommands","Test function ensuring pagefaults kills only the current…",null,null],[5,"main","sunrise_shell::subcommands::test_page_fault","Test function ensuring pagefaults kills only the current…",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"connect","sunrise_shell::subcommands","Test function ensuring SM\'s get_service works.",null,null],[5,"main","sunrise_shell::subcommands::connect","Test function ensuring SM\'s get_service works.",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"ps","sunrise_shell::subcommands","List currently running processes.",null,null],[5,"main","sunrise_shell::subcommands::ps","Get the pid and names of processes currently running.",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"kill","sunrise_shell::subcommands","Kill the provided pid.",null,null],[5,"main","sunrise_shell::subcommands::kill","Kill the process associated with the provided pid.",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"help","sunrise_shell::subcommands","Print the help message.",null,null],[5,"main","sunrise_shell::subcommands::help","Print the help message.",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[0,"exit","sunrise_shell::subcommands","Exits the shell.",null,null],[5,"main","sunrise_shell::subcommands::exit","Print the current working directory.",null,[[["string",3],["ipipeproxy",3],["vec",3]],[["error",4],["result",4]]]],[7,"HELP","","Help string.",null,null],[6,"SubcommandFn","sunrise_shell::subcommands","Subcommand function. See module documentation.",null,null],[7,"HEADER","sunrise_shell","",null,null],[7,"CAPABILITIES","","",null,null],[11,"start","","Let this job start running.",2,[[["iloaderinterfaceproxy",3]],[["error",4],["result",4]]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"from","sunrise_shell::subcommands","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"size","","",5,[[]]],[11,"is_cool","","",5,[[]]],[11,"from_raw_parts","","",5,[[]]],[11,"from_raw_parts_mut","","",5,[[]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"size","","",6,[[]]],[11,"is_cool","","",6,[[]]],[11,"from_raw_parts","","",6,[[]]],[11,"from_raw_parts_mut","","",6,[[]]],[11,"deref","","",5,[[],["btreemap",3]]],[11,"deref","sunrise_shell","",0,[[],["mutex",3]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"initialize","sunrise_shell::subcommands","",5,[[]]],[11,"initialize","sunrise_shell","",0,[[]]]],"p":[[3,"CURRENT_WORK_DIRECTORY"],[3,"Command"],[4,"Job"],[13,"BuiltIn"],[13,"Process"],[3,"SUBCOMMANDS"],[3,"RunArgs"]]},\
"sunrise_sm":{"doc":"Service Manager","i":[[3,"UserInterface","sunrise_sm","`sm:` service interface. The main interface to the Service…",null,null],[3,"SERVICES","","Global mapping of Service Name -> ClientPort.",null,null],[12,"__private_field","","",0,null],[3,"SERVICES_EVENT","","Event signaled whenever a new service is registered.…",null,null],[12,"__private_field","","",1,null],[3,"ServiceName","","Helper type that makes a ServiceName displayable.",null,null],[12,"0","","",2,null],[5,"get_service_length","","Get the length of a service encoded as an u64.",null,[[]]],[5,"get_service_str","","Casts an &u64 into an &str.",null,[[],[["utf8error",3],["result",4]]]],[5,"main","","",null,[[]]],[7,"HEADER","","",null,null],[7,"CAPABILITIES","","",null,null],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"size","","",3,[[]]],[11,"is_cool","","",3,[[]]],[11,"from_raw_parts","","",3,[[]]],[11,"from_raw_parts_mut","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"to_string","","",2,[[],["string",3]]],[11,"deref","","",0,[[],["mutex",3]]],[11,"deref","","",1,[[]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"eq","","",2,[[["servicename",3]]]],[11,"ne","","",2,[[["servicename",3]]]],[11,"cmp","","",2,[[["servicename",3]],["ordering",4]]],[11,"partial_cmp","","",2,[[["servicename",3]],[["option",4],["ordering",4]]]],[11,"lt","","",2,[[["servicename",3]]]],[11,"le","","",2,[[["servicename",3]]]],[11,"gt","","",2,[[["servicename",3]]]],[11,"ge","","",2,[[["servicename",3]]]],[11,"hash","","",2,[[]]],[11,"clone","","",3,[[],["userinterface",3]]],[11,"clone","","",2,[[],["servicename",3]]],[11,"default","","",3,[[],["userinterface",3]]],[11,"initialize","","Initialize the UserInterface, acquiring the Pid of the…",3,[[["workqueue",3],["pid",3]],[["result",4],["futureobj",3]]]],[11,"get_service","","Get a ClientSession to this service.",3,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"register_service","","Register a new service, returning a ServerPort to the…",3,[[["workqueue",3]],[["futureobj",3],["result",4]]]],[11,"unregister_service","","Unregister a service.",3,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"initialize","","",0,[[]]],[11,"initialize","","",1,[[]]]],"p":[[3,"SERVICES"],[3,"SERVICES_EVENT"],[3,"ServiceName"],[3,"UserInterface"]]},\
"sunrise_time":{"doc":"Time Service","i":[[3,"StaticService","sunrise_time","Entry point interface.",null,null],[3,"Rtc","","IBM Real Time Clock provides access to the current date…",null,null],[12,"registers","","Command and Data Register.",0,null],[12,"timestamp","","Last RTC time value.",0,null],[12,"irq_event","","The RTC event.",0,null],[3,"RTCManager","","RTC interface.",null,null],[5,"update_rtc","","Task responsible for updating the RTC_INSTANCE\'s current…",null,[[["workqueue",3]]]],[5,"main","","",null,[[]]],[0,"timezone","","TimeZone module",null,null],[3,"TimeZoneFileSystem","sunrise_time::timezone","Represent the file I/O interface with tzdata.",null,null],[3,"TimeZoneFile","","Represent a file inside a TimeZoneFileSystem.",null,null],[12,"data","","The content of the file.",1,null],[3,"TimeZoneManager","","Global instance handling I/O and storage of the device…",null,null],[12,"location","","The location name of this device.",2,null],[12,"my_rules","","Rules of this device.",2,null],[12,"temp_rules","","Temporary rules storage used during timezone conversion.",2,null],[3,"TimeZoneService","","TimeZone service object.",null,null],[12,"dummy","","A dummy field present to just avoid having a zero sized…",3,null],[5,"calendar_to_tzlib","","Convert a IPC CalendarTime type to a libtimezone…",null,[[["calendartime",3]],["calendartimeinfo",3]]],[5,"calendar_to_ipc","","Convert a libtimezone CalendarInfo to a IPC CalendarTime…",null,[[["calendartime",3]]]],[5,"to_timezone_to_time_error","","Convert a libtimezone TimeZoneError to a IPC Error type.",null,[[["timezoneerror",4]],["error",4]]],[6,"IpcResult","","A IPC result.",null,null],[7,"TIMEZONE_ARCHIVE","","The internal timezone filesystem content.",null,null],[7,"TZ_MANAGER","","Global instance of TimeZoneManager",null,null],[7,"ZEROED_TIME_ZONE_RULE","","Global clear instance of TimeZoneRule used to avoid…",null,null],[11,"from_raw","","Create a TimeZoneFile instance from a raw slice.",1,[[]]],[11,"read_full","","Read the whole file.",1,[[]]],[11,"open_file","","Open a file at the given path in the TimeZone virtual…",4,[[],[["timezonefile",3],["option",4]]]],[11,"file_exist","","Check for a file existance at the given path in the…",4,[[]]],[11,"file_count","","Return the total amount of files in the TimeZone virtual…",4,[[]]],[11,"get_device_location_name","","Get the time zone name used on this devie.",2,[[],["locationname",6]]],[11,"set_device_location_name","","Set the time zone name used on this devie.",2,[[["locationname",6]],[["result",4],["error",4]]]],[11,"set_device_location_name_unchecked","","Set the time zone name used on this devie.",2,[[["locationname",6]]]],[11,"get_total_location_name_count","","Get the total count of location name available",2,[[],[["error",4],["result",4]]]],[11,"load_timezone_rule","","Load a time zone rule.",2,[[["option",4],["timezonerule",3],["locationname",6]],[["result",4],["error",4]]]],[11,"get_my_rules","","Get the device timezone rule.",2,[[],["timezonerule",3]]],[7,"HEADER","sunrise_time","",null,null],[7,"CAPABILITIES","","",null,null],[7,"RTC_INSTANCE","","Global instance of Rtc.",null,null],[11,"new","","Create a new RTC with the default IBM PC values.",0,[[],["rtc",3]]],[11,"get_time","","Get the last timestamp of the RTC.",0,[[]]],[11,"get_irq_event_handle","","Get the update event of the RTC. TODO: Implement…",0,[[],["handleref",3]]],[11,"read_reg","","Read from a CMOS register.",0,[[]]],[11,"write_reg","","Write to the CMOS register.",0,[[]]],[11,"enable_update_ended_int","","Enable the Update Ended RTC interrupt. This will enable an…",0,[[]]],[11,"read_interrupt_kind","","Acknowledges an interrupt from the RTC. Necessary to…",0,[[]]],[11,"is_12hr_clock","","Checks if the RTC is in 12 hours or 24 hours mode.…",0,[[]]],[11,"from","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"size","","",5,[[]]],[11,"is_cool","","",5,[[]]],[11,"from_raw_parts","","",5,[[]]],[11,"from_raw_parts_mut","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"size","","",6,[[]]],[11,"is_cool","","",6,[[]]],[11,"from_raw_parts","","",6,[[]]],[11,"from_raw_parts_mut","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"from","sunrise_time::timezone","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"size","","",4,[[]]],[11,"is_cool","","",4,[[]]],[11,"from_raw_parts","","",4,[[]]],[11,"from_raw_parts_mut","","",4,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"from","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"size","","",3,[[]]],[11,"is_cool","","",3,[[]]],[11,"from_raw_parts","","",3,[[]]],[11,"from_raw_parts_mut","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_time","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"clone","sunrise_time::timezone","",3,[[],["timezoneservice",3]]],[11,"clone","sunrise_time","",5,[[],["staticservice",3]]],[11,"clone","","",6,[[],["rtcmanager",3]]],[11,"default","sunrise_time::timezone","",3,[[],["timezoneservice",3]]],[11,"default","sunrise_time","",5,[[],["staticservice",3]]],[11,"default","","",0,[[]]],[11,"default","","",6,[[],["rtcmanager",3]]],[11,"get_device_location_name","sunrise_time::timezone","",3,[[["workqueue",3]],[["result",4],["error",4],["locationname",6]]]],[11,"set_device_location_name","","",3,[[["workqueue",3],["locationname",6]],[["result",4],["error",4]]]],[11,"get_total_location_name_count","","",3,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"load_location_name_list","","",3,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"load_timezone_rule","","",3,[[["ipctimezonerule",6],["workqueue",3],["locationname",6]],[["result",4],["error",4]]]],[11,"to_calendar_time","","",3,[[["posixtime",6],["workqueue",3],["ipctimezonerule",6]],[["result",4],["error",4]]]],[11,"to_calendar_time_with_my_rule","","",3,[[["posixtime",6],["workqueue",3]],[["result",4],["error",4]]]],[11,"to_posix_time","","",3,[[["calendartime",3],["ipctimezonerule",6],["workqueue",3]],[["result",4],["posixtime",6],["error",4]]]],[11,"to_posix_time_with_my_rule","","",3,[[["calendartime",3],["workqueue",3]],[["result",4],["posixtime",6],["error",4]]]],[11,"get_rtc_time","sunrise_time","",6,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"get_rtc_event","","",6,[[["workqueue",3]],[["error",4],["result",4],["handleref",3]]]],[11,"get_timezone_service","","",5,[[["workqueue",3]],[["result",4],["error",4],["timezoneserviceproxy",3]]]]],"p":[[3,"Rtc"],[3,"TimeZoneFile"],[3,"TimeZoneManager"],[3,"TimeZoneService"],[3,"TimeZoneFileSystem"],[3,"StaticService"],[3,"RTCManager"]]},\
"sunrise_vi":{"doc":"Visual Compositor","i":[[3,"ViInterface","sunrise_vi","Entry point interface.",null,null],[3,"Buffer","","Internal representation of a window.",null,null],[12,"top","","",0,null],[12,"left","","",0,null],[12,"width","","",0,null],[12,"height","","",0,null],[12,"mem","","",0,null],[3,"IBuffer","","IPC Window object",null,null],[12,"buffer","","The Buffer linked with this window object instance.",1,null],[5,"get_intersect","","Gets the intersection between two rectangles.",null,[[],["option",4]]],[5,"draw","","Draw a portion of a buffer onto the framebuffer.",null,[[["buffer",3],["framebuffer",3]]]],[5,"get_real_bounds","","See [Buffer::get_real_bounds].",null,[[]]],[5,"main","","",null,[[]]],[0,"vbe","","VESA Bios Extensions Framebuffer",null,null],[3,"VBEColor","sunrise_vi::vbe","A rgb color",null,null],[12,"b","","",2,null],[12,"g","","",2,null],[12,"r","","",2,null],[12,"a","","",2,null],[3,"Framebuffer","","A wrapper around a linear framebuffer. The framebuffer is…",null,null],[12,"buf","","",3,null],[12,"width","","",3,null],[12,"height","","",3,null],[12,"bpp","","Bits-per-pixel. Usually 8.",3,null],[3,"FRAMEBUFFER","","",null,null],[12,"__private_field","","",4,null],[11,"rgb","","Creates a VBEColor from the given red/green/blue…",2,[[],["vbecolor",3]]],[11,"new","","Creates an instance of the linear framebuffer.",3,[[],[["result",4],["framebuffer",3],["error",4]]]],[11,"new_buffer","","Creates a backbuffer backed by an in-memory array.",3,[[],["framebuffer",3]]],[11,"width","","framebuffer width in pixels. Does not account for bpp",3,[[]]],[11,"height","","framebuffer height in pixels. Does not account for bpp",3,[[]]],[11,"bpp","","The number of bits that forms a pixel. Used to compute…",3,[[]]],[11,"get_px_offset","","Gets the offset in memory of a pixel based on an x and y.",3,[[]]],[11,"write_px","","Writes a pixel in the framebuffer respecting the bgr pattern",3,[[["vbecolor",3]]]],[11,"write_px_at","","Writes a pixel in the framebuffer respecting the bgr…",3,[[["vbecolor",3]]]],[11,"get_fb","","Gets the underlying framebuffer",3,[[]]],[11,"clear","","Clears the whole screen",3,[[]]],[11,"clear_at","","Clears a segment of the screen.",3,[[]]],[0,"terminal","sunrise_vi","Terminal rendering APIs",null,null],[3,"Pos","sunrise_vi::terminal","Just an x and a y",null,null],[12,"x","","",5,null],[12,"y","","",5,null],[3,"Terminal","","A struct for logging text to the window. Renders…",null,null],[12,"framebuffer","","Rendering target for this terminal.",6,null],[12,"cursor_pos","","Cursor pos, in pixels. Does not account for bpp.…",6,null],[12,"font","","The font in use for this terminal.",6,null],[12,"cached_glyphs","","We cache ascii glyphs to avoid rendering them every time.",6,null],[12,"advance_width","","Expected to be the same for every glyph since it should be…",6,null],[12,"linespace","","The distance between two baselines.",6,null],[12,"ascent","","The maximum ascent in the font.",6,null],[12,"descent","","The maximum descent in the font.",6,null],[3,"TerminalPipe","","Twili IPipe implementation on a Vi Terminal.",null,null],[12,"terminal","","Inner terminal.",7,null],[5,"font_height","","Get the height of the built-in monospaced font.",null,[[]]],[7,"FONT","","The font we choose to render in",null,null],[17,"FONT_SIZE","","The size we choose to render in",null,null],[11,"new","","Creates a new Window of the requested size for terminal…",6,[[["sharedmemory",3]],[["result",4],["error",4]]]],[11,"draw","","Ask the compositor to redraw the window.",6,[[]]],[11,"carriage_return","","Move the cursor to the beginning of the current line.",6,[[]]],[11,"line_feed","","Move the cursor to the beginning of the next line,…",6,[[]]],[11,"advance_pos","","Move the cursor to the next position for drawing a…",6,[[]]],[11,"move_pos_back","","Move the cursor back to the previous position. If we are…",6,[[]]],[11,"scroll_screen","","scrolls the whole screen by one line. self.pos must be on…",6,[[]]],[11,"clear","","Clears the whole screen and reset cursor",6,[[]]],[11,"print_attr","","Prints a string to the screen with attributes",6,[[["color",3]]]],[11,"display_glyph_in_box","","Copies a rendered character to the screen, displaying it…",6,[[["buffer",3],["color",3],["glyphbitmap",3],["pos",3]]]],[11,"new","","Create a new TerminalPipe from an existing Terminal.",7,[[["terminal",3]],["terminalpipe",3]]],[7,"BUFFERS","sunrise_vi","A list of the buffers currently alive.",null,null],[7,"BACKBUFFER_ARR","","The backbuffer to draw into.",null,null],[7,"HEADER","","",null,null],[7,"CAPABILITIES","","",null,null],[11,"get_real_bounds","","Returns the buffer\'s bounds within the given width/height,…",0,[[]]],[11,"width","","Get the width of this buffer.",0,[[]]],[11,"height","","Get the height of this buffer.",0,[[]]],[11,"get_buffer","","Gets the underlying framebuffer",0,[[]]],[11,"get_px_offset","","Gets the offset in memory of a pixel based on an x and y.",0,[[]]],[11,"draw","","Blit the buffer to the framebuffer.",0,[[]]],[11,"from","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"into","","",8,[[]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"size","","",8,[[]]],[11,"is_cool","","",8,[[]]],[11,"from_raw_parts","","",8,[[]]],[11,"from_raw_parts_mut","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]],[11,"from","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"into","","",1,[[]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"size","","",1,[[]]],[11,"is_cool","","",1,[[]]],[11,"from_raw_parts","","",1,[[]]],[11,"from_raw_parts_mut","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"from","sunrise_vi::vbe","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"into","","",2,[[]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"size","","",2,[[]]],[11,"is_cool","","",2,[[]]],[11,"from_raw_parts","","",2,[[]]],[11,"from_raw_parts_mut","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"from","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"into","","",3,[[]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"size","","",3,[[]]],[11,"is_cool","","",3,[[]]],[11,"from_raw_parts","","",3,[[]]],[11,"from_raw_parts_mut","","",3,[[]]],[11,"from","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"into","","",4,[[]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"size","","",4,[[]]],[11,"is_cool","","",4,[[]]],[11,"from_raw_parts","","",4,[[]]],[11,"from_raw_parts_mut","","",4,[[]]],[11,"from","sunrise_vi::terminal","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"into","","",5,[[]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"size","","",5,[[]]],[11,"is_cool","","",5,[[]]],[11,"from_raw_parts","","",5,[[]]],[11,"from_raw_parts_mut","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"from","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"into","","",6,[[]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"size","","",6,[[]]],[11,"is_cool","","",6,[[]]],[11,"from_raw_parts","","",6,[[]]],[11,"from_raw_parts_mut","","",6,[[]]],[11,"from","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"into","","",7,[[]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"size","","",7,[[]]],[11,"is_cool","","",7,[[]]],[11,"from_raw_parts","","",7,[[]]],[11,"from_raw_parts_mut","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"deref","sunrise_vi::vbe","",4,[[],["mutex",3]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_vi::terminal","",5,[[["formatter",3]],["result",6]]],[11,"fmt","sunrise_vi","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"drop","","Redraw the zone where the buffer was when dropping it, to…",1,[[]]],[11,"write_str","sunrise_vi::terminal","",6,[[],[["result",4],["error",3]]]],[11,"clone","sunrise_vi::vbe","",2,[[],["vbecolor",3]]],[11,"clone","sunrise_vi::terminal","",5,[[],["pos",3]]],[11,"clone","","",7,[[],["terminalpipe",3]]],[11,"clone","sunrise_vi","",8,[[],["viinterface",3]]],[11,"clone","","",1,[[],["ibuffer",3]]],[11,"default","","",8,[[],["viinterface",3]]],[11,"create_buffer","","Create a window.",8,[[["workqueue",3],["sharedmemory",3]],[["error",4],["ibufferproxy",3],["result",4]]]],[11,"get_screen_resolution","","Gets the screen (width, height) in pixels.",8,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"get_font_height","","",8,[[["workqueue",3]],[["error",4],["result",4]]]],[11,"create_terminal","","",8,[[["workqueue",3],["sharedmemory",3]],[["result",4],["error",4],["ipipeproxy",3]]]],[11,"draw","","Blit the buffer to the framebuffer.",1,[[["workqueue",3]],[["result",4],["error",4]]]],[11,"read","sunrise_vi::terminal","",7,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"write","","",7,[[["workqueue",3]],[["result",4],["futureobj",3]]]],[11,"initialize","sunrise_vi::vbe","",4,[[]]]],"p":[[3,"Buffer"],[3,"IBuffer"],[3,"VBEColor"],[3,"Framebuffer"],[3,"FRAMEBUFFER"],[3,"Pos"],[3,"Terminal"],[3,"TerminalPipe"],[3,"ViInterface"]]},\
"sunrise_wall_clock":{"doc":"Clock applet","i":[[3,"TimeZoneRuleWrapper","sunrise_wall_clock","Wrapper to a TimeZoneRule to enforce alignment requirement",null,null],[12,"inner","","The timezone rule",0,null],[5,"get_day_of_week","","Turns a day of week number from RTC into an english…",null,[[]]],[5,"get_month","","Turns a month number from RTC into an english string.",null,[[]]],[5,"write_calendar","","Write a wall clock time into the terminal.",null,[[["terminal",3],["bstr",3]]]],[5,"main","","",null,[[]]],[7,"TIMEZONE_RULE","","An instance to a custom TimeZoneRule",null,null],[7,"HEADER","","",null,null],[7,"CAPABILITIES","","",null,null],[11,"from","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"size","","",0,[[]]],[11,"is_cool","","",0,[[]]],[11,"from_raw_parts","","",0,[[]]],[11,"from_raw_parts_mut","","",0,[[]]]],"p":[[3,"TimeZoneRuleWrapper"]]},\
"swipc_gen":{"doc":"SwIPC Code Generator","i":[[5,"generate_ipc","swipc_gen","Generate a module containing all the functions in the…",null,[[["string",3]],["string",3]]],[0,"gen_rust_code","","Code generation implementation",null,null],[3,"BUILTINS","swipc_gen::gen_rust_code","SwIPC builtin type. Associates a SwIPC builtin name with a…",null,null],[12,"__private_field","","",0,null],[3,"Mod","","A module hierarchy.",null,null],[12,"types","","Generated code for the types at the current level of the…",1,null],[12,"ifaces","","Generated code for the ifaces at the current level of the…",1,null],[12,"mods","","Mapping from string to submodule hierarchy.",1,null],[4,"Error","","Internal error type. Raised whenever we fail to generate…",null,null],[13,"UnsupportedStruct","","This generation unit contains an unsupported type. We…",2,null],[5,"remap_keywords","","Rename field names that would conflict with rust keywords.",null,[[]]],[5,"is_raw","","Checks if an alias contains a raw data type (as opposed to…",null,[[["alias",4]]]],[5,"named_iterator","","Takes an iterator of potentially unnamed…",null,[[]]],[5,"raw_iterator","","Creates an iterator over the raw values from an…",null,[[]]],[5,"format_args","","Format the arguments of a function.",null,[[],[["string",3],["error",4],["result",4]]]],[5,"format_ret_ty","","Format the return type of a function.",null,[[],[["string",3],["error",4],["result",4]]]],[5,"get_handle_type","","Get the Rust equivalent of a handle type.",null,[[["option",4]],["option",4]]],[5,"format_ret","","Generate code to recover a single return value from an…",null,[[],[["string",3],["error",4],["result",4]]]],[5,"get_type","","Get the Rust type of an [Alias]. If output is true, then…",null,[[["alias",4]],[["string",3],["error",4],["result",4]]]],[5,"gen_in_raw","","Generates the InRaw structure from the argument list of a…",null,[[["string",3],["func",3]],[["result",4],["error",4]]]],[5,"gen_out_raw","","Generates the OutRaw structure from the return param list…",null,[[["string",3],["func",3]],[["result",4],["error",4]]]],[5,"format_cmd","","Generate code for a single function.",null,[[["func",3]],[["string",3],["error",4],["result",4]]]],[5,"format_type","","Create a new type definition. For a `TypeDef::Struct`,…",null,[[["typedef",3]],[["string",3],["error",4],["result",4]]]],[5,"generate_mod","","Generate the module hierarchy. The depth should be set to…",null,[[["mod",3]],["string",3]]],[5,"gen_call","","Parse an incoming request, call the appropriate function…",null,[[["func",3]],[["string",3],["error",4],["result",4]]]],[5,"generate_trait_async","","Generate a trait representing an async IPC interface.…",null,[[["interface",3]],["string",3]]],[5,"generate_trait","","Generate a trait representing an IPC interface.…",null,[[["interface",3]],["string",3]]],[5,"generate_proxy","","Generate a \\\"proxy\\\" interface (nomenclature shamelessly…",null,[[["interface",3]],["string",3]]],[5,"generate_ipc","","Generate a module containing all the functions in the…",null,[[["string",3]],["string",3]]],[0,"itemmod","swipc_gen","Mod parser",null,null],[3,"ItemMod","swipc_gen::itemmod","A module or module declaration: `mod m` or `mod m { ... }`.",null,null],[12,"attrs","","",3,null],[12,"vis","","",3,null],[12,"mod_token","","",3,null],[12,"ident","","",3,null],[12,"content","","Optional content of the module. The TokenStream contains…",3,null],[12,"semi","","",3,null],[11,"from","swipc_gen::gen_rust_code","",0,[[]]],[11,"into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","swipc_gen::itemmod","",3,[[]]],[11,"into","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"deref","swipc_gen::gen_rust_code","",0,[[],["hashmap",3]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"initialize","","",0,[[]]],[11,"parse","swipc_gen::itemmod","",3,[[["parsestream",6]],["result",6]]]],"p":[[3,"BUILTINS"],[3,"Mod"],[4,"Error"],[3,"ItemMod"]]},\
"swipc_parser":{"doc":"Efficient parser for the SwIPC files","i":[[3,"TypeDef","swipc_parser","A new type definition.",null,null],[12,"doc","","",0,null],[12,"name","","",0,null],[12,"ty","","",0,null],[3,"Struct","","Struct definition.",null,null],[12,"size","","",1,null],[12,"fields","","",1,null],[3,"Enum","","Enum definition.",null,null],[12,"tyname","","",2,null],[12,"fields","","",2,null],[3,"Func","","A function on an interface.",null,null],[12,"doc","","",3,null],[12,"decorators","","",3,null],[12,"num","","",3,null],[12,"name","","",3,null],[12,"args","","",3,null],[12,"ret","","",3,null],[3,"Interface","","An interface definition.",null,null],[12,"doc","","",4,null],[12,"name","","",4,null],[12,"service_list","","",4,null],[12,"funcs","","",4,null],[3,"Ctx","","The context returned by a successful parse. Contains…",null,null],[12,"types","","",5,null],[12,"interfaces","","",5,null],[4,"HandleType","","Type of a Handle. Represents all the kernel handle types…",null,null],[13,"Process","","",6,null],[13,"Thread","","",6,null],[13,"Debug","","",6,null],[13,"CodeMemory","","",6,null],[13,"TransferMemory","","",6,null],[13,"SharedMemory","","",6,null],[13,"ServerPort","","",6,null],[13,"ClientPort","","",6,null],[13,"ServerSession","","",6,null],[13,"ClientSession","","",6,null],[13,"ServerLightSession","","",6,null],[13,"ClientLightSession","","",6,null],[13,"ReadableEvent","","",6,null],[13,"WritableEvent","","",6,null],[13,"IrqEvent","","",6,null],[13,"DeviceAddressSpace","","",6,null],[4,"Alias","","A type alias.",null,null],[13,"Array","","Buffer Array. Equivalent to buffer<data_type,…",7,null],[13,"Buffer","","An IPC Buffer transfering untyped data. First argument…",7,null],[13,"Object","","An IPC Object implementing the given interface.",7,null],[13,"Bytes","","A byte blob of the given size.",7,null],[13,"Align","","Forces the alignment to the given size for the given…",7,null],[13,"Handle","","A Kernel Handle of the given type. If the first argument…",7,null],[13,"Pid","","A Pid.",7,null],[13,"Other","","Either a builtin or another structure.",7,null],[4,"Type","","A new type definition.",null,null],[13,"Struct","","Creates a new structure",8,null],[13,"Enum","","Creates a new enum",8,null],[13,"Alias","","Creates a new type alias",8,null],[4,"Decorator","","Represents a decorator.",null,null],[13,"Undocumented","","Can be attached to a function to specify that its types…",9,null],[13,"Version","","Can be attached to a function to specify that the function…",9,null],[13,"ManagedPort","","Can be attached to a service to tag it as a kernel-managed…",9,null],[13,"Unknown","","A decorator not known by this parser.",9,null],[4,"Def","","A top-level item. Can either be a type definition, or an…",null,null],[13,"Type","","",10,null],[13,"Interface","","",10,null],[5,"parse_comment","","",null,[[["pairs",3]],["string",3]]],[5,"parse_name","","",null,[[["pairs",3]]]],[5,"parse_number","","",null,[[["pairs",3]]]],[5,"parse_struct","","",null,[[["pairs",3],["rule",4]],["struct",3]]],[5,"parse_enum","","",null,[[["pairs",3],["rule",4]],["enum",3]]],[5,"parse_alias","","",null,[[["pairs",3],["rule",4]],["alias",4]]],[5,"parse_type","","",null,[[["pairs",3]],["type",4]]],[5,"parse_type_def","","",null,[[["pairs",3],["rule",4]],["typedef",3]]],[5,"parse_service_name_list","","",null,[[["pairs",3]],["vec",3]]],[5,"parse_version_number","","",null,[[["pairs",3]],["string",3]]],[5,"parse_decorators","","",null,[[["pairs",3]],[["vec",3],["decorator",4]]]],[5,"parse_named_type","","",null,[[["pair",3],["rule",4]]]],[5,"parse_named_tuple","","",null,[[["pairs",3]],["vec",3]]],[5,"parse_func","","",null,[[["pair",3],["rule",4]],["func",3]]],[5,"parse_interface","","",null,[[["pairs",3],["rule",4]],["interface",3]]],[5,"parse_def","","",null,[[["pairs",3],["rule",4]],["def",4]]],[5,"parse","","Parse the given string into a SwIPC [Ctx].",null,[[],["ctx",3]]],[0,"pest_parser","","",null,null],[3,"SwipcParser","swipc_parser::pest_parser","",null,null],[4,"Rule","","",null,null],[13,"EOI","","",11,null],[13,"start","","",11,null],[13,"number","","",11,null],[13,"def","","",11,null],[13,"expression","","",11,null],[13,"name","","",11,null],[13,"iname","","",11,null],[13,"sname","","",11,null],[13,"serviceNameList","","",11,null],[13,"structField","","",11,null],[13,"enumField","","",11,null],[13,"structTemplate","","",11,null],[13,"structure","","",11,null],[13,"enumeration","","",11,null],[13,"aliasArray","","",11,null],[13,"aliasBuffer","","",11,null],[13,"aliasObject","","",11,null],[13,"aliasBytes","","",11,null],[13,"aliasAlign","","",11,null],[13,"aliasPid","","",11,null],[13,"handleIsCopy","","",11,null],[13,"handleType","","",11,null],[13,"aliasHandle","","",11,null],[13,"alias","","",11,null],[13,"ty","","",11,null],[13,"typeDef","","",11,null],[13,"interface","","",11,null],[13,"namedTuple","","",11,null],[13,"namedType","","",11,null],[13,"comment","","",11,null],[13,"versionNumber","","",11,null],[13,"range","","",11,null],[13,"decorator","","",11,null],[13,"versionPlus","","",11,null],[13,"versionDecorator","","",11,null],[13,"undocumentedDecorator","","",11,null],[13,"managedportDecorator","","",11,null],[13,"unknownDecorator","","",11,null],[13,"funcDef","","",11,null],[13,"WHITESPACE","","",11,null],[13,"COMMENT","","",11,null],[17,"_PEST_GRAMMAR_SwipcParser","","",null,null],[11,"from","swipc_parser","",0,[[]]],[11,"into","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","swipc_parser::pest_parser","",12,[[]]],[11,"into","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"clone","","",11,[[],["rule",4]]],[11,"cmp","","",11,[[["rule",4]],["ordering",4]]],[11,"eq","","",11,[[["rule",4]]]],[11,"partial_cmp","","",11,[[["rule",4]],[["option",4],["ordering",4]]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"fmt","swipc_parser","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"hash","swipc_parser::pest_parser","",11,[[]]],[11,"parse","","",12,[[["rule",4]],[["pairs",3],["error",3],["result",4]]]]],"p":[[3,"TypeDef"],[3,"Struct"],[3,"Enum"],[3,"Func"],[3,"Interface"],[3,"Ctx"],[4,"HandleType"],[4,"Alias"],[4,"Type"],[4,"Decorator"],[4,"Def"],[4,"Rule"],[3,"SwipcParser"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);